<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Track Lab</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/browser-id3-writer@4.4.0/dist/browser-id3-writer.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=B612+Mono:wght@400;700&family=Barlow+Condensed:ital,wght@0,400;0,600;0,700;0,800;1,400;1,700&family=Bebas+Neue&family=Oswald:wght@400;600;700&family=Anonymous+Pro:ital,wght@0,400;0,700;1,400&family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&family=IBM+Plex+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Roboto+Condensed:ital,wght@0,400;0,700;1,400;1,700&family=Anton&family=Black+Ops+One&family=Teko:wght@400;600;700&family=Rajdhani:wght@400;600;700&family=Saira+Condensed:wght@400;700;900&family=Orbitron:wght@400;700;900&family=Exo+2:ital,wght@0,400;0,700;1,400&family=Chakra+Petch:ital,wght@0,400;0,700;1,400&family=Major+Mono+Display&family=VT323&family=Press+Start+2P&family=Audiowide&family=Aldrich&family=Gruppo&family=Syncopate:wght@400;700&family=Michroma&family=Jura:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;0,900;1,400;1,700&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=IM+Fell+English:ital@0;1&family=Cinzel:wght@400;700;900&family=Cormorant+Garamond:ital,wght@0,400;0,700;1,400&family=Alfa+Slab+One&family=Archivo+Black&family=Passion+One:wght@400;700;900&family=Alfa+Slab+One&family=Righteous&family=Bungee&family=Staatliches&family=Six+Caps&family=Pathway+Gothic+One&family=Fjalla+One&family=Graduate&family=Stint+Ultra+Condensed&family=Special+Elite&family=Rye&family=Permanent+Marker&family=Caveat:wght@400;700&family=Kalam:wght@400;700&family=Patrick+Hand&display=swap" rel="stylesheet">
<style>
*{box-sizing:border-box;}
html,body{margin:0;height:100%;overflow-x:hidden;overflow-y:auto;background:var(--app-bg,#06060a);}
body{font-family:'Share Tech Mono',monospace;}
#root{height:100%;}
::-webkit-scrollbar{width:4px;height:4px;}
::-webkit-scrollbar-track{background:var(--app-bg);}
::-webkit-scrollbar-thumb{background:var(--app-border);border-radius:2px;}
input[type=color]{-webkit-appearance:none;border:none;padding:0;cursor:pointer;width:26px;height:20px;border-radius:2px;background:none;}
input[type=color]::-webkit-color-swatch-wrapper{padding:0;}
input[type=color]::-webkit-color-swatch{border:none;border-radius:2px;}
input[type=range]{-webkit-appearance:none;appearance:none;height:3px;border-radius:2px;background:var(--app-border);outline:none;cursor:pointer;}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:10px;height:10px;border-radius:50%;background:var(--app-accent);cursor:pointer;}
select{vertical-align:middle;line-height:1.4;}
select option{vertical-align:middle;padding-top:2px;padding-bottom:2px;}
@keyframes tl-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
.tl-spin{animation:tl-spin 0.7s linear infinite;display:inline-block;}
@keyframes tl-peak-blink{0%,100%{opacity:1;transform:scale(1)}50%{opacity:0.15;transform:scale(0.7)}}
.tl-peak-blink{animation:tl-peak-blink 0.9s ease-in-out infinite;}
.tl-metric-wrap{position:relative;flex:1;min-width:0;}
.tl-metric-tooltip{
  position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);
  width:260px;max-width:90vw;
  background:#1a1a22;border:1px solid #444;border-radius:4px;
  padding:10px 12px;z-index:200;pointer-events:none;
  opacity:0;transition:opacity 0.12s ease;
  box-shadow:0 4px 20px rgba(0,0,0,0.6);
}
.tl-metric-wrap:hover .tl-metric-tooltip{opacity:1;}
.tl-metric-tooltip::after{
  content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);
  border:6px solid transparent;border-top-color:#444;
}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback, useMemo } = React;
// ━━━━━━━━ VERSION ━━━━━━━━
const VERSION='0.4.3';
// ━━━━━━━━ CLASSIFICATION ━━━━━━━━
const CLS={
  digit1:{name:'Primary Genre / Style',options:{
    '1':'Ambient / Atmospheric','2':'Techno / Industrial','3':'House / Dance','4':'Downtempo / Chillout',
    '5':'Experimental / Glitch','6':'Synthwave / Retro','7':'Drum & Bass / Breakbeat','8':'Trance / Progressive',
    '9':'Minimal / Micro','A':'Noise / Power Electronics','B':'Field Recording / Concrete','C':'Jazz / Fusion',
    'D':'Classical / Orchestral','E':'Folk / Acoustic','F':'Hip-Hop / Rap','G':'Reggae / Dub',
    'H':'Metal / Hardcore','I':'Pop','J':'Drone / Dark Ambient','K':'Post-Rock / Cinematic',
    'L':'EBM / Industrial Dance','M':'Krautrock / Motorik','N':'Musique Concrète','O':'Rave / Hardcore Techno',
    'P':'Psych / Kosmische','Q':'Neo-Classical / Modern','R':'Lo-Fi / Bedroom','S':'Rock',
    'T':'Punk / Post-Punk','U':'Soul / R&B / Funk','V':'Country / Americana','W':'Blues',
    'X':'World / Global','Y':'Electronic / Electronica','Z':'Unclassified / Other',
  }},
  digit2:{name:'Mood / Energy / Affect',options:{
    '0':'Dark / Melancholic','1':'Ethereal / Dreamy','2':'Energetic / Driving','3':'Calm / Meditative',
    '4':'Mysterious / Cinematic','5':'Uplifting / Euphoric','6':'Aggressive / Intense','7':'Nostalgic / Warm',
    '8':'Cold / Clinical','9':'Playful / Quirky','A':'Brooding / Tense','B':'Hypnotic / Trance-like',
    'C':'Melancholic / Bittersweet','D':'Chaotic / Dissonant','E':'Serene / Peaceful','F':'Unsettling / Uncanny',
    'G':'Triumphant / Anthemic','H':'Introspective / Private','I':'Romantic / Sensual','J':'Mechanical / Robotic',
    'K':'Spiritual / Transcendent','L':'Ironic / Detached','M':'Raw / Visceral','N':'Blissful / Elated',
    'O':'Desolate / Isolated','P':'Urgent / Pressurised','Q':'Tense / Anxious','R':'Joyful / Celebratory',
    'S':'Melancholic / Pensive','T':'Confrontational','U':'Defiant / Rebellious','V':'Tender / Vulnerable',
    'W':'Grotesque / Absurd','X':'Clinical / Detached','Y':'Ecstatic / Frenetic','Z':'Neutral / Affectless',
  }},
  digit3:{name:'Tempo / Rhythmic Feel',options:{
    '0':'0–60 BPM (Glacial)','1':'60–80 BPM (Slow)','2':'80–100 BPM (Moderate)','3':'100–120 BPM (Medium)',
    '4':'120–130 BPM (Uptempo)','5':'130–140 BPM (Fast)','6':'140–160 BPM (Very Fast)','7':'160–180 BPM (Rapid)',
    '8':'180+ BPM (Extreme)','9':'Variable / Rubato','A':'No Tempo / Free Time','B':'Half-time Feel',
    'C':'Double-time Feel','D':'Polyrhythmic / Complex','E':'Swing / Shuffle','F':'Broken / Irregular',
    'G':'Pulseless / Drone','H':'Stuttered / Chopped','I':'Waltz / 3-4','J':'Odd Meter (5,7,11)',
    'K':'4/4 Straight','L':'Syncopated','M':'Gallop / Triplet','N':'March / 2-beat',
    'O':'Samba / Baião','P':'Afrobeat / Afro-Cuban','Q':'Breakbeat / Hip-Hop','R':'Jungle / Ragga',
    'S':'Footwork / Juke','T':'IDM / Drill n Bass','U':'Trap / 808','V':'Garage / 2-step',
    'W':'Dubstep / Grime','X':'Industrial / EBM Pulse','Y':'Ambient Pulse / Slow Drift','Z':'No Rhythm / Noise',
  }},
  digit4:{name:'Texture / Density / Arrangement',options:{
    '0':'Sparse / Minimal','1':'Light / Airy','2':'Moderate','3':'Layered','4':'Dense / Full',
    '5':'Heavy / Thick','6':'Rhythmic Focus','7':'Melodic Focus','8':'Textural / Drone','9':'Complex / Chaotic',
    'A':'Single Element','B':'Call & Response','C':'Evolving / Morphing','D':'Repetitive / Locked',
    'E':'Granular / Fragmented','F':'Saturated / Distorted','G':'Acoustic / Natural','H':'Synthetic Only',
    'I':'Mixed / Hybrid','J':'Collage / Found Sound','K':'Micro-tonal','L':'Silent / Near-Silence',
    'M':'Noise / Wall','N':'Harmonic / Tonal','O':'Atonal / Dissonant','P':'Arpeggiated / Sequenced',
    'Q':'Pad-Heavy / Washed','R':'Sample-Based','S':'Vocal-Forward','T':'Bass-Heavy / Sub',
    'U':'Treble / High Frequency','V':'Mid-Range Focus','W':'Binaural / Spatial','X':'Stereo Field Play',
    'Y':'Mono / Centered','Z':'Unstructured / Free',
  }},
};
// ━━━━━━━━ useHistory — generic 50-step undo/redo stack ━━━━━━━━
// push(snapshot)  — record new state; trims redo branch above cursor.
// undo()          — step back, returns the previous snapshot.
// redo()          — step forward, returns the next snapshot.
const HISTORY_MAX=50;
function useHistory(initial){
  const [history,setHistory]=useState([initial]);
  const [cursor,setCursor]=useState(0);
  const cursorRef=useRef(0);
  const historyRef=useRef([initial]);
  useEffect(()=>{cursorRef.current=cursor;},[cursor]);
  useEffect(()=>{historyRef.current=history;},[history]);

  const push=useCallback((snapshot)=>{
    const cur=cursorRef.current;
    const hist=historyRef.current;
    const base=hist.slice(0,cur+1);
    const next=[...base,snapshot];
    const trimmed=next.length>HISTORY_MAX?next.slice(next.length-HISTORY_MAX):next;
    const newCursor=trimmed.length-1;
    historyRef.current=trimmed;
    cursorRef.current=newCursor;
    setHistory(trimmed);
    setCursor(newCursor);
  },[]);

  const undo=useCallback(()=>{
    const cur=cursorRef.current;
    const hist=historyRef.current;
    if(cur<=0)return null;
    const newCursor=cur-1;
    cursorRef.current=newCursor;
    setCursor(newCursor);
    return hist[newCursor];
  },[]);

  const redo=useCallback(()=>{
    const cur=cursorRef.current;
    const hist=historyRef.current;
    if(cur>=hist.length-1)return null;
    const newCursor=cur+1;
    cursorRef.current=newCursor;
    setCursor(newCursor);
    return hist[newCursor];
  },[]);

  // Reactive values for render
  const canUndo=cursor>0;
  const canRedo=cursor<history.length-1;
  const steps=cursor;

  return{push,undo,redo,canUndo,canRedo,steps};
}

const APP_THEMES={
  void:     {name:'Void',    bg:'#06060a',panel:'#0b0b10',border:'#141418',text:'#888', sub:'#55556a',accent:'#c8ff00',muted:'#2a2a35',card:'#0f0f16',bright:'#ccc'},
  ash:      {name:'Ash',     bg:'#111',   panel:'#181818',border:'#252525',text:'#777', sub:'#555',   accent:'#fff',   muted:'#333',   card:'#1c1c1c',bright:'#bbb'},
  slate:    {name:'Slate',   bg:'#0d1117',panel:'#161b22',border:'#21262d',text:'#8b949e',sub:'#6e7681',accent:'#58a6ff',muted:'#30363d',card:'#1c2128',bright:'#c9d1d9'},
  sepia:    {name:'Sepia',   bg:'#1a1610',panel:'#201c13',border:'#302c1e',text:'#8a7a5a',sub:'#6a5a3a',accent:'#d4a853',muted:'#3a3020',card:'#252015',bright:'#c8b890'},
  terminal: {name:'Terminal',bg:'#000d00',panel:'#001200',border:'#002200',text:'#00aa00',sub:'#007700',accent:'#00ff41',muted:'#003300',card:'#001500',bright:'#00ff00'},
  chalk:    {name:'Chalk',   bg:'#f0ede8',panel:'#e8e4de',border:'#ccc8c0',text:'#555', sub:'#777',   accent:'#111',   muted:'#aaa',   card:'#ddd9d2',bright:'#222'},
  paper:    {name:'Paper',   bg:'#fafaf7',panel:'#f2f0eb',border:'#dddad2',text:'#666', sub:'#888',   accent:'#c0392b',muted:'#bbb',   card:'#eae8e1',bright:'#111'},
};
const DEFAULT_APP_THEME={themeKey:'void',brightness:100,borderRadius:0,colorOverrides:false,customBg:'#06060a',customPanel:'#0b0b10',customBorder:'#141418',customText:'#888',customSub:'#55556a',customBright:'#cccccc',customAccent:'#c8ff00',uiFontSize:115};
const BASE_SCHEMES={
  blanc: {n:'Blanc', bg:'#ffffff',fg:'#000',bannerBg:'#000',bannerFg:'#fff',metaBg:'#000',metaFg:'#fff',accent:'#000',sub:'#777',border:'#000',strip:'#f0f0f0',codeBg:'#f6f6f6',codeFg:'#000'},
  void:  {n:'Void',  bg:'#000',fg:'#fff',bannerBg:'#fff',bannerFg:'#000',metaBg:'#fff',metaFg:'#000',accent:'#fff',sub:'#888',border:'#fff',strip:'#111',codeBg:'#111',codeFg:'#fff'},
  thermal:{n:'Thermal',bg:'#faf8f5',fg:'#1a1614',bannerBg:'#1a1614',bannerFg:'#faf8f5',metaBg:'#1a1614',metaFg:'#faf8f5',accent:'#1a1614',sub:'#666054',border:'#1a1614',strip:'#ede9e4',codeBg:'#ede9e4',codeFg:'#1a1614'},
  xerox: {n:'Xerox', bg:'#d8d5d0',fg:'#1a1a18',bannerBg:'#1a1a18',bannerFg:'#d8d5d0',metaBg:'#1a1a18',metaFg:'#d8d5d0',accent:'#1a1a18',sub:'#555',border:'#1a1a18',strip:'#c8c5c0',codeBg:'#c8c5c0',codeFg:'#1a1a18'},
  amber: {n:'Amber', bg:'#fefce8',fg:'#1a1200',bannerBg:'#b45309',bannerFg:'#fff',metaBg:'#1a1200',metaFg:'#fefce8',accent:'#b45309',sub:'#78350f',border:'#1a1200',strip:'#fef3c7',codeBg:'#fff7e0',codeFg:'#92400e'},
  slate: {n:'Slate', bg:'#f8f9fa',fg:'#1e293b',bannerBg:'#334155',bannerFg:'#fff',metaBg:'#1e293b',metaFg:'#f8f9fa',accent:'#3b5279',sub:'#64748b',border:'#1e293b',strip:'#e2e8f0',codeBg:'#e8edf2',codeFg:'#334155'},
  acid:  {n:'Acid',  bg:'#fff',fg:'#000',bannerBg:'#00c853',bannerFg:'#000',metaBg:'#000',metaFg:'#00c853',accent:'#00c853',sub:'#444',border:'#000',strip:'#efffef',codeBg:'#efffef',codeFg:'#007a33'},
  dusk:  {n:'Dusk',  bg:'#1a0a2e',fg:'#e8d8ff',bannerBg:'#4a2070',bannerFg:'#e8d8ff',metaBg:'#3d1a6b',metaFg:'#e8d8ff',accent:'#bf5af2',sub:'#9b72cf',border:'#5e2a8c',strip:'#250d40',codeBg:'#250d40',codeFg:'#bf5af2'},
  ghost: {n:'Ghost', bg:'#f7f7f5',fg:'#111',bannerBg:'#e0e0de',bannerFg:'#111',metaBg:'#1a1a1a',metaFg:'#f0f0f0',accent:'#777',sub:'#aaa',border:'#111',strip:'#ededed',codeBg:'#eeeeec',codeFg:'#555'},
  custom:{n:'Custom',bg:'#fff',fg:'#000',bannerBg:'#000',bannerFg:'#fff',metaBg:'#000',metaFg:'#fff',accent:'#000',sub:'#666',border:'#000',strip:'#f2f2f2',codeBg:'#f6f6f6',codeFg:'#000'},
};
const FONTS={
  // ── MONO / TECHNICAL
  'share-tech':      {css:'"Share Tech Mono",monospace',      name:'Share Tech Mono — OCR/thermal ★'},
  'b612':            {css:'"B612 Mono",monospace',            name:'B612 Mono — aerospace'},
  'ibm-plex':        {css:'"IBM Plex Mono",monospace',        name:'IBM Plex Mono — industrial'},
  'space-mono':      {css:'"Space Mono",monospace',           name:'Space Mono — grid'},
  'anonymous':       {css:'"Anonymous Pro",monospace',        name:'Anonymous Pro — terminal'},
  'courier':         {css:'"Courier Prime",monospace',        name:'Courier Prime — typewriter'},
  'major-mono':      {css:'"Major Mono Display",monospace',   name:'Major Mono Display — geometric'},
  'vt323':           {css:'VT323,monospace',                  name:'VT323 — CRT screen'},
  'press-start':     {css:'"Press Start 2P",monospace',       name:'Press Start 2P — 8-bit'},
  // ── INDUSTRIAL / CONDENSED
  'barlow':          {css:'"Barlow Condensed",sans-serif',    name:'Barlow Condensed — Soviet ★'},
  'roboto-condensed':{css:'"Roboto Condensed",sans-serif',    name:'Roboto Condensed — clean'},
  'oswald':          {css:'Oswald,sans-serif',                name:'Oswald — condensed'},
  'bebas':           {css:'"Bebas Neue",sans-serif',          name:'Bebas Neue — ultra-condensed'},
  'anton':           {css:'Anton,sans-serif',                 name:'Anton — bold block'},
  'teko':            {css:'Teko,sans-serif',                  name:'Teko — slab condensed'},
  'saira':           {css:'"Saira Condensed",sans-serif',     name:'Saira Condensed — narrow'},
  'fjalla':          {css:'"Fjalla One",sans-serif',          name:'Fjalla One — display'},
  'pathway':         {css:'"Pathway Gothic One",sans-serif',  name:'Pathway Gothic One — ultra-narrow'},
  'six-caps':        {css:'"Six Caps",sans-serif',            name:'Six Caps — extreme narrow'},
  'stint':           {css:'"Stint Ultra Condensed",sans-serif',name:'Stint Ultra Condensed'},
  'staatliches':     {css:'Staatliches,sans-serif',           name:'Staatliches — tall block'},
  'bungee':          {css:'Bungee,sans-serif',                name:'Bungee — inline/signage'},
  'righteous':       {css:'Righteous,sans-serif',             name:'Righteous — retro round'},
  // ── SCI-FI / FUTURIST
  'orbitron':        {css:'Orbitron,sans-serif',              name:'Orbitron — sci-fi ★'},
  'audiowide':       {css:'Audiowide,sans-serif',             name:'Audiowide — electronic'},
  'aldrich':         {css:'Aldrich,sans-serif',               name:'Aldrich — technical'},
  'michroma':        {css:'Michroma,sans-serif',              name:'Michroma — circuit'},
  'chakra':          {css:'"Chakra Petch",sans-serif',        name:'Chakra Petch — tech angular'},
  'exo2':            {css:'"Exo 2",sans-serif',               name:'Exo 2 — geometric sci-fi'},
  'rajdhani':        {css:'Rajdhani,sans-serif',              name:'Rajdhani — devanagari-influenced'},
  'syncopate':       {css:'Syncopate,sans-serif',             name:'Syncopate — space caps'},
  'jura':            {css:'Jura,sans-serif',                  name:'Jura — soft geometric'},
  'gruppo':          {css:'Gruppo,sans-serif',                name:'Gruppo — light futurist'},
  'black-ops':       {css:'"Black Ops One",sans-serif',       name:'Black Ops One — military'},
  'graduate':        {css:'Graduate,sans-serif',              name:'Graduate — collegiate'},
  // ── EDITORIAL / SERIF
  'playfair':        {css:'"Playfair Display",serif',         name:'Playfair Display — editorial'},
  'cinzel':          {css:'Cinzel,serif',                     name:'Cinzel — classical roman'},
  'cormorant':       {css:'"Cormorant Garamond",serif',       name:'Cormorant Garamond — elegant'},
  'libre-baskerville':{css:'"Libre Baskerville",serif',       name:'Libre Baskerville — book'},
  'im-fell':         {css:'"IM Fell English",serif',          name:'IM Fell English — old press'},
  'alfa-slab':       {css:'"Alfa Slab One",serif',            name:'Alfa Slab One — slab display'},
  'archivo-black':   {css:'"Archivo Black",sans-serif',       name:'Archivo Black — grotesque'},
  'passion-one':     {css:'"Passion One",sans-serif',         name:'Passion One — display round'},
  // ── VINTAGE / CHARACTER
  'special-elite':   {css:'"Special Elite",monospace',        name:'Special Elite — damaged type'},
  'rye':             {css:'Rye,serif',                        name:'Rye — western'},
  // ── HANDWRITTEN
  'permanent-marker':{css:'"Permanent Marker",cursive',       name:'Permanent Marker — marker'},
  'caveat':          {css:'Caveat,cursive',                   name:'Caveat — casual hand'},
  'kalam':           {css:'Kalam,cursive',                    name:'Kalam — clean hand'},
  'patrick-hand':    {css:'"Patrick Hand",cursive',           name:'Patrick Hand — notebook'},
};
const SIZE_PRESETS=[{name:'4×6 Standard',w:384,h:576},{name:'4×4 Square',w:384,h:384},{name:'6×4 Landscape',w:576,h:384},{name:'3×5 Small',w:288,h:480},{name:'3×3 Mini',w:288,h:288},{name:'5×7 Large',w:480,h:672}];
const mkUid=()=>Math.random().toString(36).slice(2,10);
const DEFAULT_META_ROW=[{id:'bpm',label:'BPM',value:'',show:true},{id:'key',label:'Key',value:'',show:true},{id:'genre',label:'Genre',value:'',show:true},{id:'dur',label:'Length',value:'',show:true},{id:'date',label:'Date',value:'',show:true}];
const DEFAULT_SETTINGS={
  scheme:'thermal',customColors:{bg:'#fff',fg:'#000',bannerBg:'#000',bannerFg:'#fff',metaBg:'#000',metaFg:'#fff',accent:'#000',sub:'#666',border:'#000',strip:'#f2f2f2',codeBg:'#f6f6f6',codeFg:'#000'},
  bgAlpha:1,fgAlpha:1,useGradient:false,gradColor2:'#ccc',gradDir:'to bottom',
  font:'share-tech',artistSize:15,artistBold:true,artistItalic:false,
  titleSize:24,titleBold:true,titleItalic:false,titleAlign:'left',
  metaSize:10,metaLabelSize:6,metaLabelColor:'',bodySize:11,bodyBold:false,bodyItalic:false,bodyAlign:'left',tagSize:9,
  labelW:384,labelH:576,outerBorder:3,
  borders:{bannerBottom:true,titleBottom:true,metaBottom:true,classBottom:true,descBottom:true,qrDivider:true,bottomBorder:true,footerTop:true,metaCellDividers:true},
  showBanner:true,showMeta:true,showClass:true,showDesc:true,showQR:true,showTags:true,showFooter:true,showImage:false,showCodes:true,codesInFooter:false,
  qrFloat:false,qrFloatX:8,qrFloatY:8,qrFloatSize:84,metaFields:DEFAULT_META_ROW,
  qrCaption:'SCAN',qrMode:'static',dynamicId:mkUid().toUpperCase().slice(0,8),
  imageData:null,imageOriginalData:null,imageW:180,imageH:120,imageX:8,imageY:0,ditherThreshold:128,ditherContrast:0,ditherBlend:true,
  textBlocks:[],exportScale:2,exportFormat:'png',
};
const DEFAULT_FIELDS={artist:'',catalog:'',trackNum:'01',title:'',description:'',tags:'',url:'',classCode:'',classDesc:'',isrc:'',upc:''};
const DEFAULT_METADATA={
  title:'',artist:'',albumArtist:'',album:'',year:'',trackNum:'',trackTotal:'',discNum:'',discTotal:'',
  genre:'',bpm:'',key:'',composer:'',lyricist:'',producer:'',publisher:'',copyright:'',label:'',catalog:'',
  isrc:'',upc:'',iswc:'',language:'',comment:'',mood:'',grouping:'',encoder:'',lyrics:'',notes:'',
  explicit:false,compilation:false,albumArt:null,albumArtSize:'3000',
  lufs:'',lra:'',samplePeak:'',crestFactor:'',dcOffset:'',
  stereoCorrelation:'',aiArtifact:'',spectralCeiling:'',aiProbability:'',
};
// ━━━━━━━━ STUDIO — ART TEMPLATES ━━━━━━━━
const ALBUM_ART_SIZES=[{val:'500',label:'500×500 (web)'},{val:'1000',label:'1000×1000 (standard)'},{val:'1500',label:'1500×1500 (HD)'},{val:'3000',label:'3000×3000 (master)'}];
const ART_TEMPLATES={
  'lp-cover':        {name:'LP Cover',          w:1000,h:1000,shape:'rect',   note:'12" sleeve / digital release'},
  '7in-cover':       {name:'7" Single Cover',   w:1000,h:1000,shape:'rect',   note:'Single sleeve'},
  'cd-cover':        {name:'CD Cover',          w:1000,h:1000,shape:'rect',   note:'Jewel case / digipak front'},
  'cassette-front':  {name:'Cassette J-Card',   w:700, h:438, shape:'rect',   note:'J-card front panel'},
  'cassette-label':  {name:'Cassette Label',    w:1051,h:496, shape:'cassette',
    // Outer label: chamfered rect corners (clip mask)
    // Inner window cutout: centered rounded rect, ~47% wide x 34% tall
    slot:{x:0.265,y:0.33,w:0.47,h:0.34,r:0.06},
    note:'89×42mm @ 300dpi · A/B sides',sides:true},
  'vinyl-12':        {name:'12" Vinyl Label',   w:700, h:700, shape:'circle', holeR:0.038,note:'298mm · standard spindle',sides:true},
  'vinyl-7':         {name:'7" Vinyl Label',    w:580, h:580, shape:'circle', holeR:0.058,note:'175mm · standard spindle',sides:true},
  'vinyl-45':        {name:'45 RPM Label',      w:580, h:580, shape:'circle', holeR:0.215,note:'175mm · large center hole',sides:true},
  'cd-label':        {name:'CD Label',          w:600, h:600, shape:'circle', holeR:0.168,note:'116mm disc · 41mm hub'},
};
const mkLayerId=()=>'l'+Math.random().toString(36).slice(2,9);
const DEFAULT_ART_STATE={
  template:'lp-cover',showGuides:true,selectedId:'bg0',side:'A',
  layers:[{id:'bg0',type:'bg',name:'Background',color:'#111111',opacity:1,visible:true,locked:false}],
  layersB:[{id:'bg0b',type:'bg',name:'Background',color:'#111111',opacity:1,visible:true,locked:false}],
};

// ━━━━━━━━ ALBUM ART EDITOR COMPONENT ━━━━━━━━
function AlbumArtEditor({T,artState,setArtState,fields,meta}){
  const artLayersPanel=useDragResize({key:'tl_w_art_layers',defaultW:200,min:140,max:360,label:'Layers'});
  const artPropsPanel=useDragResize({key:'tl_w_art_props',defaultW:224,min:140,max:360,side:'left',label:'Props'});
  const canvasRef=useRef();
  const overlayRef=useRef({}); // refs to portal DOM nodes for zero-lag updates
  const wrapperRef=useRef(); // ref to canvas wrapper div for outside-click detection
  const textEditorRef=useRef();
  const lastClickRef=useRef({id:null,time:0}); // for double-click-to-edit detection
  const imgCache=useRef({});
  const fileRef=useRef();
  const pendingImg=useRef('add');
  // Interaction state — all in a single ref to avoid closure staleness
  // mode: 'idle'|'move'|'resize'
  // resize handle: 'nw'|'n'|'ne'|'e'|'se'|'s'|'sw'|'w'
  const iact=useRef({mode:'idle',layerId:null,handle:null,
    startX:0,startY:0,origX:0,origY:0,origW:0,origH:0});
  const drawLayersRef=useRef(null);  // always-current ref so mousemove effect never re-registers
  const computeSnapRef=useRef(null);  // same for computeSnap
  const tplRef=useRef(null);          // same for tpl
  const bleedRef=useRef(200);         // same for BLEED
  const updateLayerRef=useRef(null); // same for updateLayer
  const scaleRef=useRef(1);          // same for scale
  const activeLayersRef=useRef([]);   // always-current activeLayers
  const activeSelectedIdRef=useRef(null); // always-current selected id
  const canvasRectRef=useRef(null);   // always-current canvas screen rect (no state lag)
  const [cursorStyle,setCursorStyle]=useState('default');
  const [canvasRect,setCanvasRect]=useState(null); // screen rect of canvas for fixed overlay
  const [editingId,setEditingId]=useState(null); // id of text layer being inline-edited
  const editingIdRef=useRef(null); // ref mirror — always current in callbacks

  const tpl=ART_TEMPLATES[artState.template]||ART_TEMPLATES['lp-cover'];
  const hasSides=!!tpl.sides;
  const side=hasSides?(artState.side||'A'):'A';
  const PREV_MAX=520;
  const scale=Math.min(1,PREV_MAX/Math.max(tpl.w,tpl.h));
  const BLEED=800; // canvas-px of ghost margin — fills stage on any screen

  const activeLayers=hasSides&&side==='B'?(artState.layersB||[]):(artState.layers||[]);
  // Keep stable refs current so the drag effect closure always has latest values
  scaleRef.current=scale;
  activeLayersRef.current=activeLayers;
  activeSelectedIdRef.current=activeSelectedId;
  tplRef.current=tpl;
  bleedRef.current=BLEED;
  const activeSelectedId=hasSides&&side==='B'?(artState.selectedIdB||null):artState.selectedId;

  const setLayers=fn=>setArtState(s=>{
    const key=hasSides&&side==='B'?'layersB':'layers';
    const cur=s[key]||[];
    return{...s,[key]:typeof fn==='function'?fn(cur):fn};
  });
  const setSelId=id=>setArtState(s=>{
    const key=hasSides&&side==='B'?'selectedIdB':'selectedId';
    return{...s,[key]:id||null};
  });
  const selLayer=activeLayers.find(l=>l.id===activeSelectedId)||null;
  // updateLayer: must be stable — used inside mouse event handlers via ref closure
  const updateLayer=useCallback((id,ch)=>setArtState(s=>{
    const key=hasSides&&side==='B'?'layersB':'layers';
    const cur=s[key]||[];
    return{...s,[key]:cur.map(l=>l.id===id?{...l,...ch}:l)};
  }),[hasSides,side]);
  updateLayerRef.current=updateLayer;
  const updateSel=ch=>selLayer&&updateLayer(selLayer.id,ch);

  const switchSide=newSide=>{
    if(!hasSides||newSide===side)return;
    setArtState(s=>{
      const ns={...s,side:newSide};
      if(newSide==='B'&&(!s.layersB||!s.layersB.length)){
        ns.layersB=[{id:'bg0b',type:'bg',name:'Background',color:'#111111',opacity:1,visible:true,locked:false}];
        ns.selectedIdB='bg0b';
      }
      return ns;
    });
  };

  const importImg=file=>{
    if(!file||!file.type.startsWith('image/'))return;
    const r=new FileReader();
    r.onload=ev=>{
      const src=ev.target.result;
      const img=new Image();
      const isAdd=pendingImg.current==='add';
      const replaceId=isAdd?null:pendingImg.current;
      img.onload=()=>{
        const id=isAdd?mkLayerId():replaceId;
        imgCache.current[id]=img;
        if(isAdd){
          const aspect=img.width/img.height;
          const fw=Math.round(Math.min(tpl.w,tpl.h*aspect));
          const fh=Math.round(fw/aspect);
          setLayers(ls=>[...ls,{id,type:'image',name:file.name.replace(/\.[^.]+$/,'').slice(0,24),src,x:0,y:0,w:fw,h:fh,opacity:1,visible:true,locked:false}]);
          setSelId(id);
        }else{
          updateLayer(replaceId,{src,w:Math.min(img.width,tpl.w),h:Math.min(img.height,tpl.h)});
        }
      };
      img.src=src;
    };
    r.readAsDataURL(file);
    if(fileRef.current)fileRef.current.value='';
  };

  const addLayer=type=>{
    const id=mkLayerId();
    const base={id,visible:true,locked:false,opacity:1};
    let l;
    if(type==='text') l={...base,type:'text',name:'Text',text:fields.title||meta.title||'TITLE',
      x:Math.round(tpl.w*0.08),y:Math.round(tpl.h*0.4),
      w:Math.round(tpl.w*0.84),h:Math.round(tpl.w*0.065*2.2),
      fontSize:Math.round(tpl.w*0.065),fontFamily:'"Share Tech Mono",monospace',
      color:'#ffffff',align:'left',bold:false,italic:false};
    else l={...base,type:'shape',name:'Shape',shapeType:'rect',
      x:Math.round(tpl.w*0.1),y:Math.round(tpl.h*0.1),
      w:Math.round(tpl.w*0.8),h:Math.round(tpl.h*0.8),fill:'transparent',stroke:'#ffffff',strokeW:2};
    setLayers(ls=>[...ls,l]);
    setSelId(id);
  };

  const moveLayerOrder=(id,dir)=>setLayers(ls=>{
    const i=ls.findIndex(l=>l.id===id);if(i<0)return ls;
    const n=[...ls],ni=dir==='up'?i+1:i-1;
    if(ni<0||ni>=n.length)return ls;
    [n[i],n[ni]]=[n[ni],n[i]];return n;
  });

  const deleteLayer=id=>{
    delete imgCache.current[id];
    setArtState(s=>{
      const key=hasSides&&side==='B'?'layersB':'layers';
      const selKey=hasSides&&side==='B'?'selectedIdB':'selectedId';
      const layers=(s[key]||[]).filter(l=>l.id!==id);
      const selId=s[selKey]===id?(layers[layers.length-1]?.id||null):s[selKey];
      return{...s,[key]:layers,[selKey]:selId};
    });
  };

  const exportArt=()=>{
    const c=canvasRef.current;if(!c)return;
    // Crop out the bleed margin — export only the template area
    const out=document.createElement('canvas');
    out.width=tpl.w;out.height=tpl.h;
    const octx=out.getContext('2d');
    octx.drawImage(c,BLEED,BLEED,tpl.w,tpl.h,0,0,tpl.w,tpl.h);
    const slug=((fields.title||meta.title||'artwork')+'-'+artState.template+(hasSides?'-side'+side:'')).replace(/\W+/g,'-').toLowerCase().slice(0,60);
    const a=document.createElement('a');a.href=out.toDataURL('image/png');a.download=slug+'.png';a.click();
  };

  // ── DRAW (pure canvas, no state reads during drag) ──────────────
  // drawLayers accepts an override map {id:{x,y,w,h}} for live drag preview
  const drawLayers=useCallback((overrides={},guides=[])=>{
    const canvas=canvasRef.current;if(!canvas)return;
    const ctx=canvas.getContext('2d');
    const {w,h,shape,holeR,slot}=tpl;
    ctx.clearRect(0,0,w,h);

    // ── helper: draw a single layer's content (used for both ghost + normal pass)
    const drawLayerContent=(l,lx,ly,lw,lh,alpha,bl=0)=>{
      ctx.globalAlpha=alpha;
      if(l.type==='bg'){ctx.fillStyle=l.color||'#000';ctx.fillRect(0,0,w+bl*2,h+bl*2);return;}
      if(l.type==='image'){const img=imgCache.current[l.id];if(img)ctx.drawImage(img,lx+bl,ly+bl,lw,lh);return;}
      if(l.type==='text'){
        const dispText=l.caps?(l.text||'').toUpperCase():(l.text||'');
        ctx.fillStyle=l.color||'#fff';ctx.textAlign=l.align||'left';ctx.textBaseline='top';
        const weight=(l.bold?'bold ':'')+(l.italic?'italic ':'');
        const fs=l.fontSize||32;
        ctx.font=`${weight}${fs}px ${l.fontFamily||'monospace'}`;
        ctx.letterSpacing=(l.letterSpacing||0)+'px';
        const lnH=Math.round(fs*(l.lineHeight||1.3));
        const maxW2=lw;
        const alignX2=l.align==='center'?(lx+bl)+lw/2:l.align==='right'?(lx+bl)+lw:(lx+bl);
        const paras2=(dispText).split('\n');
        let cy2=ly+bl;
        const dLine=(txt,y2)=>{
          ctx.fillText(txt,alignX2,y2);
          if(l.underline){
            const tw2=ctx.measureText(txt).width;
            const ux2=l.align==='center'?alignX2-tw2/2:l.align==='right'?alignX2-tw2:alignX2;
            ctx.save();ctx.strokeStyle=l.color||'#fff';ctx.lineWidth=Math.max(1,fs*0.06);
            ctx.beginPath();ctx.moveTo(ux2,y2+fs*1.08);ctx.lineTo(ux2+tw2,y2+fs*1.08);ctx.stroke();
            ctx.restore();
          }
        };
        for(const para2 of paras2){
          const words2=para2.split(' ');let line3='';
          for(const word2 of words2){
            const test2=line3?line3+' '+word2:word2;
            if(ctx.measureText(test2).width>maxW2&&line3){dLine(line3,cy2);line3=word2;cy2+=lnH;}
            else line3=test2;
          }
          if(line3)dLine(line3,cy2);
          cy2+=lnH;
        }
        ctx.letterSpacing='0px';
        return;
      }
      if(l.type==='shape'){
        ctx.lineWidth=l.strokeW||2;
        if(l.shapeType==='ellipse'){
          ctx.beginPath();ctx.ellipse((lx+bl)+lw/2,(ly+bl)+lh/2,lw/2,lh/2,0,0,Math.PI*2);
          if(l.fill&&l.fill!=='transparent'){ctx.fillStyle=l.fill;ctx.fill();}
          if(l.stroke&&l.stroke!=='transparent'){ctx.strokeStyle=l.stroke;ctx.stroke();}
        } else {
          if(l.fill&&l.fill!=='transparent'){ctx.fillStyle=l.fill;ctx.fillRect(lx+bl,ly+bl,lw,lh);}
          if(l.stroke&&l.stroke!=='transparent'){ctx.strokeStyle=l.stroke;ctx.strokeRect(lx+bl,ly+bl,lw,lh);}
        }
      }
    };

    // ── PASS 0: fill entire canvas with slate stage color
    ctx.fillStyle='#3a3d42';
    ctx.fillRect(0,0,w+BLEED*2,h+BLEED*2);

    // ── PASS 1: ghost bleed — non-bg layers at 45% opacity, no clip, slate bg shows through
    ctx.save();
    for(const l of activeLayers){
      if(!l.visible||l.id===editingId||l.type==='bg')continue;
      const ov=overrides[l.id]||{};
      const lx=(ov.x!=null?ov.x:l.x)||0;
      const ly=(ov.y!=null?ov.y:l.y)||0;
      const lw=ov.w!=null?ov.w:(l.w||w);
      const lh=ov.h!=null?ov.h:(l.h||h);
      drawLayerContent(l,lx,ly,lw,lh,(l.opacity??1)*0.45,BLEED);
    }
    ctx.restore();

    // ── PASS 2: clip to template shape, draw all layers (bg first) inside
    ctx.save();
    if(shape==='circle'){
      ctx.beginPath();ctx.arc(w/2+BLEED,h/2+BLEED,w/2,0,Math.PI*2);ctx.clip();
    } else if(shape==='cassette'){
      const ch=Math.round(h*0.14);
      const bx0=BLEED,by0=BLEED;
      ctx.beginPath();
      ctx.moveTo(bx0+ch,by0);ctx.lineTo(bx0+w-ch,by0);
      ctx.lineTo(bx0+w,by0+ch);ctx.lineTo(bx0+w,by0+h-ch);
      ctx.lineTo(bx0+w-ch,by0+h);ctx.lineTo(bx0+ch,by0+h);
      ctx.lineTo(bx0,by0+h-ch);ctx.lineTo(bx0,by0+ch);
      ctx.closePath();ctx.clip();
    } else {
      // rect / lp-cover / cd / etc — clip to exact template bounds
      ctx.beginPath();ctx.rect(BLEED,BLEED,w,h);ctx.clip();
    }
    for(const l of activeLayers){
      if(!l.visible||l.id===editingId)continue;
      const ov=overrides[l.id]||{};
      const lx=(ov.x!=null?ov.x:l.x)||0;
      const ly=(ov.y!=null?ov.y:l.y)||0;
      const lw=ov.w!=null?ov.w:(l.w||w);
      const lh=ov.h!=null?ov.h:(l.h||h);
      drawLayerContent(l,lx,ly,lw,lh,l.opacity??1,BLEED);
      ctx.globalAlpha=1;
    }
    ctx.restore();

    // Hole punch
    if(holeR){
      ctx.save();ctx.globalCompositeOperation='destination-out';
      ctx.beginPath();ctx.arc(w/2+BLEED,h/2+BLEED,w*holeR,0,Math.PI*2);ctx.fill();
      ctx.restore();
    }
    // Cassette window cutout — single centered rounded rect
    if(shape==='cassette'&&slot){
      ctx.save();ctx.globalCompositeOperation='destination-out';
      const sx=Math.round(w*slot.x)+BLEED, sy=Math.round(h*slot.y)+BLEED;
      const sw2=Math.round(w*slot.w), sh2=Math.round(h*slot.h);
      const sr=Math.round(Math.min(sw2,sh2)*slot.r);
      ctx.beginPath();ctx.roundRect(sx,sy,sw2,sh2,sr);ctx.fill();
      ctx.restore();
    }

    // Guides overlay (doesn't export)
    ctx.save();
    if(artState.showGuides){
      ctx.strokeStyle='rgba(70,170,255,0.35)';ctx.lineWidth=1;ctx.setLineDash([5,5]);
      if(shape==='rect'){const m=Math.round(w*0.05);ctx.strokeRect(m+BLEED,m+BLEED,w-m*2,h-m*2);}
      else if(shape==='circle'){ctx.beginPath();ctx.arc(w/2+BLEED,h/2+BLEED,w/2*0.85,0,Math.PI*2);ctx.stroke();}
      else if(shape==='cassette'&&slot){
        // Show safe zone: left of slot, right of slot, full height
        const slotX=Math.round(w*slot.x), slotR=Math.round(w*(slot.x+slot.w));
        ctx.setLineDash([4,4]);ctx.strokeStyle='rgba(70,170,255,0.4)';
        ctx.strokeRect(10+BLEED,10+BLEED,slotX-20,h-20);
        ctx.strokeRect(slotR+10+BLEED,10+BLEED,w-slotR-20,h-20);
      }
      ctx.setLineDash([3,5]);ctx.strokeStyle='rgba(70,170,255,0.18)';
      ctx.beginPath();ctx.moveTo(w/2+BLEED-18,h/2+BLEED);ctx.lineTo(w/2+BLEED+18,h/2+BLEED);ctx.moveTo(w/2+BLEED,h/2+BLEED-18);ctx.lineTo(w/2+BLEED,h/2+BLEED+18);ctx.stroke();
    }
    ctx.restore();

    // ── Smart guide lines (drawn last, always on top, never exported)
    if(guides&&guides.length){
      ctx.save();
      ctx.setLineDash([]);
      guides.forEach(g=>{
        ctx.strokeStyle=g.type==='center'?'rgba(0,210,255,1)':'rgba(0,175,230,1)';
        ctx.lineWidth=1;
        ctx.beginPath();
        if(g.axis==='x'){ctx.moveTo(g.pos+BLEED,0);ctx.lineTo(g.pos+BLEED,h+BLEED*2);}
        else            {ctx.moveTo(0,g.pos+BLEED);ctx.lineTo(w+BLEED*2,g.pos+BLEED);}
        ctx.stroke();
      });
      ctx.restore();
    }
  },[activeLayers,artState.showGuides,tpl,editingId]);
  drawLayersRef.current=drawLayers;

  useEffect(()=>{
    activeLayers.forEach(l=>{
      if(l.type==='image'&&l.src&&!imgCache.current[l.id]){
        const img=new Image();img.onload=()=>{imgCache.current[l.id]=img;drawLayers();};img.src=l.src;
      }
    });
    drawLayers();
  },[activeLayers,drawLayers]);

  // ── LAYER BOUNDING BOX (in canvas coords) ───────────────────────
  const getLayerBBox=useCallback((l,overrides={})=>{
    if(!l||l.type==='bg')return null;
    const ov=overrides[l.id]||{};
    const x=(ov.x!=null?ov.x:l.x)||0;
    const y=(ov.y!=null?ov.y:l.y)||0;
    if(l.type==='image'||l.type==='shape'){
      return{x,y,w:ov.w!=null?ov.w:(l.w||100),h:ov.h!=null?ov.h:(l.h||100)};
    }
    if(l.type==='text'){
      // Text stores w/h just like image/shape so handles can resize it
      const fw=ov.w!=null?ov.w:(l.w||Math.round(tpl.w*0.84));
      const fh=ov.h!=null?ov.h:(l.h||Math.round((l.fontSize||32)*2.2));
      return{x,y,w:Math.max(20,fw),h:Math.max(10,fh)};
    }
    return null;
  },[tpl]);

  // ── HIT TEST ────────────────────────────────────────────────────
  const hitTest=useCallback((cx,cy,overrides={})=>{
    for(let i=activeLayers.length-1;i>=0;i--){
      const l=activeLayers[i];
      if(!l.visible||l.locked||l.type==='bg')continue;
      const bb=getLayerBBox(l,overrides);
      if(bb&&cx>=bb.x&&cx<=bb.x+bb.w&&cy>=bb.y&&cy<=bb.y+bb.h)return l;
    }
    return null;
  },[activeLayers,getLayerBBox]);

  // ── RESIZE HANDLE HIT TEST ─────────────────────────────────────
  const HANDLE_R=5; // screen px radius for hit detection
  const getHandles=useCallback((bb)=>{
    if(!bb)return[];
    const {x,y,w,h}=bb;
    const mx=x+w/2, my=y+h/2;
    return[
      {id:'nw',cx:x,cy:y},   {id:'n',cx:mx,cy:y},  {id:'ne',cx:x+w,cy:y},
      {id:'e',cx:x+w,cy:my},
      {id:'se',cx:x+w,cy:y+h},{id:'s',cx:mx,cy:y+h},{id:'sw',cx:x,cy:y+h},
      {id:'w',cx:x,cy:my},
    ];
  },[]);

  const HANDLE_CURSORS={nw:'nwse-resize',n:'ns-resize',ne:'nesw-resize',e:'ew-resize',se:'nwse-resize',s:'ns-resize',sw:'nesw-resize',w:'ew-resize'};

  const hitHandle=useCallback((cx,cy,overrides={},forLayer=null)=>{
    // Use forLayer if provided (avoids stale closure); fall back to selLayer
    const targetLayer=forLayer||(activeLayersRef.current.find(l=>l.id===activeSelectedIdRef.current))||selLayer;
    if(!targetLayer)return null;
    const bb=getLayerBBox(targetLayer,overrides);
    if(!bb)return null;
    const handles=getHandles(bb);
    for(const h of handles){
      const hxScreen=h.cx*scale, hyScreen=h.cy*scale;
      const cxScreen=cx*scale, cyScreen=cy*scale;
      if(Math.abs(cxScreen-hxScreen)<=HANDLE_R+2&&Math.abs(cyScreen-hyScreen)<=HANDLE_R+2)return h.id;
    }
    return null;
  },[selLayer,getLayerBBox,getHandles,scale]);


  // ── INLINE TEXT EDIT ────────────────────────────────────────────
  const commitTextEdit=useCallback(()=>{
    if(!editingId||!textEditorRef.current)return;
    const txt=textEditorRef.current.innerText||'';
    updateLayer(editingId,{text:txt});
    editingIdRef.current=null;setEditingId(null);
  },[editingId,updateLayer]);

  const enterEditMode=useCallback((layer)=>{
    if(!layer||layer.type!=='text')return;
    editingIdRef.current=layer.id;setEditingId(layer.id);
    // Focus the editor on next paint
    setTimeout(()=>{
      const el=textEditorRef.current;
      if(!el)return;
      el.focus();
      // Place cursor at end
      const range=document.createRange();
      range.selectNodeContents(el);
      range.collapse(false);
      const sel=window.getSelection();
      sel.removeAllRanges();sel.addRange(range);
    },20);
  },[]);
  // ── CANVAS MOUSE DOWN — Keynote-style ─────────────────────────
  const onCanvasMouseDown=useCallback(e=>{
    if(e.button!==0)return;
    e.preventDefault();
    const rect=canvasRef.current.getBoundingClientRect();
    // Subtract bleed offset: canvas is larger than template, origin is at BLEED,BLEED
    const cx=(e.clientX-rect.left)/scale - BLEED;
    const cy=(e.clientY-rect.top)/scale - BLEED;

    // If currently editing text, commit and stop
    if(editingIdRef.current){commitTextEdit();return;}

    // Check resize handle first — read fresh layer from ref, not stale selLayer closure
    const handle=hitHandle(cx,cy);
    if(handle&&activeSelectedIdRef.current){
      const freshSel=activeLayersRef.current.find(l=>l.id===activeSelectedIdRef.current);
      if(freshSel){
        const bb=getLayerBBox(freshSel)||{x:0,y:0,w:100,h:100};
        iact.current={mode:'resize',layerId:freshSel.id,handle,
          startX:e.clientX,startY:e.clientY,
          origX:bb.x,origY:bb.y,origW:bb.w,origH:bb.h};
        setCursorStyle(HANDLE_CURSORS[handle]||'nwse-resize');
        return;
      }
    }

    const hit=hitTest(cx,cy);
    if(hit){
      const now=Date.now();
      const lc=lastClickRef.current;
      // Second click within 400ms on same text layer → enter inline edit
      if(hit.type==='text'&&hit.id===lc.id&&(now-lc.time)<400){
        lastClickRef.current={id:null,time:0};
        enterEditMode(hit);
        return;
      }
      lastClickRef.current={id:hit.id,time:now};
      setSelId(hit.id);
      // Read FRESH layer data from ref (not stale closure hit object)
      const freshLayer=activeLayersRef.current.find(l=>l.id===hit.id)||hit;
      const freshBB=getLayerBBox(freshLayer)||{x:0,y:0,w:100,h:100};
      iact.current={mode:'move',layerId:hit.id,
        startX:e.clientX,startY:e.clientY,
        origX:freshBB.x,origY:freshBB.y,
        origW:freshBB.w,origH:freshBB.h};
      setCursorStyle('move');
      return;
    }

    // Blank canvas — clear selection
    lastClickRef.current={id:null,time:0};
    setSelId(null);
  },[scale,selLayer,commitTextEdit,enterEditMode,hitHandle,hitTest,getLayerBBox,setSelId]);

  // ── OVERLAY HANDLE MOUSE DOWN — fires from fixed portal ────────
  // Converts screen coords back to canvas coords for handle hit
  const onOverlayMouseDown=useCallback(e=>{
    if(e.button!==0)return;
    e.preventDefault();
    e.stopPropagation();
    if(!selLayer||!canvasRef.current)return;
    const rect=canvasRef.current.getBoundingClientRect();
    const cx=(e.clientX-rect.left)/scale - BLEED;
    const cy=(e.clientY-rect.top)/scale - BLEED;
    const freshSel2=activeLayersRef.current.find(l=>l.id===activeSelectedIdRef.current)||selLayer;
    const handle=hitHandle(cx,cy,{},freshSel2);
    if(handle&&freshSel2){
      const bb=getLayerBBox(freshSel2)||{x:0,y:0,w:100,h:100};
      iact.current={mode:'resize',layerId:freshSel2.id,handle,
        startX:e.clientX,startY:e.clientY,
        origX:bb.x,origY:bb.y,origW:bb.w,origH:bb.h};
      setCursorStyle(HANDLE_CURSORS[handle]||'nwse-resize');
    }
  },[selLayer,scale,hitHandle,getLayerBBox]);


  // ── SMART GUIDE SNAPPING ────────────────────────────────────────
  // Returns {snappedX, snappedY, guides:[]} for a layer bbox during move
  // Keynote behavior:
  //   SNAP_THRESHOLD: if within this many canvas-px, snap
  //   RELEASE_EXTRA:  user must drag this far past snap before it releases
  const SNAP_T=6;   // canvas px snap threshold
  const SNAP_R=14;  // canvas px to drag past snap before releasing

  const computeSnap=useCallback((layerId,rawX,rawY,origX,origY)=>{
    const layers=activeLayersRef.current;
    const sc=scaleRef.current;
    const {w,h}=tpl;
    // Get bbox of moving layer at raw (unsnapped) position
    const movingLayer=layers.find(l=>l.id===layerId);
    if(!movingLayer)return{snappedX:rawX,snappedY:rawY,guides:[]};
    const mw=movingLayer.w||w, mh=movingLayer.h||h;

    // Candidate snap lines: canvas center + edges, plus every other visible non-bg layer
    // Each entry: {axis, pos, type:'center'|'edge'}
    const snapLines=[];
    // Canvas axes
    snapLines.push({axis:'x',pos:0,      type:'edge'},  {axis:'x',pos:w,      type:'edge'});
    snapLines.push({axis:'x',pos:w/2,    type:'center'});
    snapLines.push({axis:'y',pos:0,      type:'edge'},  {axis:'y',pos:h,      type:'edge'});
    snapLines.push({axis:'y',pos:h/2,    type:'center'});

    for(const l of layers){
      if(l.id===layerId||!l.visible||l.type==='bg')continue;
      const lx=(l.x||0), ly=(l.y||0);
      const lw=l.w||w, lh=l.h||h;
      // Other layer: left, center-x, right
      snapLines.push({axis:'x',pos:lx,        type:'edge'});
      snapLines.push({axis:'x',pos:lx+lw/2,   type:'center'});
      snapLines.push({axis:'x',pos:lx+lw,     type:'edge'});
      // Other layer: top, center-y, bottom
      snapLines.push({axis:'y',pos:ly,        type:'edge'});
      snapLines.push({axis:'y',pos:ly+lh/2,   type:'center'});
      snapLines.push({axis:'y',pos:ly+lh,     type:'edge'});
    }

    // Points on the moving layer that can snap to snap lines
    // x-axis: left edge, center-x, right edge
    // y-axis: top edge, center-y, bottom edge
    const mx_left=rawX, mx_mid=rawX+mw/2, mx_right=rawX+mw;
    const my_top=rawY,  my_mid=rawY+mh/2, my_bot=rawY+mh;

    let snappedX=rawX, snappedY=rawY;
    const activeGuides=[];
    let bestDx=SNAP_T+1, bestDy=SNAP_T+1;

    for(const sl of snapLines){
      if(sl.axis==='x'){
        // Check each moving-layer x point against this snap line
        for(const [mp,offset] of [[mx_left,0],[mx_mid,-mw/2],[mx_right,-mw]]){
          const d=Math.abs(mp-sl.pos);
          if(d<bestDx){
            bestDx=d;
            snappedX=sl.pos+offset;
            // Clear previous x guides and add this one
            activeGuides.filter(g=>g.axis==='x').forEach((_,i,a)=>a.splice(i,1));
          }
          if(d<SNAP_T){
            const already=activeGuides.find(g=>g.axis==='x'&&Math.abs(g.pos-sl.pos)<1);
            if(!already)activeGuides.push({axis:'x',pos:sl.pos,type:sl.type});
          }
        }
      } else {
        for(const [mp,offset] of [[my_top,0],[my_mid,-mh/2],[my_bot,-mh]]){
          const d=Math.abs(mp-sl.pos);
          if(d<bestDy){
            bestDy=d;
            snappedY=sl.pos+offset;
            activeGuides.filter(g=>g.axis==='y').forEach((_,i,a)=>a.splice(i,1));
          }
          if(d<SNAP_T){
            const already=activeGuides.find(g=>g.axis==='y'&&Math.abs(g.pos-sl.pos)<1);
            if(!already)activeGuides.push({axis:'y',pos:sl.pos,type:sl.type});
          }
        }
      }
    }

    // If not within threshold, no snap
    if(bestDx>SNAP_T)snappedX=rawX;
    if(bestDy>SNAP_T)snappedY=rawY;

    return{snappedX,snappedY,guides:activeGuides};
  },[tpl]);
  computeSnapRef.current=computeSnap;

  // ── GLOBAL MOUSE MOVE / UP ──────────────────────────────────────
  // Uses refs (drawLayersRef, updateLayerRef, scaleRef) so this effect
  // registers ONCE and NEVER tears down mid-drag when other state changes.
  useEffect(()=>{
    let rafId=null;

    const onMove=e=>{
      const d=iact.current;
      if(d.mode==='idle')return;
      const sc=scaleRef.current;
      const dx=(e.clientX-d.startX)/sc;
      const dy=(e.clientY-d.startY)/sc;

      let overrides={};
      let guides=[];
      if(d.mode==='move'){
        const rawX=Math.round(d.origX+dx), rawY=Math.round(d.origY+dy);
        // Keynote magnetic snap: compute snap with release hysteresis
        if(!d.snapLock)d.snapLock={};
        const snap=computeSnapRef.current&&computeSnapRef.current(d.layerId,rawX,rawY,d.origX,d.origY);
        let finalX=rawX, finalY=rawY;
        if(snap){
          guides=snap.guides;
          // X axis snap with magnetic hold
          if(snap.snappedX!==rawX){
            d.snapLock.x=snap.snappedX;
            finalX=snap.snappedX;
          } else if(d.snapLock.x!=null){
            // Still locked? Only release if user dragged past SNAP_R beyond the snap point
            const layer=activeLayersRef.current.find(l=>l.id===d.layerId);
            const mw2=layer?(layer.w||(tplRef.current||{w:800}).w):100;
            const snapRawEdges=[d.snapLock.x, d.snapLock.x+mw2/2, d.snapLock.x+mw2];
            const minDist=Math.min(...snapRawEdges.map(e=>Math.abs(rawX-(e-(e-d.snapLock.x)))));
            if(Math.abs(rawX-d.snapLock.x)>SNAP_R&&Math.abs(rawX-(d.snapLock.x+(layer?layer.w||0:0)/2))>SNAP_R){
              d.snapLock.x=null;finalX=rawX;
            } else {finalX=d.snapLock.x;}
          }
          // Y axis snap with magnetic hold
          if(snap.snappedY!==rawY){
            d.snapLock.y=snap.snappedY;
            finalY=snap.snappedY;
          } else if(d.snapLock.y!=null){
            const layer2=activeLayersRef.current.find(l=>l.id===d.layerId);
            const mh2=layer2?(layer2.h||(tplRef.current||{h:800}).h):100;
            if(Math.abs(rawY-d.snapLock.y)>SNAP_R&&Math.abs(rawY-(d.snapLock.y+mh2/2))>SNAP_R){
              d.snapLock.y=null;finalY=rawY;
            } else {finalY=d.snapLock.y;}
          }
        }
        // Clamp to template bounds so layers can't escape onto the UI
        const tpl2=tplRef.current||{w:800,h:800};
        const movingL=activeLayersRef.current.find(l=>l.id===d.layerId);
        const lw2=movingL?(movingL.w||100):100;
        const lh2=movingL?(movingL.h||100):100;
        const clampedX=Math.round(Math.max(0,Math.min(tpl2.w-lw2,finalX)));
        const clampedY=Math.round(Math.max(0,Math.min(tpl2.h-lh2,finalY)));
        overrides[d.layerId]={x:clampedX,y:clampedY};
      } else if(d.mode==='resize'){
        const {origX:ox,origY:oy,origW:ow,origH:oh,handle}=d;
        let nx=ox,ny=oy,nw=ow,nh=oh;
        if(handle.includes('e'))nw=Math.max(10,ow+dx);
        if(handle.includes('s'))nh=Math.max(10,oh+dy);
        if(handle.includes('w')){nx=ox+dx;nw=Math.max(10,ow-dx);}
        if(handle.includes('n')){ny=oy+dy;nh=Math.max(10,oh-dy);}
        overrides[d.layerId]={x:Math.round(nx),y:Math.round(ny),w:Math.round(nw),h:Math.round(nh)};
      }

      if(rafId)cancelAnimationFrame(rafId);
      rafId=requestAnimationFrame(()=>{
        drawLayersRef.current&&drawLayersRef.current(overrides,guides);
        d.liveOverrides=overrides;
        // Direct DOM mutation for zero-lag overlay tracking
        const cv=canvasRef.current;
        if(cv&&overrides[d.layerId]){
          const cr=cv.getBoundingClientRect();
          const ov2=overrides[d.layerId];
          const sc2=scaleRef.current;
          const bl=bleedRef.current;
          const bx=ov2.x!=null?ov2.x:0;
          const by=ov2.y!=null?ov2.y:0;
          const bw=ov2.w!=null?ov2.w:d.origW;
          const bh=ov2.h!=null?ov2.h:d.origH;
          // cr.left is the left of the oversized canvas; add BLEED*scale to get template origin
          const ox=cr.left+(bx+bl)*sc2, oy2=cr.top+(by+bl)*sc2;
          const ow=bw*sc2, oh=bh*sc2;
          const o=overlayRef.current;
          if(o.outline){
            o.outline.style.left=ox+'px'; o.outline.style.top=oy2+'px';
            o.outline.style.width=ow+'px'; o.outline.style.height=oh+'px';
          }
          const HS=8;
          [[ox,oy2],[ox+ow/2,oy2],[ox+ow,oy2],
           [ox+ow,oy2+oh/2],
           [ox+ow,oy2+oh],[ox+ow/2,oy2+oh],[ox,oy2+oh],
           [ox,oy2+oh/2]
          ].forEach(([hx,hy],i)=>{
            const el=o['h'+i];
            if(el){el.style.left=(hx-HS/2)+'px';el.style.top=(hy-HS/2)+'px';}
          });
        }
        rafId=null;
      });
    };

    const onUp=e=>{
      const d=iact.current;
      if(d.mode==='idle')return;
      const screenDx=e.clientX-d.startX;
      const screenDy=e.clientY-d.startY;
      const wasDrag=Math.abs(screenDx)>3||Math.abs(screenDy)>3;

      if(wasDrag){
        const sc=scaleRef.current;
        const ov=d.liveOverrides;
        if(ov&&ov[d.layerId]){
          if(d.mode==='move'){
            // Only commit x,y — never clobber w,h
            updateLayerRef.current&&updateLayerRef.current(d.layerId,{x:ov[d.layerId].x,y:ov[d.layerId].y});
          } else {
            updateLayerRef.current&&updateLayerRef.current(d.layerId,ov[d.layerId]);
          }
        } else if(d.mode==='move'){
          updateLayerRef.current&&updateLayerRef.current(d.layerId,{
            x:Math.round(d.origX+screenDx/sc),
            y:Math.round(d.origY+screenDy/sc)
          });
        }
      }
      iact.current={mode:'idle',liveOverrides:null};
      setCursorStyle('default');
      if(rafId)cancelAnimationFrame(rafId);
      drawLayersRef.current&&drawLayersRef.current();
    };

    window.addEventListener('mousemove',onMove);
    window.addEventListener('mouseup',onUp);
    return()=>{
      window.removeEventListener('mousemove',onMove);
      window.removeEventListener('mouseup',onUp);
      if(rafId)cancelAnimationFrame(rafId);
    };
  },[]);

  // ── KEEP canvasRect IN SYNC with scroll/resize ─────────────────
  useEffect(()=>{
    const update=()=>{
      if(canvasRef.current){const r=canvasRef.current.getBoundingClientRect();canvasRectRef.current=r;setCanvasRect(r);}
    };
    update();
    const ro=new ResizeObserver(update);
    if(canvasRef.current)ro.observe(canvasRef.current);
    window.addEventListener('scroll',update,true);
    window.addEventListener('resize',update);
    return()=>{ro.disconnect();window.removeEventListener('scroll',update,true);window.removeEventListener('resize',update);};
  },[]);

  // ── CLEAR SELECTION when clicking outside canvas wrapper ────────
  useEffect(()=>{
    const onOutsideClick=e=>{
      if(editingId)return; // let commitTextEdit handle it
      if(!canvasRef.current)return;
      // Check if the click target is inside the canvas wrapper or any portal overlay
      // Use wrapperRef so clicks on the canvas element itself (pointerEvents:none) are also caught
      if(wrapperRef.current&&wrapperRef.current.contains(e.target))return;
      if(e.target.closest&&e.target.closest('[data-tl-overlay]'))return;
      // Clicks within the editor panels should not clear selection
      if(e.target.closest&&e.target.closest('[data-tl-editor]'))return;
      setSelId(null);
      lastClickRef.current={id:null,time:0};
    };
    window.addEventListener('mousedown',onOutsideClick,true);
    return()=>window.removeEventListener('mousedown',onOutsideClick,true);
  },[editingId]);

  // ── CANVAS CURSOR on hover ──────────────────────────────────────
  const onCanvasMouseMove=useCallback(e=>{
    if(iact.current.mode!=='idle')return;
    const rect=canvasRef.current.getBoundingClientRect();
    const cx=(e.clientX-rect.left)/scale - BLEED;
    const cy=(e.clientY-rect.top)/scale - BLEED;
    const handle=hitHandle(cx,cy);
    if(handle){setCursorStyle(HANDLE_CURSORS[handle]||'nwse-resize');return;}
    const hit=hitTest(cx,cy);
    setCursorStyle(hit?'move':'default');
  },[scale,hitHandle,hitTest]);

  // ── FONT GROUPS ─────────────────────────────────────────────────
  const FONT_GROUPS=[
    {label:'── Mono / Technical',keys:['share-tech','b612','ibm-plex','space-mono','anonymous','courier','major-mono','vt323','press-start']},
    {label:'── Industrial / Condensed',keys:['barlow','roboto-condensed','oswald','bebas','anton','teko','saira','fjalla','pathway','six-caps','stint','staatliches','bungee','righteous']},
    {label:'── Sci-Fi / Futurist',keys:['orbitron','audiowide','aldrich','michroma','chakra','exo2','rajdhani','syncopate','jura','gruppo','black-ops','graduate']},
    {label:'── Editorial / Serif',keys:['playfair','cinzel','cormorant','libre-baskerville','im-fell','alfa-slab','archivo-black','passion-one']},
    {label:'── Vintage / Character',keys:['special-elite','rye']},
    {label:'── Handwritten',keys:['permanent-marker','caveat','kalam','patrick-hand']},
  ];

  const typeIcon={bg:'▬',image:'⬜',text:'T',shape:'◻'};
  const iconBtn=(label,onClick,color)=>(
    <button onClick={onClick} style={{
      background:'none',border:'none',cursor:'pointer',
      color:color||T.muted,fontSize:14,lineHeight:1,
      padding:'4px 5px',minWidth:24,minHeight:24,
      display:'flex',alignItems:'center',justifyContent:'center',
      borderRadius:T.r||2,
    }}>{label}</button>
  );

  // Selection outline + handles are drawn directly on canvas in drawLayers()

  return(
    <div data-tl-editor style={{display:'flex',minHeight:'calc(100vh - 88px)'}}>
      {/* ── LEFT: layers panel ── */}
      <div style={{width:artLayersPanel.width,flexShrink:0,background:T.panel,borderRight:artLayersPanel.collapsed?'none':`1px solid ${T.border}`,display:'flex',flexDirection:'column',overflow:'hidden',position:'relative',transition:'width 0.15s'}}>
        <div {...artLayersPanel.handle}/>
        {artLayersPanel.tab}
        <div style={{padding:'8px 10px',borderBottom:`1px solid ${T.border}`,flexShrink:0}}>
          <div style={{fontSize:7,letterSpacing:'0.14em',textTransform:'uppercase',color:T.muted,marginBottom:4}}>Format</div>
          <select value={artState.template} onChange={e=>setArtState(s=>({...s,template:e.target.value,side:'A'}))} style={{...mkIS(T),fontSize:9}}>
            {Object.entries(ART_TEMPLATES).map(([k,t])=><option key={k} value={k}>{t.name}</option>)}
          </select>
          <div style={{fontSize:7,color:T.muted,marginTop:3,lineHeight:1.4}}>{tpl.note}</div>
          {hasSides&&(
            <div style={{display:'flex',gap:4,marginTop:7}}>
              {['A','B'].map(s=>(
                <button key={s} onClick={()=>switchSide(s)} style={{
                  flex:1,padding:'5px 0',fontSize:10,fontWeight:700,letterSpacing:'0.1em',
                  background:side===s?T.accent:T.bg,color:side===s?T.bg:T.muted,
                  border:`1px solid ${side===s?T.accent:T.border}`,cursor:'pointer',
                  borderRadius:T.r||0,fontFamily:'inherit',
                }}>Side {s}</button>
              ))}
            </div>
          )}
        </div>
        <div style={{padding:'5px 8px',borderBottom:`1px solid ${T.border}`,flexShrink:0,display:'flex',gap:4}}>
          <input ref={fileRef} type="file" accept="image/*" style={{display:'none'}} onChange={e=>importImg(e.target.files[0])}/>
          <button onClick={()=>{pendingImg.current='add';fileRef.current.click();}} style={{...mkBtn(T),flex:1,fontSize:8,padding:'5px 0'}}>+ Img</button>
          <button onClick={()=>addLayer('text')} style={{...mkBtn(T),flex:1,fontSize:8,padding:'5px 0'}}>+ Text</button>
          <button onClick={()=>addLayer('shape')} style={{...mkBtn(T),flex:1,fontSize:8,padding:'5px 0'}}>+ Shape</button>
        </div>
        <div style={{flex:1,overflowY:'auto'}}>
          {[...activeLayers].reverse().map(layer=>{
            const sel=layer.id===activeSelectedId;
            return(
              <div key={layer.id} onClick={()=>setSelId(layer.id)}
                style={{display:'flex',alignItems:'center',gap:2,padding:'3px 6px',
                  background:sel?T.card:'transparent',cursor:'pointer',
                  borderLeft:`2px solid ${sel?T.accent:'transparent'}`,minHeight:32}}>
                <span style={{fontSize:10,color:T.muted,flexShrink:0,width:14,textAlign:'center'}}>{typeIcon[layer.type]}</span>
                <span style={{fontSize:9,color:sel?T.bright:T.text,flex:1,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{layer.name}</span>
                <div style={{display:'flex',alignItems:'center',flexShrink:0}}>
                  {iconBtn(layer.visible?'◉':'○',e=>{e.stopPropagation();updateLayer(layer.id,{visible:!layer.visible});},layer.visible?T.accent:T.border)}
                  {iconBtn('↑',e=>{e.stopPropagation();moveLayerOrder(layer.id,'up');})}
                  {iconBtn('↓',e=>{e.stopPropagation();moveLayerOrder(layer.id,'down');})}
                  {layer.type!=='bg'&&iconBtn('✕',e=>{e.stopPropagation();deleteLayer(layer.id);},'#f87171')}
                </div>
              </div>
            );
          })}
        </div>
        <div style={{padding:'8px 10px',borderTop:`1px solid ${T.border}`,flexShrink:0}}>
          <Tog T={T} label="Show guides" value={artState.showGuides} onChange={v=>setArtState(s=>({...s,showGuides:v}))}/>
          <button onClick={exportArt} style={{...mkBtn(T,true),width:'100%',padding:'9px 0',fontSize:9,marginTop:7}}>
            ⬇ Export PNG{hasSides?` (Side ${side})`:''}
          </button>
        </div>
      </div>
      {artLayersPanel.expandStub}

      {/* ── CENTER: slate stage — fills remaining space ── */}
      <div style={{flex:1,overflow:'auto',position:'relative',
                   display:'flex',alignItems:'center',justifyContent:'center',
                   background:'#3a3d42'}}>
        {/* Side label floats top-center on stage */}
        {hasSides&&<div style={{position:'absolute',top:10,left:0,right:0,
          textAlign:'center',fontSize:8,color:'rgba(255,255,255,0.35)',
          letterSpacing:'0.2em',textTransform:'uppercase',fontFamily:'monospace',
          pointerEvents:'none',zIndex:2}}>
          SIDE {side} — {tpl.name}
        </div>}
        {/* Template wrapper — template-sized, black bg, shadow, bleed canvas overflows it */}
        <div ref={wrapperRef} style={{
            position:'relative',display:'inline-block',flexShrink:0,
            width:tpl.w*scale,height:tpl.h*scale,
            boxShadow:'0 8px 48px rgba(0,0,0,0.85)',
            borderRadius:tpl.shape==='circle'?'50%':'0',
            overflow:'visible'}}>
          <canvas ref={canvasRef} width={tpl.w+BLEED*2} height={tpl.h+BLEED*2}
            onMouseDown={onCanvasMouseDown}
            onMouseMove={onCanvasMouseMove}
            onMouseLeave={()=>iact.current.mode==='idle'&&setCursorStyle('default')}
            style={{display:'block',
              position:'absolute',
              left:-BLEED*scale,top:-BLEED*scale,
              width:(tpl.w+BLEED*2)*scale,height:(tpl.h+BLEED*2)*scale,
              cursor:cursorStyle,userSelect:'none',
              pointerEvents:'all'}}/>
        </div>
          {/* Inline text editor — portalled to body, sits exactly over canvas text */}
          {editingId&&canvasRect&&(()=>{
            const el=activeLayers.find(l=>l.id===editingId);
            if(!el)return null;
            const bb=getLayerBBox(el)||{x:0,y:0,w:200,h:60};
            const ex=canvasRect.left+(bb.x+BLEED)*scale;
            const ey=canvasRect.top+(bb.y+BLEED)*scale;
            const ew=bb.w*scale;
            const eh=bb.h*scale;
            const fs=(el.fontSize||32)*scale;
            const lh=fs*(el.lineHeight||1.3);
            const ff=el.fontFamily||'monospace';
            const fw=el.bold?'bold':'normal';
            const fst=el.italic?'italic':'normal';
            const col=el.color||'#fff';
            const ta=el.align||'left';
            return ReactDOM.createPortal(
              <div
                ref={textEditorRef}
                contentEditable suppressContentEditableWarning
                onKeyDown={e=>{if(e.key==='Escape'){e.preventDefault();commitTextEdit();}}}
                onBlur={commitTextEdit}
                onMouseDown={e=>e.stopPropagation()}
                onInput={e=>{
                  // Expand layer h to fit typed content, then refresh canvasRect
                  const el2=e.currentTarget;
                  const newH=Math.round(el2.scrollHeight/scaleRef.current);
                  updateLayerRef.current&&updateLayerRef.current(editingId,{h:newH});
                }}
                style={{
                  position:'fixed',left:ex,top:ey,width:ew,
                  minHeight:eh,height:'auto',overflow:'visible',
                  fontSize:fs,
                  lineHeight:lh+'px',
                  fontFamily:ff,fontWeight:fw,fontStyle:fst,color:col,textAlign:ta,
                  whiteSpace:'pre-wrap',wordBreak:'break-word',
                  padding:0,margin:0,zIndex:10001,
                  caretColor:col,cursor:'text',
                  letterSpacing:(el.letterSpacing||0)+'px',
                  textDecoration:el.underline?'underline':'none',
                  textTransform:el.caps?'uppercase':'none',
                  outline:`2px solid rgba(200,255,0,0.55)`,outlineOffset:'2px',
                  boxSizing:'border-box',background:'transparent',border:'none',
                }}
                dangerouslySetInnerHTML={{__html:(el.text||'').replace(/\n/g,'<br/>')}}
              />,
              document.body
            );
          })()}
          {/* Fixed-position selection overlay — portalled to body, no overflow clipping */}
          {selLayer&&selLayer.type!=='bg'&&canvasRect&&(()=>{
            // Use canvasRectRef for latest rect, activeLayersRef for latest layer data
            const freshSel=activeLayersRef.current.find(l=>l.id===selLayer.id)||selLayer;
            const bb=getLayerBBox(freshSel);
            if(!bb)return null;
            const cr=canvasRectRef.current||canvasRect;
            // Canvas is oversized by BLEED on each side; offset coords accordingly
            const ox=cr.left+(bb.x+BLEED)*scale;
            const oy=cr.top+(bb.y+BLEED)*scale;
            const ow=bb.w*scale;
            const oh=bb.h*scale;
            const HS=8; // handle size px
            const handles=[
              {id:'nw',x:ox,      y:oy,       cur:'nwse-resize'},
              {id:'n', x:ox+ow/2, y:oy,       cur:'ns-resize'},
              {id:'ne',x:ox+ow,   y:oy,       cur:'nesw-resize'},
              {id:'e', x:ox+ow,   y:oy+oh/2,  cur:'ew-resize'},
              {id:'se',x:ox+ow,   y:oy+oh,    cur:'nwse-resize'},
              {id:'s', x:ox+ow/2, y:oy+oh,    cur:'ns-resize'},
              {id:'sw',x:ox,      y:oy+oh,    cur:'nesw-resize'},
              {id:'w', x:ox,      y:oy+oh/2,  cur:'ew-resize'},
            ];
            return ReactDOM.createPortal(
              <div data-tl-overlay style={{position:'fixed',left:0,top:0,width:0,height:0,pointerEvents:'none',zIndex:9999}}>
                {/* Outline */}
                <div ref={el=>overlayRef.current.outline=el} style={{position:'fixed',left:ox,top:oy,width:ow,height:oh,
                  border:`1px dashed ${T.accent}`,boxSizing:'border-box',pointerEvents:'none'}}/>
                {/* Handles */}
                {handles.map(h=>(
                  <div key={h.id} ref={el=>overlayRef.current['h'+handles.indexOf(h)]=el}
                    onMouseDown={e=>{
                      e.preventDefault();e.stopPropagation();
                      // h.id is the handle — no need to hit-test, we're already on the handle
                      const selId=activeSelectedIdRef.current;
                      const freshS=activeLayersRef.current.find(l=>l.id===selId);
                      if(freshS){
                        const bb2=getLayerBBox(freshS)||{x:0,y:0,w:100,h:100};
                        iact.current={mode:'resize',layerId:freshS.id,handle:h.id,
                          startX:e.clientX,startY:e.clientY,
                          origX:bb2.x,origY:bb2.y,origW:bb2.w,origH:bb2.h};
                        setCursorStyle(h.cur);
                      }
                    }}
                    data-tl-overlay
                    style={{position:'fixed',
                      left:h.x-HS/2,top:h.y-HS/2,
                      width:HS,height:HS,
                      background:T.bg,border:`1.5px solid ${T.accent}`,
                      borderRadius:1,pointerEvents:'auto',
                      cursor:h.cur,zIndex:10000,
                      boxShadow:'0 1px 4px rgba(0,0,0,0.6)',
                    }}/>
                ))}
              </div>,
              document.body
            );
          })()}
        {artState.showGuides&&<div style={{
          position:'absolute',bottom:10,left:0,right:0,
          textAlign:'center',fontSize:7,color:'rgba(255,255,255,0.28)',
          letterSpacing:'0.08em',pointerEvents:'none',zIndex:2}}>
          {tpl.w}×{tpl.h}px · drag to move · handles to resize
        </div>}
      </div>

      {/* ── RIGHT: properties ── */}
      {artPropsPanel.expandStub}
      <div style={{width:artPropsPanel.width,flexShrink:0,background:T.panel,borderLeft:artPropsPanel.collapsed?'none':`1px solid ${T.border}`,overflow:'hidden',padding:artPropsPanel.collapsed?0:'10px 12px',position:'relative',transition:'width 0.15s'}}>
        <div {...artPropsPanel.handle}/>
        {artPropsPanel.tab}
        {!selLayer
          ?<div style={{fontSize:9,color:T.muted,textAlign:'center',marginTop:40,lineHeight:1.8}}>Select a layer</div>
          :(<>
            <div style={{fontSize:7,color:T.accent,letterSpacing:'0.14em',textTransform:'uppercase',marginBottom:8}}>{selLayer.type} layer</div>
            <F T={T} label="Name"><TInp T={T} value={selLayer.name} onChange={e=>updateSel({name:e.target.value})}/></F>
            <F T={T} label={`Opacity ${Math.round((selLayer.opacity??1)*100)}%`}>
              <input type="range" min={0} max={1} step={0.01} value={selLayer.opacity??1}
                onChange={e=>updateSel({opacity:+e.target.value})} style={{width:'100%'}}/>
            </F>

            {selLayer.type==='bg'&&(
              <F T={T} label="Color"><div style={{display:'flex',gap:6,alignItems:'center'}}>
                <input type="color" value={selLayer.color||'#000000'} onChange={e=>updateSel({color:e.target.value})}/>
                <TInp T={T} value={selLayer.color||'#000000'} onChange={e=>updateSel({color:e.target.value})} style={{flex:1,fontSize:10}}/>
              </div></F>
            )}

            {selLayer.type==='image'&&(<>
              <Row2>
                <F T={T} label="X"><TInp T={T} type="number" value={selLayer.x||0} onChange={e=>updateSel({x:+e.target.value})}/></F>
                <F T={T} label="Y"><TInp T={T} type="number" value={selLayer.y||0} onChange={e=>updateSel({y:+e.target.value})}/></F>
              </Row2>
              <Row2>
                <F T={T} label="W"><TInp T={T} type="number" min={1} value={selLayer.w||tpl.w} onChange={e=>updateSel({w:+e.target.value})}/></F>
                <F T={T} label="H"><TInp T={T} type="number" min={1} value={selLayer.h||tpl.h} onChange={e=>updateSel({h:+e.target.value})}/></F>
              </Row2>
              <button onClick={()=>{pendingImg.current=selLayer.id;fileRef.current.click();}} style={{...mkBtn(T),width:'100%',fontSize:9,padding:'6px 0',marginTop:2}}>↺ Replace Image</button>
            </>)}

            {selLayer.type==='text'&&(()=>{
              const tl=selLayer;
              const fmtBtn=(label,active,onClick,title)=>(
                <button title={title} onClick={onClick} style={{
                  flex:1,padding:'5px 0',fontSize:11,fontWeight:700,
                  background:active?T.accent:T.bg,
                  color:active?T.bg:T.muted,
                  border:`1px solid ${active?T.accent:T.border}`,
                  cursor:'pointer',borderRadius:T.r||0,fontFamily:'inherit',lineHeight:1,
                }}>{label}</button>
              );
              return(<>
                {/* ── Double-click hint ── */}
                <div style={{fontSize:7,color:T.muted,marginBottom:8,letterSpacing:'0.06em',lineHeight:1.5,
                  padding:'5px 8px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                  Double-click layer on canvas to edit text inline
                </div>

                {/* ── Font family ── */}
                <F T={T} label="Font">
                  <select value={tl.fontFamily||'"Share Tech Mono",monospace'}
                    onChange={e=>updateSel({fontFamily:e.target.value})} style={{...mkIS(T),fontSize:9}}>
                    {FONT_GROUPS.map(g=>(
                      <optgroup key={g.label} label={g.label}>
                        {g.keys.filter(k=>FONTS[k]).map(k=>(
                          <option key={k} value={FONTS[k].css}>{FONTS[k].name}</option>
                        ))}
                      </optgroup>
                    ))}
                  </select>
                </F>

                {/* ── Size + Line height ── */}
                <Row2>
                  <F T={T} label="Size">
                    <div style={{display:'flex',alignItems:'center',gap:3}}>
                      <button onClick={()=>updateSel({fontSize:Math.max(6,(tl.fontSize||32)-1)})}
                        style={{...mkBtn(T),padding:'3px 7px',fontSize:12,lineHeight:1}}>−</button>
                      <TInp T={T} type="number" min={6} value={tl.fontSize||32}
                        onChange={e=>updateSel({fontSize:Math.max(6,+e.target.value)})}
                        style={{textAlign:'center',width:44,fontSize:11}}/>
                      <button onClick={()=>updateSel({fontSize:(tl.fontSize||32)+1})}
                        style={{...mkBtn(T),padding:'3px 7px',fontSize:12,lineHeight:1}}>+</button>
                    </div>
                  </F>
                  <F T={T} label="Leading">
                    <TInp T={T} type="number" min={0.5} max={4} step={0.05}
                      value={tl.lineHeight||1.3}
                      onChange={e=>updateSel({lineHeight:Math.max(0.5,+e.target.value)})}
                      style={{fontSize:11}}/>
                  </F>
                </Row2>

                {/* ── Bold / Italic / Underline / Caps ── */}
                <F T={T} label="Style">
                  <div style={{display:'flex',gap:4}}>
                    {fmtBtn('B',tl.bold,()=>updateSel({bold:!tl.bold}),'Bold')}
                    {fmtBtn('I',tl.italic,()=>updateSel({italic:!tl.italic}),'Italic')}
                    {fmtBtn('U',tl.underline,()=>updateSel({underline:!tl.underline}),'Underline')}
                    {fmtBtn('AA',tl.caps,()=>updateSel({caps:!tl.caps}),'Uppercase')}
                  </div>
                </F>

                {/* ── Alignment — L / C / R ── */}
                <F T={T} label="Align">
                  <div style={{display:'flex',gap:4}}>
                    {[
                      {a:'left',   lines:[[1,2,13,2],[1,5,9,5],[1,8,12,8],[1,11,7,11]]},
                      {a:'center', lines:[[1,2,13,2],[3,5,11,5],[2,8,12,8],[4,11,10,11]]},
                      {a:'right',  lines:[[1,2,13,2],[5,5,13,5],[2,8,13,8],[7,11,13,11]]},
                    ].map(({a,lines})=>{
                      const active=(tl.align||'left')===a;
                      return(
                        <button key={a} title={a.charAt(0).toUpperCase()+a.slice(1)}
                          onClick={()=>updateSel({align:a})}
                          style={{flex:1,padding:'6px 0',display:'flex',alignItems:'center',
                            justifyContent:'center',background:active?T.accent:T.bg,
                            color:active?T.bg:T.muted,
                            border:`1px solid ${active?T.accent:T.border}`,
                            cursor:'pointer',borderRadius:T.r||0}}>
                          <svg width="14" height="13" viewBox="0 0 14 13" fill="none"
                            stroke="currentColor" strokeWidth="1.5" strokeLinecap="round">
                            {lines.map(([x1,y1,x2,y2],i)=>(
                              <line key={i} x1={x1} y1={y1} x2={x2} y2={y2}/>
                            ))}
                          </svg>
                        </button>
                      );
                    })}
                  </div>
                </F>

                {/* ── Color + Letter spacing ── */}
                <Row2>
                  <F T={T} label="Color">
                    <div style={{display:'flex',gap:4,alignItems:'center'}}>
                      <input type="color" value={tl.color||'#ffffff'} onChange={e=>updateSel({color:e.target.value})}/>
                      <TInp T={T} value={tl.color||'#ffffff'} onChange={e=>updateSel({color:e.target.value})} style={{flex:1,fontSize:9}}/>
                    </div>
                  </F>
                  <F T={T} label="Spacing">
                    <TInp T={T} type="number" min={-10} max={100} step={0.5}
                      value={tl.letterSpacing||0}
                      onChange={e=>updateSel({letterSpacing:+e.target.value})}
                      style={{fontSize:11}}/>
                  </F>
                </Row2>

                {/* ── Position + Size ── */}
                <Row2>
                  <F T={T} label="X"><TInp T={T} type="number" value={tl.x||0} onChange={e=>updateSel({x:+e.target.value})}/></F>
                  <F T={T} label="Y"><TInp T={T} type="number" value={tl.y||0} onChange={e=>updateSel({y:+e.target.value})}/></F>
                </Row2>
                <Row2>
                  <F T={T} label="W"><TInp T={T} type="number" min={20} value={tl.w||Math.round(tpl.w*0.84)} onChange={e=>updateSel({w:+e.target.value})}/></F>
                  <F T={T} label="H"><TInp T={T} type="number" min={10} value={tl.h||Math.round((tl.fontSize||32)*2.2)} onChange={e=>updateSel({h:+e.target.value})}/></F>
                </Row2>
              </>);
            })()}

            {selLayer.type==='shape'&&(<>
              <F T={T} label="Shape"><TSel T={T} value={selLayer.shapeType||'rect'} onChange={e=>updateSel({shapeType:e.target.value})}>
                <option value="rect">Rectangle</option><option value="ellipse">Ellipse / Circle</option>
              </TSel></F>
              <F T={T} label="Fill"><div style={{display:'flex',gap:6,alignItems:'center'}}>
                <input type="color" value={selLayer.fill&&selLayer.fill!=='transparent'?selLayer.fill:'#000000'} onChange={e=>updateSel({fill:e.target.value})}/>
                <TInp T={T} value={selLayer.fill||'transparent'} onChange={e=>updateSel({fill:e.target.value})} style={{flex:1,fontSize:10}}/>
              </div></F>
              <F T={T} label="Stroke"><div style={{display:'flex',gap:6,alignItems:'center'}}>
                <input type="color" value={selLayer.stroke&&selLayer.stroke!=='transparent'?selLayer.stroke:'#ffffff'} onChange={e=>updateSel({stroke:e.target.value})}/>
                <TInp T={T} value={selLayer.stroke||'transparent'} onChange={e=>updateSel({stroke:e.target.value})} style={{flex:1,fontSize:10}}/>
              </div></F>
              <F T={T} label="Stroke W"><TInp T={T} type="number" min={0} value={selLayer.strokeW||2} onChange={e=>updateSel({strokeW:+e.target.value})}/></F>
              <Row2>
                <F T={T} label="X"><TInp T={T} type="number" value={selLayer.x||0} onChange={e=>updateSel({x:+e.target.value})}/></F>
                <F T={T} label="Y"><TInp T={T} type="number" value={selLayer.y||0} onChange={e=>updateSel({y:+e.target.value})}/></F>
              </Row2>
              <Row2>
                <F T={T} label="W"><TInp T={T} type="number" min={1} value={selLayer.w||100} onChange={e=>updateSel({w:+e.target.value})}/></F>
                <F T={T} label="H"><TInp T={T} type="number" min={1} value={selLayer.h||100} onChange={e=>updateSel({h:+e.target.value})}/></F>
              </Row2>
            </>)}
          </>)
        }
      </div>
    </div>
  );
}


const STATUS_OPT={draft:{label:'Draft',color:'#888'},complete:{label:'Complete',color:'#58a6ff'},released:{label:'Released',color:'#3fb950'},archived:{label:'Archived',color:'#8b949e'}};
const CREDIT_ROLES=['Songwriter','Composer','Lyricist','Producer','Co-Producer','Featured Artist','Mixer','Mastering Engineer','Performer','Arranger','Publisher','Label','Other'];
const PRO_LIST=['—','ASCAP','BMI','SESAC','SOCAN','PRS','APRA AMCOS','GEMA','STIM','SACEM','Other'];
// ━━━━━━━━ HELPERS ━━━━━━━━
const todayStr=()=>{const d=new Date();return`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;};
const shortUrl=u=>{try{const p=new URL(u);return p.hostname+(p.pathname!=='/'?p.pathname.slice(0,22):'');}catch{return u.slice(0,28);}};
const getCodeDesc=code=>{const d=code.replace('.','').toUpperCase().split('');if(d.length<4)return'';return[CLS.digit1.options[d[0]],CLS.digit2.options[d[1]],CLS.digit3.options[d[2]],CLS.digit4.options[d[3]]].filter(Boolean).join(' • ');};
const rgba=(hex,alpha=1)=>{if(!hex||hex==='transparent')return'transparent';const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);return`rgba(${r},${g},${b},${alpha})`;};
const loadLS=(k,d)=>{try{const v=localStorage.getItem(k);return v?JSON.parse(v):d;}catch{return d;}};
const saveLS=(k,v)=>{try{localStorage.setItem(k,JSON.stringify(v));}catch{}};
const getColors=s=>{const base=s.scheme==='custom'?s.customColors:(BASE_SCHEMES[s.scheme]||BASE_SCHEMES.blanc);return{...base,_bgAlpha:s.bgAlpha??1,_fgAlpha:s.fgAlpha??1};};
const REQUIRED_THEME_KEYS=['bg','panel','border','text','sub','accent','muted','card','bright'];
const getAppTheme=at=>{
  // Guard: if at is missing or malformed, return a safe default immediately
  if(!at||typeof at!=='object') return {...APP_THEMES.void,r:0};
  const base=at.themeKey==='custom'
    ?{bg:at.customBg||'#06060a',panel:at.customPanel||'#0b0b10',border:at.customBorder||'#141418',
      text:at.customText||'#888',sub:at.customSub||'#55556a',accent:at.customAccent||'#c8ff00',
      muted:at.customBorder||'#141418',card:at.customPanel||'#0b0b10',
      bright:at.customBright||at.customText||'#ccc'}
    :(APP_THEMES[at.themeKey]||APP_THEMES.void);
  // Guard: if base is somehow missing required keys, fall back to void
  if(REQUIRED_THEME_KEYS.some(k=>!base[k])) return {...APP_THEMES.void,r:at.borderRadius||0};
  const merged={...base,r:at.borderRadius||0};
  // Apply color overrides — no guards, user intent is absolute
  if(at.colorOverrides&&at.themeKey!=='custom'){
    if(at.customBg)     { merged.bg=at.customBg; merged.card=at.customBg; merged.panel=at.customBg; }
    if(at.customAccent) merged.accent=at.customAccent;
    if(at.customText)   merged.text=at.customText;
    if(at.customSub)    merged.sub=at.customSub;
    if(at.customBright) merged.bright=at.customBright;
  }
  return merged;
};
const isrcValid=v=>/^[A-Z]{2}-[A-Z0-9]{3}-\d{2}-\d{5}$/.test(v);
const upcValid=v=>/^\d{12,13}$/.test(v.replace(/[\s-]/g,''));
const fmtBytes=b=>b>1048576?`${(b/1048576).toFixed(1)} MB`:b>1024?`${(b/1024).toFixed(0)} KB`:`${b} B`;
// Formats stored YYYY-MM-DD → "14 Jan 2025" — handles missing/malformed gracefully
const fmtDate=str=>{
  if(!str)return'';
  try{
    const[y,m,d]=str.split('-');
    const MON=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return`${+d} ${MON[+m-1]||'?'} ${y}`;
  }catch{return str;}
};

// ━━━━━━━━ INDEXEDDB ━━━━━━━━
const IDB={
  _db:null,
  // v2: adds dedicated 'assets' store; keeps 'blobs' for backwards compat
  open(){return new Promise((res,rej)=>{if(this._db)return res(this._db);const req=indexedDB.open('tracklab',2);req.onupgradeneeded=e=>{const db=e.target.result;if(!db.objectStoreNames.contains('blobs'))db.createObjectStore('blobs');if(!db.objectStoreNames.contains('assets'))db.createObjectStore('assets');};req.onsuccess=e=>{this._db=e.target.result;res(this._db);};req.onerror=()=>rej(req.error);});},
  async set(k,v,store='assets'){const db=await this.open();return new Promise((res,rej)=>{const tx=db.transaction(store,'readwrite');tx.objectStore(store).put(v,k);tx.oncomplete=res;tx.onerror=()=>rej(tx.error);});},
  async get(k,store='assets'){const db=await this.open();return new Promise((res,rej)=>{const req=db.transaction(store,'readonly').objectStore(store).get(k);req.onsuccess=()=>res(req.result);req.onerror=()=>rej(req.error);});},
  async del(k,store='assets'){const db=await this.open();return new Promise((res,rej)=>{const tx=db.transaction(store,'readwrite');tx.objectStore(store).delete(k);tx.oncomplete=res;tx.onerror=()=>rej(tx.error);});},
};
// Named boot hook — call once on app mount to guarantee DB schema is ready
const initDB=()=>IDB.open();

// ━━━━━━━━ DITHERING ━━━━━━━━
function atkinsonDither(imgEl,tw,th,threshold=128,contrast=0){
  const c=document.createElement('canvas');c.width=tw;c.height=th;
  const ctx=c.getContext('2d');ctx.filter=`contrast(${100+contrast}%)`;ctx.drawImage(imgEl,0,0,tw,th);
  const id=ctx.getImageData(0,0,tw,th),d=id.data,w=tw,h=th,g=new Float32Array(w*h);
  for(let i=0;i<w*h;i++){const p=i*4;g[i]=0.299*d[p]+0.587*d[p+1]+0.114*d[p+2];}
  for(let y=0;y<h;y++){for(let x=0;x<w;x++){const i=y*w+x,old=Math.max(0,Math.min(255,g[i])),nw=old<threshold?0:255;g[i]=nw;const err=(old-nw)/8;[[x+1,y],[x+2,y],[x-1,y+1],[x,y+1],[x+1,y+1],[x,y+2]].forEach(([nx,ny])=>{if(nx>=0&&nx<w&&ny>=0&&ny<h)g[ny*w+nx]+=err;});}}
  for(let i=0;i<w*h;i++){const p=i*4;const v=Math.round(g[i]);d[p]=d[p+1]=d[p+2]=v;d[p+3]=255;}
  ctx.putImageData(id,0,0);return c.toDataURL('image/png');
}

// ━━━━━━━━ QR BLOCK ━━━━━━━━
function QRBlock({url,colors,size}){
  const ref=useRef();
  useEffect(()=>{
    if(!ref.current)return;ref.current.innerHTML='';
    const t=url&&url.trim()?url.trim():'https://example.com';
    try{new QRCode(ref.current,{text:t,width:size,height:size,colorDark:colors.fg,colorLight:colors.bg,correctLevel:QRCode.CorrectLevel.M});}catch(e){}
  },[url,colors.fg,colors.bg,size]);
  return <div ref={ref} style={{width:size,height:size,display:'flex',alignItems:'center',justifyContent:'center'}}/>;
}
// ━━━━━━━━ TRACK LABEL COMPONENT ━━━━━━━━
const TrackLabel=React.forwardRef(function TrackLabel({fields,settings},ref){
  const sc=getColors(settings),ff=FONTS[settings.font]?.css||FONTS['share-tech'].css;
  const bw=settings.outerBorder||0,W=settings.labelW,H=settings.labelH,bd=settings.borders||{};
  const ibw=Math.max(1,Math.round(bw*0.6));
  const bl=()=>`${ibw}px solid ${rgba(sc.border)}`;
  const metaVals=settings.metaFields?.filter(f=>f.show)||[];
  const qrSize=Math.min(84,Math.round(W*0.2));
  const qrUrl=settings.qrMode==='dynamic'?`https://go.tracklab.io/${settings.dynamicId}`:(fields.url||'');
  let bg={background:rgba(sc.bg,sc._bgAlpha)};
  if(settings.useGradient)bg={background:`linear-gradient(${settings.gradDir||'to bottom'},${rgba(sc.bg,sc._bgAlpha)},${rgba(settings.gradColor2,sc._bgAlpha)})`};
  return(
    <div ref={ref} style={{width:W,height:H,display:'flex',flexDirection:'column',fontFamily:ff,position:'relative',overflow:'hidden',flexShrink:0,border:bw>0?`${bw}px solid ${rgba(sc.border)}`:'none',...bg}}>
      {settings.showBanner&&(
        <div style={{background:rgba(sc.bannerBg,sc._bgAlpha),color:rgba(sc.bannerFg,sc._fgAlpha),display:'flex',alignItems:'center',justifyContent:'space-between',padding:'5px 10px',flexShrink:0,minHeight:36,borderBottom:bd.bannerBottom?bl():'none'}}>
          <div style={{fontSize:settings.artistSize||15,fontWeight:settings.artistBold?800:400,fontStyle:settings.artistItalic?'italic':'normal',letterSpacing:'0.05em',lineHeight:1,textTransform:'none'}}>{fields.artist||'ARTIST'}</div>
          <div style={{fontSize:9,letterSpacing:'0.15em',opacity:0.75,fontFamily:ff,textTransform:'none'}}>{fields.catalog}</div>
        </div>
      )}
      <div style={{padding:'7px 10px 5px',flexShrink:0,position:'relative',borderBottom:bd.titleBottom?bl():'none',...bg}}>
        <div style={{fontSize:7,letterSpacing:'0.25em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha),marginBottom:2,fontFamily:ff}}>Track</div>
        <div style={{fontSize:settings.titleSize,fontWeight:settings.titleBold?800:400,fontStyle:settings.titleItalic?'italic':'normal',textAlign:settings.titleAlign||'left',lineHeight:1.0,letterSpacing:'0.02em',textTransform:'none',color:rgba(sc.fg,sc._fgAlpha),wordBreak:'break-word',paddingRight:42,fontFamily:ff}}>{fields.title||'UNTITLED'}</div>
        <div style={{position:'absolute',right:10,top:8,fontSize:Math.round(settings.titleSize*0.8),fontWeight:700,color:rgba(sc.accent,0.22),lineHeight:1,fontFamily:ff}}>{fields.trackNum}</div>
      </div>
      {settings.showMeta&&metaVals.length>0&&(
        <div style={{display:'flex',background:rgba(sc.metaBg,sc._bgAlpha),borderBottom:bd.metaBottom?bl():'none',flexShrink:0,minHeight:32}}>
          {metaVals.map((mf,i)=>(
            <div key={mf.id} style={{flex:1,display:'flex',flexDirection:'column',justifyContent:'center',padding:'0 7px',borderRight:bd.metaCellDividers&&i<metaVals.length-1?`1px solid ${rgba(sc.metaFg,0.12)}`:'none'}}>
              <div style={{fontSize:settings.metaLabelSize||6,letterSpacing:'0.22em',textTransform:'uppercase',opacity:settings.metaLabelColor?1:0.45,color:settings.metaLabelColor?rgba(settings.metaLabelColor,sc._fgAlpha):rgba(sc.metaFg,sc._fgAlpha),marginBottom:1,fontFamily:ff}}>{mf.label}</div>
              <div style={{fontSize:settings.metaSize,fontWeight:700,color:rgba(sc.metaFg,sc._fgAlpha),lineHeight:1,fontFamily:ff}}>{mf.value||'—'}</div>
            </div>
          ))}
        </div>
      )}
      {settings.showClass&&fields.classCode&&(
        <div style={{background:rgba(sc.codeBg,sc._bgAlpha),padding:'5px 10px',borderBottom:bd.classBottom?bl():'none',flexShrink:0,display:'flex',alignItems:'baseline',gap:8}}>
          <div style={{fontSize:17,fontWeight:700,color:rgba(sc.codeFg,sc._fgAlpha),letterSpacing:'0.12em',flexShrink:0,fontFamily:ff}}>{fields.classCode}</div>
          <div style={{fontSize:8,color:rgba(sc.sub,sc._fgAlpha),letterSpacing:'0.04em',lineHeight:1.3,flex:1,overflow:'hidden',fontFamily:ff}}>{fields.classDesc||getCodeDesc(fields.classCode)}</div>
        </div>
      )}
      {settings.showDesc&&(
        <div style={{padding:'6px 10px',borderBottom:bd.descBottom?bl():'none',flexShrink:0,...bg}}>
          <div style={{fontSize:7,letterSpacing:'0.22em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha),marginBottom:3,fontFamily:ff}}>Notes</div>
          <div style={{fontSize:settings.bodySize,fontWeight:settings.bodyBold?700:400,fontStyle:settings.bodyItalic?'italic':'normal',textAlign:settings.bodyAlign||'left',lineHeight:1.45,color:rgba(sc.fg,sc._fgAlpha),overflow:'hidden',maxHeight:Math.round(settings.bodySize*1.45*3),fontFamily:ff}}>{fields.description}</div>
        </div>
      )}
      {settings.showCodes&&(fields.isrc||fields.upc)&&(
        <div style={{padding:'4px 10px',borderBottom:bd.descBottom?bl():'none',flexShrink:0,...bg,display:'flex',gap:16,alignItems:'center'}}>
          {fields.isrc&&<div style={{display:'flex',gap:5,alignItems:'baseline'}}><span style={{fontSize:6,letterSpacing:'0.2em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha*0.7),fontFamily:ff}}>ISRC</span><span style={{fontSize:8,fontWeight:700,color:rgba(sc.fg,sc._fgAlpha),letterSpacing:'0.12em',fontFamily:ff}}>{fields.isrc}</span></div>}
          {fields.upc&&<div style={{display:'flex',gap:5,alignItems:'baseline'}}><span style={{fontSize:6,letterSpacing:'0.2em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha*0.7),fontFamily:ff}}>UPC</span><span style={{fontSize:8,fontWeight:700,color:rgba(sc.fg,sc._fgAlpha),letterSpacing:'0.12em',fontFamily:ff}}>{fields.upc}</span></div>}
        </div>
      )}
      <div style={{flex:1,display:'flex',overflow:'hidden',minHeight:0,borderBottom:bd.bottomBorder?bl():'none',...bg}}>
        {settings.showQR&&!settings.qrFloat&&(
          <div style={{width:Math.round(W*0.3),flexShrink:0,display:'flex',flexDirection:'column',alignItems:'center',justifyContent:'center',gap:4,borderRight:bd.qrDivider?bl():'none',padding:'6px 8px'}}>
            <QRBlock url={qrUrl} colors={sc} size={qrSize}/>
            <div style={{fontSize:7,letterSpacing:'0.12em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha),textAlign:'center',fontFamily:ff}}>{settings.qrCaption||'SCAN'}</div>
          </div>
        )}
        <div style={{flex:1,padding:'8px 9px',display:'flex',flexDirection:'column',gap:5,overflow:'hidden'}}>
          {settings.showTags&&(
            <><div style={{fontSize:7,letterSpacing:'0.22em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha),fontFamily:ff}}>Tags</div>
            <div style={{display:'flex',flexWrap:'wrap',gap:3}}>{(fields.tags||'').split(',').map(t=>t.trim()).filter(Boolean).map((t,i)=>(
              <div key={i} style={{background:rgba(sc.strip,sc._bgAlpha),color:rgba(sc.accent,sc._fgAlpha),fontSize:settings.tagSize,fontWeight:700,letterSpacing:'0.06em',padding:'2px 5px',border:`1px solid ${rgba(sc.border)}`,textTransform:'uppercase',fontFamily:ff}}>{t}</div>
            ))}</div></>
          )}
          <div style={{marginTop:'auto',fontSize:8,color:rgba(sc.sub,sc._fgAlpha*0.7),wordBreak:'break-all',lineHeight:1.4,fontFamily:ff}}>{fields.url?shortUrl(fields.url):''}</div>
        </div>
      </div>
      {settings.showQR&&settings.qrFloat&&(
        <div style={{position:'absolute',left:settings.qrFloatX,top:settings.qrFloatY,display:'flex',flexDirection:'column',alignItems:'center',gap:3,zIndex:15,pointerEvents:'none'}}>
          <QRBlock url={qrUrl} colors={sc} size={settings.qrFloatSize||84}/>
          {settings.qrCaption&&<div style={{fontSize:7,letterSpacing:'0.12em',textTransform:'uppercase',color:rgba(sc.sub,sc._fgAlpha),textAlign:'center',fontFamily:ff}}>{settings.qrCaption}</div>}
        </div>
      )}
      {settings.showFooter&&(
        <div style={{height:22,background:rgba(sc.strip,sc._bgAlpha),display:'flex',alignItems:'center',justifyContent:'space-between',padding:'0 9px',flexShrink:0,borderTop:bd.footerTop?bl():'none'}}>
          <div style={{fontSize:7,letterSpacing:'0.08em',color:rgba(sc.sub,sc._fgAlpha),fontFamily:ff,textTransform:'none'}}>{[fields.artist,fields.catalog].filter(Boolean).join(' · ')}</div>
          <div style={{fontSize:7,letterSpacing:'0.08em',color:rgba(sc.sub,sc._fgAlpha),fontFamily:ff,display:'flex',gap:8}}>
            {settings.codesInFooter&&(fields.isrc||fields.upc)?(
              <>{fields.isrc&&<span><span style={{opacity:0.55,fontSize:6}}>ISRC </span>{fields.isrc}</span>}{fields.upc&&<span><span style={{opacity:0.55,fontSize:6}}>UPC </span>{fields.upc}</span>}</>
            ):(settings.metaFields?.filter(f=>f.show).slice(0,2)||[]).map(f=>f.value).filter(Boolean).join(' · ')}
          </div>
        </div>
      )}
      {settings.showImage&&settings.imageData&&(
        <div style={{position:'absolute',left:settings.imageX,top:settings.imageY,width:settings.imageW,height:settings.imageH,pointerEvents:'none',mixBlendMode:settings.ditherBlend?'multiply':'normal'}}>
          <img src={settings.imageData} style={{width:'100%',height:'100%',objectFit:'contain',display:'block',imageRendering:'pixelated'}} alt=""/>
        </div>
      )}
      {(settings.textBlocks||[]).map(tb=>(
        <div key={tb.id} style={{position:'absolute',left:tb.x,top:tb.y,zIndex:20,fontSize:tb.size||12,fontWeight:tb.bold?700:400,fontStyle:tb.italic?'italic':'normal',textAlign:tb.align||'left',color:rgba(tb.color||sc.fg,tb.opacity??1),fontFamily:FONTS[tb.font||settings.font]?.css||ff,letterSpacing:'0.05em',lineHeight:1.3,width:tb.w||'auto',whiteSpace:tb.wrap?'pre-wrap':'nowrap',textTransform:tb.caps?'uppercase':'none'}}>{tb.text}</div>
      ))}
    </div>
  );
});
// ━━━━━━━━ UI PRIMITIVES — ALL DEFINED OUTSIDE APP TO PREVENT REMOUNT BUG ━━━━━━━━
const mkIS=T=>({width:'100%',background:T.bg,border:`1px solid ${T.border}`,color:T.bright,fontFamily:'inherit',fontSize:12,padding:'5px 8px',outline:'none',marginBottom:0,borderRadius:T.r||0,lineHeight:'1.4',verticalAlign:'middle'});
const mkLBL=T=>({display:'block',fontSize:8,letterSpacing:'0.18em',textTransform:'uppercase',color:T.muted,marginBottom:3,fontFamily:'inherit'});
const mkCard=T=>({background:T.card,border:`1px solid ${T.border}`,padding:16,marginBottom:12,borderRadius:(T.r||0)*1.5});
const mkBtn=(T,primary=false)=>({padding:'8px 16px',background:primary?T.accent:T.panel,color:primary?T.bg:T.text,border:`1px solid ${primary?T.accent:T.border}`,fontFamily:'inherit',fontSize:10,letterSpacing:'0.12em',textTransform:'uppercase',cursor:'pointer',fontWeight:primary?700:400,borderRadius:T.r||0});
const btnMini={background:'none',border:'none',color:'#555',fontSize:11,cursor:'pointer',padding:'0 3px',flexShrink:0};

function TInp({T,style,...p}){return<input {...p} style={{...mkIS(T),...style}}/>;}
function TSel({T,style,children,...p}){return<select {...p} style={{...mkIS(T),...style}}>{children}</select>;}
function TTxt({T,style,...p}){return<textarea {...p} style={{...mkIS(T),resize:'vertical',minHeight:56,lineHeight:1.45,...style}}/>;}
function Row2({children}){return<div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6}}>{children}</div>;}
function F({T,label,children,mt=0}){return<div style={{marginBottom:7,marginTop:mt}}>{label&&<label style={mkLBL(T)}>{label}</label>}{children}</div>;}

// MF: metadata field wrapper — receives T as prop, never defined inside App
function MF({T,label,hint,children}){
  return(
    <div style={{marginBottom:10}}>
      {label&&<label style={mkLBL(T)}>{label}</label>}
      {children}
      {hint&&<div style={{fontSize:8,color:T.muted,marginTop:3,lineHeight:1.5,letterSpacing:'0.03em'}}>{hint}</div>}
    </div>
  );
}

function Accordion({T,title,children,defaultOpen=false}){
  const [open,setOpen]=useState(defaultOpen);
  return(
    <div style={{borderBottom:`1px solid ${T.border}`}}>
      <div onClick={()=>setOpen(o=>!o)} style={{display:'flex',justifyContent:'space-between',alignItems:'center',padding:'9px 0',cursor:'pointer',userSelect:'none'}}>
        <span style={{fontSize:9,letterSpacing:'0.2em',textTransform:'uppercase',color:T.muted}}>{title}</span>
        <span style={{fontSize:10,color:T.muted,transform:open?'rotate(180deg)':'none',transition:'transform 0.15s'}}>▾</span>
      </div>
      {open&&<div style={{paddingBottom:12}}>{children}</div>}
    </div>
  );
}

function Tog({T,label,value,onChange}){
  return(
    <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:6,cursor:'pointer'}} onClick={()=>onChange(!value)}>
      <span style={{fontSize:10,color:value?T.text:T.muted,letterSpacing:'0.06em'}}>{label}</span>
      <div style={{width:28,height:14,background:value?T.accent:T.bg,borderRadius:7,position:'relative',flexShrink:0,border:`1px solid ${T.border}`,transition:'background 0.12s'}}>
        <div style={{position:'absolute',top:2,left:value?14:2,width:8,height:8,borderRadius:'50%',background:value?T.bg:T.muted,transition:'left 0.12s'}}/>
      </div>
    </div>
  );
}

function ColorRow({T,label,hex,alpha,onHex,onAlpha,showAlpha=false}){
  const eye=async cb=>{if('EyeDropper' in window){try{const r=await(new EyeDropper()).open();cb(r.sRGBHex);}catch{}}else alert('EyeDropper: Chrome only');};
  return(
    <div style={{marginBottom:8}}>
      {label&&<label style={mkLBL(T)}>{label}</label>}
      <div style={{display:'flex',alignItems:'center',gap:5}}>
        <input type="color" value={hex||'#000000'} onChange={e=>onHex(e.target.value)} style={{width:26,height:20,padding:0,border:`1px solid ${T.border}`,borderRadius:2,cursor:'pointer',flexShrink:0}}/>
        <TInp T={T} value={hex||'#000000'} onChange={e=>onHex(e.target.value)} style={{flex:1,fontSize:11,padding:'3px 6px'}}/>
        {'EyeDropper' in window&&<button onClick={()=>eye(onHex)} style={{background:T.bg,border:`1px solid ${T.border}`,color:T.muted,fontSize:11,padding:'2px 6px',cursor:'pointer',flexShrink:0}}>✦</button>}
        {showAlpha&&<><input type="range" min={0} max={1} step={0.01} value={alpha??1} onChange={e=>onAlpha(+e.target.value)} style={{width:48}}/><span style={{fontSize:9,color:T.muted,width:26,textAlign:'right'}}>{Math.round((alpha??1)*100)}%</span></>}
      </div>
    </div>
  );
}

// ━━━━━━━━ PANEL COMPONENTS (outside App) ━━━━━━━━
function MetaFieldsPanel({T,settings,setS}){
  const mfs=settings.metaFields||[];
  const upd=(idx,k,v)=>setS(s=>({...s,metaFields:mfs.map((f,i)=>i===idx?{...f,[k]:v}:f)}));
  const add=()=>setS(s=>({...s,metaFields:[...mfs,{id:mkUid(),label:'FIELD',value:'',show:true}]}));
  const del=idx=>setS(s=>({...s,metaFields:mfs.filter((_,i)=>i!==idx)}));
  const mv=(idx,dir)=>{const a=[...mfs];const to=idx+dir;if(to<0||to>=a.length)return;[a[idx],a[to]]=[a[to],a[idx]];setS(s=>({...s,metaFields:a}));};
  return(
    <div>
      <Tog T={T} label="Show meta row" value={settings.showMeta} onChange={v=>setS(s=>({...s,showMeta:v}))}/>
      {mfs.map((f,i)=>(
        <div key={f.id||i} style={{display:'flex',alignItems:'center',gap:4,marginBottom:5,padding:'4px 6px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
          <Tog T={T} label="" value={f.show} onChange={v=>upd(i,'show',v)}/>
          <TInp T={T} value={f.label} onChange={e=>upd(i,'label',e.target.value)} style={{width:52,fontSize:10,padding:'3px 5px',flex:'0 0 52px'}}/>
          <TInp T={T} value={f.value} onChange={e=>upd(i,'value',e.target.value)} style={{flex:1,fontSize:10,padding:'3px 5px'}}/>
          <button onClick={()=>mv(i,-1)} style={btnMini}>↑</button><button onClick={()=>mv(i,1)} style={btnMini}>↓</button>
          <button onClick={()=>del(i)} style={{...btnMini,color:'#f87171'}}>✕</button>
        </div>
      ))}
      <button onClick={add} style={{...mkBtn(T),width:'100%',marginTop:4,fontSize:9}}>+ Add Field</button>
    </div>
  );
}

function TextBlocksPanel({T,settings,setS}){
  const blocks=settings.textBlocks||[];
  const add=()=>setS(s=>({...s,textBlocks:[...blocks,{id:mkUid(),text:'TYPE HERE',x:12,y:200,size:14,bold:false,italic:false,align:'left',color:'#000000',opacity:1,font:settings.font,wrap:false,caps:false,w:200}]}));
  const upd=(id,k,v)=>setS(s=>({...s,textBlocks:blocks.map(b=>b.id===id?{...b,[k]:v}:b)}));
  const del=id=>setS(s=>({...s,textBlocks:blocks.filter(b=>b.id!==id)}));
  return(
    <div>
      <button onClick={add} style={{...mkBtn(T),width:'100%',marginBottom:8,fontSize:9}}>+ Add Text Block</button>
      {blocks.map((b,i)=>(
        <div key={b.id} style={{border:`1px solid ${T.border}`,marginBottom:8,padding:8,borderRadius:T.r||0}}>
          <div style={{display:'flex',justifyContent:'space-between',marginBottom:6}}>
            <span style={{fontSize:9,color:T.muted}}>BLOCK {i+1}</span>
            <button onClick={()=>del(b.id)} style={{...btnMini,color:'#f87171'}}>✕</button>
          </div>
          <F T={T} label="Text"><TTxt T={T} value={b.text} onChange={e=>upd(b.id,'text',e.target.value)} style={{minHeight:40}}/></F>
          <Row2><F T={T} label="X px"><TInp T={T} type="number" value={b.x} onChange={e=>upd(b.id,'x',+e.target.value)}/></F><F T={T} label="Y px"><TInp T={T} type="number" value={b.y} onChange={e=>upd(b.id,'y',+e.target.value)}/></F></Row2>
          <Row2><F T={T} label="Font Size"><TInp T={T} type="number" min={8} max={72} value={b.size} onChange={e=>upd(b.id,'size',+e.target.value)}/></F><F T={T} label="Width"><TInp T={T} type="number" min={20} value={b.w||200} onChange={e=>upd(b.id,'w',+e.target.value)}/></F></Row2>
          <F T={T} label="Font"><TSel T={T} value={b.font||settings.font} onChange={e=>upd(b.id,'font',e.target.value)}>{Object.entries(FONTS).map(([k,f])=><option key={k} value={k}>{f.name}</option>)}</TSel></F>
          <div style={{display:'flex',gap:8,flexWrap:'wrap',marginBottom:4}}>
            <div style={{display:'flex',alignItems:'center',gap:4}}><label style={{...mkLBL(T),marginBottom:0}}>Color</label><input type="color" value={b.color||'#000000'} onChange={e=>upd(b.id,'color',e.target.value)} style={{width:24,height:18,border:`1px solid ${T.border}`,padding:0,cursor:'pointer',borderRadius:2}}/></div>
            <F T={T} label="Align"><TSel T={T} value={b.align||'left'} onChange={e=>upd(b.id,'align',e.target.value)} style={{padding:'3px 5px'}}><option value="left">Left</option><option value="center">Center</option><option value="right">Right</option></TSel></F>
          </div>
          <div style={{display:'flex',gap:10,flexWrap:'wrap'}}><Tog T={T} label="Bold" value={b.bold} onChange={v=>upd(b.id,'bold',v)}/><Tog T={T} label="Italic" value={b.italic} onChange={v=>upd(b.id,'italic',v)}/><Tog T={T} label="Caps" value={b.caps} onChange={v=>upd(b.id,'caps',v)}/><Tog T={T} label="Wrap" value={b.wrap} onChange={v=>upd(b.id,'wrap',v)}/></div>
        </div>
      ))}
    </div>
  );
}

function DitherPanel({T,settings,setS}){
  const fileRef=useRef();
  const redither=useCallback(()=>{
    if(!settings.imageOriginalData)return;
    const img=new Image();img.onload=()=>{const d=atkinsonDither(img,settings.imageW,settings.imageH,settings.ditherThreshold,settings.ditherContrast);setS(s=>({...s,imageData:d}));};img.src=settings.imageOriginalData;
  },[settings.imageOriginalData,settings.imageW,settings.imageH,settings.ditherThreshold,settings.ditherContrast]);
  const load=file=>{
    if(!file||!file.type.startsWith('image/'))return;
    const r=new FileReader();r.onload=e=>{setS(s=>({...s,imageOriginalData:e.target.result,showImage:true}));const img=new Image();img.onload=()=>{const w=settings.imageW,h=Math.round(w/(img.width/img.height));setS(s=>({...s,imageH:h}));setS(s=>({...s,imageData:atkinsonDither(img,w,h,settings.ditherThreshold,settings.ditherContrast)}));};img.src=e.target.result;};r.readAsDataURL(file);
  };
  return(
    <div>
      <Tog T={T} label="Show image on label" value={settings.showImage} onChange={v=>setS(s=>({...s,showImage:v}))}/>
      <Tog T={T} label="Blend highlights to background" value={settings.ditherBlend} onChange={v=>setS(s=>({...s,ditherBlend:v}))}/>
      <input ref={fileRef} type="file" accept="image/*" style={{display:'none'}} onChange={e=>load(e.target.files[0])}/>
      <div style={{display:'flex',gap:6,marginBottom:8}}>
        <button onClick={()=>fileRef.current.click()} style={{...mkBtn(T),flex:1,fontSize:9}}>{settings.imageOriginalData?'↺ Replace':'+ Import Image'}</button>
        {settings.imageOriginalData&&<button onClick={redither} style={{...mkBtn(T),fontSize:9}}>Re-dither</button>}
      </div>
      {settings.imageOriginalData&&(
        <><F T={T} label={`Threshold: ${settings.ditherThreshold}`}><input type="range" min={50} max={220} value={settings.ditherThreshold} onChange={e=>setS(s=>({...s,ditherThreshold:+e.target.value}))} onMouseUp={redither} style={{width:'100%'}}/></F>
        <F T={T} label={`Contrast: ${settings.ditherContrast}`}><input type="range" min={-50} max={150} value={settings.ditherContrast} onChange={e=>setS(s=>({...s,ditherContrast:+e.target.value}))} onMouseUp={redither} style={{width:'100%'}}/></F>
        <Row2><F T={T} label="W px"><TInp T={T} type="number" min={40} value={settings.imageW} onChange={e=>setS(s=>({...s,imageW:+e.target.value}))}/></F><F T={T} label="H px"><TInp T={T} type="number" min={40} value={settings.imageH} onChange={e=>setS(s=>({...s,imageH:+e.target.value}))}/></F></Row2>
        <div style={{fontSize:8,color:T.muted,lineHeight:1.55,marginTop:2,padding:'5px 7px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
          <span style={{color:T.accent,marginRight:4}}>↖</span>Drag image on preview to position · drag <span style={{color:T.accent}}>■</span> corner to resize
        </div></>
      )}
    </div>
  );
}

function PresetPanel({T,settings,presets,lastId,onLoad,onSave,onDelete}){
  const [name,setName]=useState('');
  return(
    <div>
      <div style={{display:'flex',gap:6,marginBottom:10}}>
        <TInp T={T} placeholder="Preset name…" value={name} onChange={e=>setName(e.target.value)} style={{flex:1}}/>
        <button onClick={()=>{if(name.trim()){onSave(name.trim());setName('');}}} style={mkBtn(T,true)}>Save</button>
      </div>
      {presets.length===0&&<div style={{fontSize:10,color:T.muted,textAlign:'center',padding:'12px 0'}}>No presets yet</div>}
      {presets.map(p=>(
        <div key={p.id} style={{display:'flex',alignItems:'center',gap:5,marginBottom:5,padding:'6px 8px',background:T.bg,border:`1px solid ${p.id===lastId?T.accent:T.border}`,borderRadius:T.r||0}}>
          <span style={{flex:1,fontSize:10,color:p.id===lastId?T.accent:T.text,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{p.name}</span>
          <button onClick={()=>onLoad(p)} style={{...btnMini,color:T.text,fontSize:10}}>LOAD</button>
          <button onClick={()=>onDelete(p.id)} style={{...btnMini,color:'#f87171'}}>✕</button>
        </div>
      ))}
    </div>
  );
}

function ThemePopover({appTheme,setAppTheme,T,onClose,fsProps}){
  const at=appTheme,setA=(k,v)=>setAppTheme(a=>({...a,[k]:v}));
  const [savedThemes,setST]=useState(()=>loadLS('tl_saved_themes',[]));
  const [saveName,setSaveName]=useState('');
  const [resetHover,setResetHover]=useState(false);
  const saveST=n=>{if(!n.trim())return;const t={id:mkUid(),name:n.trim(),theme:{...at}};const ns=[...savedThemes,t];setST(ns);saveLS('tl_saved_themes',ns);setSaveName('');};
  const delST=id=>{const ns=savedThemes.filter(t=>t.id!==id);setST(ns);saveLS('tl_saved_themes',ns);};
  const doReset=()=>{
    if(window.confirm('Reset all appearance settings to defaults? Your saved themes will not be affected.')){
      setAppTheme(()=>({...DEFAULT_APP_THEME,themeKey:at.themeKey}));
    }
  };
  return(
    <div style={{position:'fixed',top:44,right:0,width:Math.max(300,Math.round((at.uiFontSize||100)*3)),maxHeight:'calc(100vh - 44px)',overflowY:'auto',background:T.panel,border:`1px solid ${T.border}`,borderRadius:`0 0 0 ${(T.r||0)*1.5}px`,zIndex:1000,padding:16,boxShadow:'0 8px 32px rgba(0,0,0,0.6)'}}>
      <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:14}}>
        <span style={{fontSize:9,letterSpacing:'0.2em',textTransform:'uppercase',color:T.muted}}>App Appearance</span>
        <button onClick={onClose} style={{background:'none',border:'none',color:T.muted,fontSize:14,cursor:'pointer'}}>✕</button>
      </div>
      <div style={{marginBottom:12}}>
        <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:4}}>
          <label style={{...mkLBL(T),marginBottom:0}}>Theme Preset</label>
          <button
            onClick={doReset}
            onMouseEnter={()=>setResetHover(true)}
            onMouseLeave={()=>setResetHover(false)}
            style={{fontSize:8,cursor:'pointer',letterSpacing:'0.1em',textTransform:'uppercase',
              padding:'2px 7px',borderRadius:T.r||0,border:'1px solid #f87171',
              background:resetHover?'#f87171':'transparent',
              color:resetHover?'#ffffff':'#f87171',
              transition:'background 0.12s, color 0.12s'}}>
            Reset
          </button>
        </div>
        <div style={{display:'flex',flexWrap:'wrap',gap:5}}>
          {Object.entries(APP_THEMES).map(([k,th])=>(
            <button key={k} onClick={()=>setA('themeKey',k)} style={{...mkBtn(T,at.themeKey===k),padding:'4px 9px',fontSize:9}}>{th.name}</button>
          ))}
          <button
            onClick={()=>{
              if(at.themeKey==='custom')return;
              // Seed all custom fields from the current live theme so it's readable immediately
              setAppTheme(a=>({...a,
                themeKey:'custom',
                customBg:T.bg,
                customPanel:T.panel,
                customBorder:T.border,
                customText:T.text,
                customBright:T.bright,
                customAccent:T.accent,
              }));
            }}
            style={{...mkBtn(T,at.themeKey==='custom'),padding:'4px 9px',fontSize:9}}
          >Custom</button>
        </div>
      </div>
      <div style={{marginBottom:12}}>
        <label style={mkLBL(T)}>Brightness — {at.brightness||100}%</label>
        <input type="range" min={40} max={150} value={at.brightness||100} onChange={e=>setA('brightness',+e.target.value)} style={{width:'100%'}}/>
      </div>
      <div style={{marginBottom:12}}>
        <label style={mkLBL(T)}>Corner Radius — {at.borderRadius||0}px</label>
        <input type="range" min={0} max={16} value={at.borderRadius||0} onChange={e=>setA('borderRadius',+e.target.value)} style={{width:'100%'}}/>
        <div style={{display:'flex',gap:4,marginTop:6}}>
          {[['Sharp',0],['Slight',3],['Soft',6],['Round',10],['Pill',16]].map(([lbl,val])=>(
            <button key={lbl} onClick={()=>setA('borderRadius',val)} style={{...mkBtn(T,(at.borderRadius||0)===val),padding:'3px 5px',fontSize:8,flex:1}}>{lbl}</button>
          ))}
        </div>
      </div>
      {at.themeKey==='custom'&&(
        <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginBottom:12}}>
          <label style={mkLBL(T)}>Custom Colors</label>
          {[['customBg','Background',T.bg],['customPanel','Panel',T.panel],['customBorder','Borders',T.border],['customText','Body Text',T.text],['customSub','UI Text',T.sub],['customBright','Heading Text',T.bright],['customAccent','Accent',T.accent]].map(([k,lbl,fallback])=>(
            <div key={k} style={{display:'flex',alignItems:'center',gap:8,marginBottom:6}}>
              <input type="color" value={at[k]||fallback} onChange={e=>setA(k,e.target.value)} style={{width:24,height:18,border:`1px solid ${T.border}`,padding:0,cursor:'pointer',borderRadius:2}}/>
              <span style={{fontSize:9,color:T.text,flex:1}}>{lbl}</span>
              <span style={{fontSize:9,color:T.muted,fontFamily:'monospace'}}>{at[k]||fallback}</span>
            </div>
          ))}
        </div>
      )}
      {at.themeKey!=='custom'&&(
        <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginBottom:12}}>
          <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:6}}>
            <label style={{...mkLBL(T),marginBottom:0}}>Color Overrides</label>
            <button
              onClick={()=>{
                if(!at.colorOverrides){
                  // Seed pickers from the CURRENT live theme so user starts from real values
                  setAppTheme(a=>({...a,
                    colorOverrides:true,
                    customBg:T.bg,
                    customAccent:T.accent,
                    customText:T.text,
                    customSub:T.sub,
                    customBright:T.bright,
                  }));
                }else{
                  setA('colorOverrides',false);
                }
              }}
              style={{...mkBtn(T,!!at.colorOverrides),padding:'3px 10px',fontSize:9}}
            >{at.colorOverrides?'On':'Off'}</button>
          </div>
          {at.colorOverrides?(
            <>
              <div style={{fontSize:8,color:T.muted,marginBottom:8,lineHeight:1.6}}>Overriding preset colors. Changes apply instantly.</div>
              {[['customBg','Background',T.bg],['customAccent','Accent',T.accent],['customText','Body Text',T.text],['customSub','UI Text (labels, titles, lists)',T.sub],['customBright','Heading Text',T.bright]].map(([k,lbl,fallback])=>(
                <div key={k} style={{display:'flex',alignItems:'center',gap:8,marginBottom:6}}>
                  <input type="color" value={at[k]||fallback} onChange={e=>setA(k,e.target.value)} style={{width:24,height:18,border:`1px solid ${T.border}`,padding:0,cursor:'pointer',borderRadius:2}}/>
                  <span style={{fontSize:9,color:T.text,flex:1}}>{lbl}</span>
                  <span style={{fontSize:9,color:T.muted,fontFamily:'monospace'}}>{at[k]||fallback}</span>
                </div>
              ))}
            </>
          ):(
            <div style={{fontSize:8,color:T.muted,lineHeight:1.6}}>Enable to override background, accent, body text, and UI text colors on top of any preset.</div>
          )}
        </div>
      )}
      <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginBottom:12}}>
        <label style={mkLBL(T)}>Player</label>
        <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:8}}>
          <span style={{fontSize:9,color:T.text}}>Auto-hide player</span>
          <button onClick={()=>setA('playerAutoHide',!at.playerAutoHide)} style={{...mkBtn(T,!!at.playerAutoHide),padding:'3px 10px',fontSize:9}}>{at.playerAutoHide?'On':'Off'}</button>
        </div>
        {at.playerAutoHide&&<div style={{fontSize:8,color:T.muted,marginBottom:8,lineHeight:1.6}}>Player slides off-screen. Hover the bottom edge to reveal it. Accent dots on the pull tab indicate playback.</div>}
        <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:6}}>
          <span style={{fontSize:9,color:T.text}}>Auto-save entry</span>
          <button onClick={()=>setA('playerAutoSave',!at.playerAutoSave)} style={{...mkBtn(T,!!at.playerAutoSave),padding:'3px 10px',fontSize:9}}>{at.playerAutoSave?'On':'Off'}</button>
        </div>
        {at.playerAutoSave&&(
          <div>
            <label style={mkLBL(T)}>Save interval</label>
            <div style={{display:'flex',gap:4}}>
              {[[30,'30s'],[60,'1m'],[120,'2m'],[300,'5m']].map(([s,lbl])=>(
                <button key={s} onClick={()=>setA('playerAutoSaveInterval',s)} style={{...mkBtn(T,(at.playerAutoSaveInterval||60)===s),padding:'3px 0',fontSize:9,flex:1}}>{lbl}</button>
              ))}
            </div>
          </div>
        )}
      </div>
      {/* ── SAVE LOCATION ── */}
      <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginBottom:12}}>
        <label style={mkLBL(T)}>Save Location</label>
        {!fsProps.supported?(
          <div style={{fontSize:8,color:T.muted,lineHeight:1.7,padding:'4px 0'}}>
            Auto-save to disk requires Chrome or Edge. Your browser doesn't support this. Use Archive → Export ZIP to save manually.
          </div>
        ):fsProps.folderName?(
          <>
            <div style={{display:'flex',alignItems:'center',gap:7,padding:'6px 9px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0,marginBottom:6}}>
              <span style={{fontSize:12}}>📁</span>
              <span style={{fontSize:9,color:T.bright,flex:1,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{fsProps.folderName}</span>
              {fsProps.diskSaving&&<span className="tl-spin" style={{fontSize:9,color:T.muted}}>↻</span>}
              {!fsProps.diskSaving&&fsProps.diskLastSaved&&<span style={{fontSize:8,color:'#3fb950'}}>✓</span>}
            </div>
            {fsProps.diskLastSaved&&<div style={{fontSize:7,color:T.muted,marginBottom:4}}>Last saved: {fsProps.diskLastSaved.toLocaleTimeString()}</div>}
            {fsProps.diskSaveError&&<div style={{fontSize:7,color:'#f87171',marginBottom:6,lineHeight:1.5}}>{fsProps.diskSaveError}</div>}
            <div style={{display:'flex',gap:5,marginBottom:8}}>
              <button onClick={fsProps.saveNow} disabled={fsProps.diskSaving} style={{...mkBtn(T,true),flex:1,padding:'5px 0',fontSize:9,opacity:fsProps.diskSaving?0.5:1}}>⬇ Save Now</button>
              <button onClick={fsProps.pickFolder} style={{...mkBtn(T),padding:'5px 10px',fontSize:9}}>Change…</button>
              <button onClick={fsProps.clearFolder} style={{...mkBtn(T),padding:'5px 10px',fontSize:9,color:'#f87171'}}>✕</button>
            </div>
            <label style={mkLBL(T)}>Auto-save interval</label>
            <div style={{display:'flex',gap:4}}>
              {[[60,'1m'],[120,'2m'],[300,'5m'],[600,'10m']].map(([s,lbl])=>(
                <button key={s} onClick={()=>setAppTheme(a=>({...a,diskSaveInterval:s}))} style={{...mkBtn(T,(appTheme.diskSaveInterval||120)===s),padding:'3px 0',fontSize:9,flex:1}}>{lbl}</button>
              ))}
            </div>
          </>
        ):(
          <>
            <div style={{fontSize:8,color:T.muted,lineHeight:1.7,marginBottom:8}}>
              Choose a folder on your computer. TrackLab will save your full library there — audio, artwork, and metadata — organized by profile and track. The catalog auto-saves every few minutes.
            </div>
            <button onClick={fsProps.pickFolder} style={{...mkBtn(T,true),width:'100%',padding:'8px 0',fontSize:9}}>📁 Choose Library Folder…</button>
          </>
        )}
      </div>
      {/* ── FONT SIZE ── */}
      {/* Scale mapping: internal value 115 = display "100%" (the comfortable default).
          All preset labels and the live readout are remapped: display% = round(internal * 100/115) */}
      <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginBottom:12}}>
        <label style={mkLBL(T)}>UI Scale — {Math.round((at.uiFontSize||115)*100/115)}%</label>
        <input type="range" min={75} max={200} step={5} value={at.uiFontSize||115} onChange={e=>setA('uiFontSize',+e.target.value)} style={{width:'100%',marginBottom:6}}/>
        <div style={{display:'flex',gap:4,flexWrap:'wrap'}}>
          {[[86,'75%'],[100,'87%'],[115,'100%'],[132,'115%'],[150,'130%'],[172,'150%'],[200,'174%']].map(([v,lbl])=>(
            <button key={v} onClick={()=>setA('uiFontSize',v)} style={{...mkBtn(T,(at.uiFontSize||115)===v),padding:'4px 0',fontSize:9,flex:1,minWidth:32}}>{lbl}</button>
          ))}
        </div>
        {(at.uiFontSize||115)>=172&&<div style={{fontSize:9,color:T.muted,marginTop:6,lineHeight:1.6}}>Large mode — some panels may need scrolling.</div>}
      </div>
      {/* ── UI FONT ── */}
      <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginBottom:12}}>
        <label style={mkLBL(T)}>UI Font</label>
        <div style={{display:'flex',flexWrap:'wrap',gap:4}}>
          {[
            ['share-tech','"Share Tech Mono"','Share Tech Mono'],
            ['ibm-plex','"IBM Plex Mono"','IBM Plex Mono'],
            ['space-mono','"Space Mono"','Space Mono'],
            ['barlow','"Barlow Condensed"','Barlow'],
            ['orbitron','Orbitron','Orbitron'],
            ['system','system-ui,sans-serif','System UI'],
          ].map(([k,css,lbl])=>{
            const active=(at.uiFontKey||'share-tech')===k;
            return(
              <button key={k} onClick={()=>setAppTheme(a=>({...a,uiFontKey:k,uiFontCss:css}))}
                style={{...mkBtn(T,active),padding:'4px 8px',fontSize:8,fontFamily:css}}>
                {lbl}
              </button>
            );
          })}
        </div>
      </div>
      <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12}}>
        <label style={mkLBL(T)}>Saved Themes</label>
        <div style={{display:'flex',gap:6,marginBottom:8}}>
          <input value={saveName} onChange={e=>setSaveName(e.target.value)} placeholder="Name this theme…" style={{...mkIS(T),flex:1,fontSize:11}}/>
          <button onClick={()=>saveST(saveName)} style={{...mkBtn(T,true),padding:'5px 10px',fontSize:9}}>Save</button>
        </div>
        {savedThemes.length===0&&<div style={{fontSize:9,color:T.muted,textAlign:'center',padding:'6px 0'}}>No saved themes</div>}
        {savedThemes.map(t=>(
          <div key={t.id} style={{display:'flex',alignItems:'center',gap:6,marginBottom:5,padding:'5px 8px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
            <span style={{flex:1,fontSize:10,color:T.text,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{t.name}</span>
            <button onClick={()=>setAppTheme(()=>({...t.theme}))} style={{...mkBtn(T),padding:'3px 8px',fontSize:9}}>Load</button>
            <button onClick={()=>delST(t.id)} style={{background:'none',border:'none',color:'#f87171',cursor:'pointer',fontSize:12}}>✕</button>
          </div>
        ))}
      </div>
      {/* ── TROUBLESHOOT ── */}
      <div style={{borderTop:`1px solid ${T.border}`,paddingTop:12,marginTop:4}}>
        <label style={mkLBL(T)}>Troubleshoot</label>
        <div style={{fontSize:8,color:T.muted,lineHeight:1.7,marginBottom:8}}>
          If themes are not applying correctly, clear the stored settings and reload. Your saved themes above will not be affected.
        </div>
        {/* Live colour swatch — if these match the UI, theme is working */}
        <div style={{display:'flex',gap:4,marginBottom:8}}>
          {[['bg',T.bg],['panel',T.panel],['accent',T.accent],['text',T.text],['border',T.border]].map(([k,v])=>(
            <div key={k} title={`${k}: ${v}`} style={{flex:1,height:14,background:v,border:'1px solid rgba(128,128,128,0.3)',borderRadius:2}}/>
          ))}
        </div>
        <button
          onClick={()=>{
            if(window.confirm('Clear stored appearance settings and reload? Your saved themes will be preserved.')){
              localStorage.removeItem('tl_apptheme');
              window.location.reload();
            }
          }}
          style={{...mkBtn(T),width:'100%',padding:'6px 0',fontSize:9,color:'#f87171',borderColor:'#f87171'}}
        >⟳ Clear Appearance Cache &amp; Reload</button>
      </div>
    </div>
  );
}

// EntryCard — archive list row
function EntryCard({T,entry,onOpen,onDelete,isActive,isPlaying,selectable,selected,onToggle,onPlayPause,onTabJump}){
  const st=STATUS_OPT[entry.status||'draft'];
  const handleClick=()=>selectable?onToggle?.(entry.id):onOpen(entry.id);

  const aBtnS={
    background:'none',border:`1px solid ${T.border}`,color:T.muted,
    fontFamily:'inherit',fontSize:8,letterSpacing:'0.1em',textTransform:'uppercase',
    cursor:'pointer',padding:'2px 6px',borderRadius:T.r||0,lineHeight:1.5,flexShrink:0,
  };

  return(
    <div
      onClick={handleClick}
      style={{
        background:isActive?T.panel:T.card,
        border:`1px solid ${selected?T.accent:isActive?T.accent:T.border}`,
        borderRadius:(T.r||0)*1.5,
        padding:'7px 10px',
        marginBottom:4,
        cursor:'pointer',
        display:'flex',
        alignItems:'center',
        gap:8,
      }}
    >
      {/* Checkbox (select mode) */}
      {selectable&&(
        <div style={{flexShrink:0,width:16,height:16,border:`1px solid ${selected?T.accent:T.border}`,borderRadius:2,background:selected?T.accent:'transparent',display:'flex',alignItems:'center',justifyContent:'center',color:selected?T.bg:T.muted,fontSize:10,lineHeight:1}}>
          {selected?'✓':''}
        </div>
      )}

      {/* ── Play button — bare triangle, no background ── */}
      {!selectable&&(
        <button
          onClick={e=>{e.stopPropagation();onPlayPause&&onPlayPause(entry);}}
          title={isPlaying?'Pause':'Play'}
          style={{
            flexShrink:0,width:18,height:18,
            background:'none',border:'none',
            color:isActive?T.accent:T.muted,
            fontSize:isPlaying?9:11,cursor:'pointer',
            display:'flex',alignItems:'center',justifyContent:'center',
            lineHeight:1,padding:0,
          }}
        >{isPlaying?'⏸':'▶'}</button>
      )}

      {/* ── Title / date / artist / badges ── */}
      <div style={{flex:1,minWidth:0}}>
        <div style={{display:'flex',alignItems:'baseline',gap:6,marginBottom:1}}>
          <span style={{fontSize:12,fontWeight:700,color:T.bright,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{entry.title||'Untitled'}</span>
          {(entry.created||entry.updated)&&<span style={{fontSize:7,color:T.muted,flexShrink:0,letterSpacing:'0.03em'}}>{fmtDate(entry.created||entry.updated)}</span>}
        </div>
        <div style={{display:'flex',gap:6,alignItems:'center',flexWrap:'wrap'}}>
          <span style={{fontSize:9,color:T.muted,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',maxWidth:110}}>{entry.artist||<span style={{opacity:0.4}}>No artist</span>}</span>
          {entry.classCode&&<span style={{fontFamily:'monospace',fontSize:9,color:T.accent,letterSpacing:'0.08em'}}>{entry.classCode}</span>}
          <span style={{fontSize:7,color:st.color,border:`1px solid ${st.color}44`,padding:'1px 4px',borderRadius:T.r||0,flexShrink:0}}>{st.label}</span>
          {entry.hasAudio&&<span style={{fontSize:8,color:T.muted}}>🎵</span>}
          {entry.hasArt&&<span style={{fontSize:8,color:T.muted}}>🖼</span>}
          {entry.analyzing&&<span style={{fontSize:7,color:T.accent,letterSpacing:'0.06em'}}><span className="tl-spin" style={{display:'inline-block'}}>⟳</span> reading…</span>}
        </div>
      </div>

      {/* ── Right action buttons ── */}
      {!selectable&&(
        <div style={{display:'flex',alignItems:'center',gap:3,flexShrink:0}} onClick={e=>e.stopPropagation()}>
          <button onClick={()=>onTabJump&&onTabJump(entry,'metadata')}  title="Edit Data"  style={aBtnS}>Data</button>
          <button onClick={()=>onTabJump&&onTabJump(entry,'classify')}  title="Classify"   style={aBtnS}>Class</button>
          <button onClick={()=>onTabJump&&onTabJump(entry,'label')}     title="Edit Label" style={aBtnS}>Label</button>
          <button onClick={e=>{e.stopPropagation();if(window.confirm(`Delete "${entry.title||'this entry'}"?`))onDelete(entry.id);}} title="Delete" style={{...btnMini,color:'#f87171',fontSize:13,marginLeft:2}}>✕</button>
        </div>
      )}
    </div>
  );
}
// ━━━━━━━━ PLAYER VIEW ━━━━━━━━
function PlayerView({T,audioElRef,audioObjectUrl,activeEntry,activeEid,meta,audioFile,entries,profiles,activePid,setActivePid,loadEntry,setAudioObjectUrl,setAudioFile,playerVisible}){
  const playerSidebar=useDragResize({key:'tl_w_player_sidebar',defaultW:200,min:120,max:360,label:'Library'});
  const canvasRef=useRef();
  const containerRef=useRef();
  const rafRef=useRef();
  const decodedRef=useRef(null);
  const [playing,setPlaying]=useState(false);
  const [currentTime,setCurrentTime]=useState(0);
  const [duration,setDuration]=useState(0);
  const [volume,setVolume]=useState(1);
  const [decoding,setDecoding]=useState(false);

  const fmt=s=>{if(!s||!isFinite(s))return'0:00';const m=Math.floor(s/60),sc=Math.floor(s%60);return`${m}:${sc.toString().padStart(2,'0')}`;};

  // Mirror audio element state
  useEffect(()=>{
    const el=audioElRef?.current;if(!el)return;
    const onTime=()=>setCurrentTime(el.currentTime);
    const onMeta=()=>setDuration(el.duration||0);
    const onPlay=()=>setPlaying(true);
    const onPause=()=>setPlaying(false);
    const onEnd=()=>setPlaying(false);
    el.addEventListener('timeupdate',onTime);el.addEventListener('loadedmetadata',onMeta);
    el.addEventListener('durationchange',onMeta);el.addEventListener('play',onPlay);
    el.addEventListener('pause',onPause);el.addEventListener('ended',onEnd);
    // Sync initial state
    setCurrentTime(el.currentTime||0);setDuration(el.duration||0);setPlaying(!el.paused);
    return()=>{el.removeEventListener('timeupdate',onTime);el.removeEventListener('loadedmetadata',onMeta);el.removeEventListener('durationchange',onMeta);el.removeEventListener('play',onPlay);el.removeEventListener('pause',onPause);el.removeEventListener('ended',onEnd);};
  },[audioElRef]);

  // Decode waveform whenever track changes — cache peaks in IDB to skip re-decode on repeat loads
  useEffect(()=>{
    decodedRef.current=null;
    if(!audioObjectUrl)return;
    let cancelled=false;
    setDecoding(true);
    (async()=>{
      try{
        // Try cached peaks first — avoids full WebAudio decode for already-seen tracks
        if(activeEid){
          const cached=await IDB.get(`peaks_${activeEid}`).catch(()=>null);
          if(cached&&!cancelled){decodedRef.current=new Float32Array(cached);setDecoding(false);return;}
        }
        const ac=new(window.AudioContext||window.webkitAudioContext)();
        const res=await fetch(audioObjectUrl);
        const buf=await res.arrayBuffer();
        const decoded=await ac.decodeAudioData(buf);
        if(!cancelled){
          const peaks=new Float32Array(decoded.getChannelData(0)); // own copy, channel 0
          decodedRef.current=peaks;
          // Cache asynchronously — fire-and-forget, don't block render
          if(activeEid)IDB.set(`peaks_${activeEid}`,peaks.buffer).catch(()=>{});
        }
        await ac.close();
      }catch(e){console.warn('PlayerView decode:',e);}
      finally{if(!cancelled)setDecoding(false);}
    })();
    return()=>{cancelled=true;};
  },[audioObjectUrl,activeEid]);

  // Canvas waveform draw loop
  const drawWave=useCallback(()=>{
    rafRef.current=requestAnimationFrame(drawWave);
    const canvas=canvasRef.current;if(!canvas)return;
    const W=canvas.width,H=canvas.height;if(!W||!H)return;
    const c=canvas.getContext('2d');
    c.clearRect(0,0,W,H);
    const accent=T.accent;
    const decoded=decodedRef.current;

    if(!decoded||!duration){
      // Empty state — just draw center line
      c.strokeStyle=T.border;c.lineWidth=1;
      c.beginPath();c.moveTo(0,H/2);c.lineTo(W,H/2);c.stroke();
      return;
    }

    const totalSamples=decoded.length;
    const samplesPerPixel=Math.max(1,Math.floor(totalSamples/W));

    // Draw full waveform as filled envelope
    c.beginPath();c.moveTo(0,H/2);
    for(let px=0;px<W;px++){
      const si=Math.floor((px/W)*totalSamples);
      let mx=0;
      for(let s=si;s<Math.min(si+samplesPerPixel,totalSamples);s++) mx=Math.max(mx,Math.abs(decoded[s]));
      c.lineTo(px,H/2-mx*(H/2-2));
    }
    for(let px=W-1;px>=0;px--){
      const si=Math.floor((px/W)*totalSamples);
      let mx=0;
      for(let s=si;s<Math.min(si+samplesPerPixel,totalSamples);s++) mx=Math.max(mx,Math.abs(decoded[s]));
      c.lineTo(px,H/2+mx*(H/2-2));
    }
    c.closePath();
    c.fillStyle=T.bright+'44';
    c.fill();

    // Played portion — filled with accent
    if(currentTime>0&&duration>0){
      const playedPx=Math.floor((currentTime/duration)*W);
      c.beginPath();c.moveTo(0,H/2);
      for(let px=0;px<Math.min(playedPx,W);px++){
        const si=Math.floor((px/W)*totalSamples);
        let mx=0;
        for(let s=si;s<Math.min(si+samplesPerPixel,totalSamples);s++) mx=Math.max(mx,Math.abs(decoded[s]));
        c.lineTo(px,H/2-mx*(H/2-2));
      }
      for(let px=Math.min(playedPx,W)-1;px>=0;px--){
        const si=Math.floor((px/W)*totalSamples);
        let mx=0;
        for(let s=si;s<Math.min(si+samplesPerPixel,totalSamples);s++) mx=Math.max(mx,Math.abs(decoded[s]));
        c.lineTo(px,H/2+mx*(H/2-2));
      }
      c.closePath();
      const grad=c.createLinearGradient(0,0,playedPx,0);
      grad.addColorStop(0,accent+'99');grad.addColorStop(1,accent);
      c.fillStyle=grad;c.fill();

      // Playhead line
      c.strokeStyle=accent;c.lineWidth=2;
      c.beginPath();c.moveTo(playedPx,0);c.lineTo(playedPx,H);c.stroke();
    }
  },[T,currentTime,duration]);

  useEffect(()=>{
    rafRef.current=requestAnimationFrame(drawWave);
    return()=>{if(rafRef.current){cancelAnimationFrame(rafRef.current);rafRef.current=null;}};
  },[drawWave]);

  // Resize canvas
  useEffect(()=>{
    const resize=()=>{const cv=canvasRef.current,p=containerRef.current;if(!cv||!p)return;cv.width=p.clientWidth;cv.height=p.clientHeight;};
    resize();const ro=new ResizeObserver(resize);if(containerRef.current)ro.observe(containerRef.current);
    return()=>ro.disconnect();
  },[]);

  const togglePlay=()=>{const el=audioElRef?.current;if(!el||!audioObjectUrl)return;playing?el.pause():el.play();};
  const seek=pct=>{const el=audioElRef?.current;if(!el||!duration)return;el.currentTime=pct*duration;};
  const seekByCanvas=e=>{const r=e.currentTarget.getBoundingClientRect();seek((e.clientX-r.left)/r.width);};
  const changeVol=v=>{const el=audioElRef?.current;if(!el)return;el.volume=v;setVolume(v);};
  const skip=sec=>{const el=audioElRef?.current;if(!el)return;el.currentTime=Math.max(0,Math.min(duration,el.currentTime+sec));};

  const thumb=activeEntry?.albumArtThumb||(meta?.albumArt&&!meta.albumArt.startsWith('[stored]')?meta.albumArt:null);
  const title=activeEntry?.title||meta?.title||audioFile?.name||'No track loaded';
  const artist=activeEntry?.artist||meta?.artist||'';
  const classCode=activeEntry?.classCode||'';
  const hasTrack=!!audioObjectUrl;

  // Group entries by profile for nav
  const profileEntries=useMemo(()=>profiles.map(p=>({
    ...p,tracks:entries.filter(e=>e.profileId===p.id).sort((a,b)=>(b.updated||'').localeCompare(a.updated||''))
  })),[profiles,entries]);

  return(
    <div style={{minHeight:'100%',display:'flex',overflow:'visible',background:T.bg}}>

      {/* ── LEFT NAV ── */}
      <div style={{width:playerSidebar.width,flexShrink:0,borderRight:playerSidebar.collapsed?'none':`1px solid ${T.border}`,display:'flex',flexDirection:'column',overflow:'hidden',background:T.panel,position:'relative',transition:'width 0.15s'}}>
        <div {...playerSidebar.handle}/>
        {playerSidebar.tab}
        <div style={{padding:'12px 12px 8px',borderBottom:`1px solid ${T.border}`,flexShrink:0}}>
          <div style={{fontSize:8,letterSpacing:'0.25em',textTransform:'uppercase',color:T.muted}}>Library</div>
        </div>
        <div style={{flex:1,overflowY:'auto',padding:'6px'}}>
          {profileEntries.length===0&&(
            <div style={{padding:'20px 8px',fontSize:9,color:T.muted,textAlign:'center',lineHeight:1.8}}>No profiles yet.<br/>Create one in Archive.</div>
          )}
          {profileEntries.map(p=>(
            <div key={p.id} style={{marginBottom:4}}>
              <div onClick={()=>setActivePid(p.id)} style={{padding:'7px 8px',cursor:'pointer',display:'flex',alignItems:'center',justifyContent:'space-between',borderRadius:T.r||0,background:activePid===p.id?T.card:'transparent'}}>
                <span style={{fontSize:10,fontWeight:700,color:activePid===p.id?T.accent:T.bright,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',flex:1}}>{p.name}</span>
                <span style={{fontSize:8,color:T.muted,flexShrink:0,marginLeft:4}}>{p.tracks.length}</span>
              </div>
              {activePid===p.id&&p.tracks.map(e=>(
                <div key={e.id} onClick={()=>loadEntry(e)} style={{padding:'5px 8px 5px 18px',cursor:'pointer',borderRadius:T.r||0,background:e.id===activeEid?T.bg:'transparent',marginBottom:1,display:'flex',alignItems:'center',gap:6}}>
                  {e.id===activeEid&&<div style={{width:4,height:4,borderRadius:'50%',background:T.accent,flexShrink:0}}/>}
                  <div style={{flex:1,minWidth:0}}>
                    <div style={{fontSize:9,color:e.id===activeEid?T.accent:T.sub,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{e.title||'Untitled'}</div>
                    {e.artist&&<div style={{fontSize:8,color:T.sub,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{e.artist}</div>}
                  </div>
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
      {playerSidebar.expandStub}

      {/* ── MAIN AREA ── */}
      <div style={{flex:1,display:'flex',flexDirection:'column',overflowY:'auto',minWidth:0}}>

        {/* Art + Info */}
        <div style={{flex:1,display:'flex',gap:0,minHeight:0}}>
          {/* Album art */}
          <div style={{flexShrink:0,width:'min(40%,320px)',display:'flex',alignItems:'center',justifyContent:'center',padding:24,background:T.bg}}>
            {thumb?(
              <div style={{width:'100%',maxWidth:260,aspectRatio:'1',borderRadius:(T.r||0)*2,overflow:'hidden',border:`1px solid ${T.border}`,boxShadow:'0 8px 40px rgba(0,0,0,0.4)'}}>
                <img src={thumb} style={{width:'100%',height:'100%',objectFit:'cover',display:'block'}} alt=""/>
              </div>
            ):(
              <div style={{width:'100%',maxWidth:260,aspectRatio:'1',borderRadius:(T.r||0)*2,border:`1px solid ${T.border}`,display:'flex',alignItems:'center',justifyContent:'center',background:T.panel}}>
                <div style={{fontSize:48,opacity:0.08}}>♫</div>
              </div>
            )}
          </div>

          {/* Track info */}
          <div style={{flex:1,display:'flex',flexDirection:'column',justifyContent:'center',padding:'24px 32px',minWidth:0,overflow:'hidden'}}>
            {hasTrack?(
              <>
                <div style={{fontSize:8,letterSpacing:'0.25em',textTransform:'uppercase',color:T.muted,marginBottom:12}}>Now Playing</div>
                <div style={{fontSize:26,fontWeight:700,color:T.bright,lineHeight:1.2,marginBottom:6,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{title}</div>
                {artist&&<div style={{fontSize:13,color:T.text,marginBottom:16,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{artist}</div>}
                {classCode&&(
                  <div style={{display:'flex',alignItems:'center',gap:8,marginBottom:16}}>
                    <span style={{fontFamily:'monospace',fontSize:16,color:T.accent,letterSpacing:'0.1em'}}>{classCode}</span>
                    <span style={{fontSize:9,color:T.muted}}>{activeEntry?.[Symbol.iterator]?'':(activeEntry?.classCode?`— ${activeEntry.metadata?.genre||''}`:'')}</span>
                  </div>
                )}
                <div style={{display:'flex',gap:16,flexWrap:'wrap'}}>
                  {activeEntry?.metadata?.genre&&<div><div style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',marginBottom:2}}>Genre</div><div style={{fontSize:10,color:T.text}}>{activeEntry.metadata.genre}</div></div>}
                  {activeEntry?.metadata?.bpm&&<div><div style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',marginBottom:2}}>BPM</div><div style={{fontSize:10,color:T.text}}>{activeEntry.metadata.bpm}</div></div>}
                  {activeEntry?.metadata?.key&&<div><div style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',marginBottom:2}}>Key</div><div style={{fontSize:10,color:T.text}}>{activeEntry.metadata.key}</div></div>}
                  {activeEntry?.metadata?.year&&<div><div style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',marginBottom:2}}>Year</div><div style={{fontSize:10,color:T.text}}>{activeEntry.metadata.year}</div></div>}
                  {duration>0&&<div><div style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',marginBottom:2}}>Length</div><div style={{fontSize:10,color:T.text}}>{fmt(duration)}</div></div>}
                </div>
              </>
            ):(
              <div style={{textAlign:'center',opacity:0.3}}>
                <div style={{fontSize:32,marginBottom:12}}>◈</div>
                <div style={{fontSize:10,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted}}>Select a track to play</div>
              </div>
            )}
          </div>
        </div>

        {/* ── WAVEFORM + CONTROLS ── */}
        <div style={{flexShrink:0,borderTop:`1px solid ${T.border}`,background:T.panel,padding:`0 0 ${playerVisible?72:16}px`}}>

          {/* Waveform canvas — click to seek */}
          <div ref={containerRef} style={{height:64,cursor:hasTrack?'pointer':'default',position:'relative'}} onClick={hasTrack?seekByCanvas:undefined}>
            <canvas ref={canvasRef} style={{display:'block',width:'100%',height:'100%'}}/>
            {decoding&&<div style={{position:'absolute',inset:0,display:'flex',alignItems:'center',justifyContent:'center'}}><span style={{fontSize:8,color:T.muted,letterSpacing:'0.15em'}}>DECODING…</span></div>}
          </div>

          {/* Time row */}
          <div style={{display:'flex',justifyContent:'space-between',padding:'2px 16px 10px',fontSize:8,color:T.muted,fontVariantNumeric:'tabular-nums'}}>
            <span>{fmt(currentTime)}</span>
            <span>{fmt(duration)}</span>
          </div>

          {/* Controls row */}
          <div style={{display:'flex',alignItems:'center',justifyContent:'center',gap:10,padding:'0 16px 4px'}}>
            {/* Restart / Back */}
            <button onClick={()=>{const el=audioElRef?.current;if(el)el.currentTime=0;}} disabled={!hasTrack} title="Restart" style={{background:'none',border:`1px solid ${hasTrack?T.border:'transparent'}`,color:hasTrack?T.text:T.muted,cursor:hasTrack?'pointer':'default',fontSize:11,padding:'5px 8px',borderRadius:T.r||0,fontFamily:'inherit',lineHeight:1}}>⏮</button>
            {/* Back 10s */}
            <button onClick={()=>skip(-10)} disabled={!hasTrack} title="Back 10s" style={{background:'none',border:`1px solid ${hasTrack?T.border:'transparent'}`,color:hasTrack?T.text:T.muted,cursor:hasTrack?'pointer':'default',fontSize:11,padding:'5px 8px',borderRadius:T.r||0,fontFamily:'inherit',lineHeight:1}}>−10s</button>
            {/* Stop */}
            <button onClick={()=>{const el=audioElRef?.current;if(!el)return;el.pause();el.currentTime=0;}} disabled={!hasTrack} title="Stop" style={{background:'none',border:`1px solid ${hasTrack?T.border:'transparent'}`,color:hasTrack?T.text:T.muted,cursor:hasTrack?'pointer':'default',fontSize:14,padding:'5px 9px',borderRadius:T.r||0,fontFamily:'inherit',lineHeight:1}}>⏹</button>
            {/* Play */}
            <button onClick={()=>{const el=audioElRef?.current;if(el&&audioObjectUrl)el.play();}} disabled={!hasTrack||playing} title="Play" style={{width:44,height:44,borderRadius:'50%',border:`1px solid ${hasTrack&&!playing?T.accent:T.border}`,background:hasTrack&&!playing?T.accent:'transparent',color:hasTrack&&!playing?T.bg:T.muted,fontSize:14,cursor:hasTrack&&!playing?'pointer':'default',display:'flex',alignItems:'center',justifyContent:'center',fontFamily:'inherit',flexShrink:0}}>▶</button>
            {/* Pause */}
            <button onClick={()=>{const el=audioElRef?.current;if(el)el.pause();}} disabled={!hasTrack||!playing} title="Pause" style={{width:44,height:44,borderRadius:'50%',border:`1px solid ${hasTrack&&playing?T.accent:T.border}`,background:hasTrack&&playing?T.accent:'transparent',color:hasTrack&&playing?T.bg:T.muted,fontSize:12,cursor:hasTrack&&playing?'pointer':'default',display:'flex',alignItems:'center',justifyContent:'center',fontFamily:'inherit',flexShrink:0}}>⏸</button>
            {/* Forward 10s */}
            <button onClick={()=>skip(10)} disabled={!hasTrack} title="Forward 10s" style={{background:'none',border:`1px solid ${hasTrack?T.border:'transparent'}`,color:hasTrack?T.text:T.muted,cursor:hasTrack?'pointer':'default',fontSize:11,padding:'5px 8px',borderRadius:T.r||0,fontFamily:'inherit',lineHeight:1}}>+10s</button>
            {/* Volume */}
            <div style={{display:'flex',alignItems:'center',gap:6,marginLeft:16}}>
              <span style={{fontSize:11,color:T.muted,cursor:'pointer'}} onClick={()=>changeVol(volume>0?0:1)}>{volume===0?'🔇':volume<0.5?'🔉':'🔊'}</span>
              <input type="range" min={0} max={1} step={0.02} value={volume} onChange={e=>changeVol(+e.target.value)} style={{width:72,accentColor:T.accent}}/>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
// ━━━━━━━━ DETAIL MINI PLAYER ━━━━━━━━
// v0.0.1: Removed private <audio> element. Now piggybacks on the shared
// audioElRef from App, eliminating the dual-audio conflict. Props:
//   audioElRef    — the single shared HTMLAudioElement ref from App
//   audioObjectUrl — the current blob URL loaded in the shared player
//   isCurrentEntry — true when this entry is the one in the shared player
//   onLoad        — called when user hits play but entry isn't loaded yet
function DetailMiniPlayer({T,entry,audioElRef,audioObjectUrl,isCurrentEntry,onLoad}){
  const [dp,setDp]=useState(false);
  const [dt,setDt]=useState(0);
  const [dd,setDd]=useState(0);
  // loaded = this entry is actually in the shared player right now
  const loaded=isCurrentEntry&&!!audioObjectUrl;
  const fmt=s=>{if(!s||!isFinite(s))return'0:00';const m=Math.floor(s/60),sc=Math.floor(s%60);return`${m}:${sc.toString().padStart(2,'0')}`;};

  // Mirror shared audio element events
  useEffect(()=>{
    const el=audioElRef?.current;if(!el)return;
    const onP=()=>setDp(true),onPs=()=>setDp(false),onE=()=>setDp(false);
    const onT=()=>setDt(el.currentTime);
    const onM=()=>setDd(el.duration||0);
    el.addEventListener('play',onP);el.addEventListener('pause',onPs);el.addEventListener('ended',onE);
    el.addEventListener('timeupdate',onT);el.addEventListener('loadedmetadata',onM);el.addEventListener('durationchange',onM);
    // Sync immediately in case audio is already playing
    setDp(!el.paused);setDt(el.currentTime||0);setDd(el.duration||0);
    return()=>{
      el.removeEventListener('play',onP);el.removeEventListener('pause',onPs);el.removeEventListener('ended',onE);
      el.removeEventListener('timeupdate',onT);el.removeEventListener('loadedmetadata',onM);el.removeEventListener('durationchange',onM);
    };
  },[audioElRef,isCurrentEntry]);

  // Reset display counters whenever this entry leaves the shared player
  useEffect(()=>{if(!loaded){setDp(false);setDt(0);setDd(0);}},[loaded]);

  const toggle=()=>{
    if(!loaded){onLoad?.();return;} // not loaded → ask parent to load it
    const el=audioElRef?.current;if(!el)return;
    dp?el.pause():el.play();
  };
  const seek=e=>{
    if(!loaded)return;
    const el=audioElRef?.current;if(!el||!dd)return;
    const r=e.currentTarget.getBoundingClientRect();
    el.currentTime=(e.clientX-r.left)/r.width*dd;
  };

  return(
    <div style={{background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0,padding:'7px 10px',display:'flex',flexDirection:'column',gap:6}}>
      {/* ── No private <audio> here — uses shared audioElRef from App ── */}
      {/* Controls row */}
      <div style={{display:'flex',alignItems:'center',gap:8}}>
        <button onClick={toggle}
          title={loaded?(dp?'Pause':'Play'):'Load track into player'}
          style={{flexShrink:0,width:26,height:26,borderRadius:'50%',
            border:`1px solid ${loaded?T.accent:T.border}`,
            background:loaded?T.accent:'transparent',
            color:loaded?T.bg:T.muted,
            fontSize:loaded?10:7,cursor:'pointer',
            display:'flex',alignItems:'center',justifyContent:'center',
            fontFamily:'inherit',lineHeight:1,padding:0,letterSpacing:'0.04em'}}>
          {loaded?(dp?'▮▮':'▶'):'↓'}
        </button>
        <span style={{fontSize:8,color:T.text,fontVariantNumeric:'tabular-nums',letterSpacing:'0.04em'}}>{fmt(dt)}</span>
        <div style={{flex:1}}/>
        <span style={{fontSize:8,color:T.muted,fontVariantNumeric:'tabular-nums',letterSpacing:'0.04em'}}>{fmt(dd)}</span>
      </div>
      {/* Seekable progress bar */}
      <div style={{width:'100%',height:18,display:'flex',alignItems:'center',cursor:loaded?'pointer':'default'}} onClick={seek}>
        <div style={{width:'100%',height:2,background:T.border,borderRadius:2,overflow:'hidden',position:'relative'}}>
          <div style={{position:'absolute',left:0,top:0,bottom:0,
            width:`${dd&&loaded?dt/dd*100:0}%`,
            background:T.accent,borderRadius:2,transition:'width 0.1s linear'}}/>
        </div>
      </div>
      {!loaded&&(
        <div style={{fontSize:7,color:T.muted,textAlign:'center',letterSpacing:'0.08em',textTransform:'uppercase'}}>
          ↓ Load track to preview
        </div>
      )}
    </div>
  );
}
// ━━━━━━━━ FLOATING PLAYER ━━━━━━━━
function FloatingPlayer({T,audioObjectUrl,audioFile,activeEntry,meta,autoHide,audioElRef}){
  const audioEl=audioElRef;
  const [playing,setPlaying]=useState(false);
  const [currentTime,setCurrentTime]=useState(0);
  const [duration,setDuration]=useState(0);
  const [volume,setVolume]=useState(1);
  const [minimized,setMinimized]=useState(false);
  const [revealed,setRevealed]=useState(false);
  const hideTimer=useRef(null);

  // Sync src when URL changes
  useEffect(()=>{
    const el=audioEl.current;if(!el)return;
    if(audioObjectUrl){el.src=audioObjectUrl;el.load();setCurrentTime(0);setDuration(0);setPlaying(false);}
    else{el.src='';setPlaying(false);}
  },[audioObjectUrl]);

  // Wire audio events
  useEffect(()=>{
    const el=audioEl.current;if(!el)return;
    const onTime=()=>setCurrentTime(el.currentTime);
    const onMeta=()=>setDuration(el.duration||0);
    const onEnd=()=>setPlaying(false);
    const onPlay=()=>setPlaying(true);
    const onPause=()=>setPlaying(false);
    el.addEventListener('timeupdate',onTime);
    el.addEventListener('loadedmetadata',onMeta);
    el.addEventListener('durationchange',onMeta);
    el.addEventListener('ended',onEnd);
    el.addEventListener('play',onPlay);
    el.addEventListener('pause',onPause);
    return()=>{el.removeEventListener('timeupdate',onTime);el.removeEventListener('loadedmetadata',onMeta);el.removeEventListener('durationchange',onMeta);el.removeEventListener('ended',onEnd);el.removeEventListener('play',onPlay);el.removeEventListener('pause',onPause);};
  },[]);

  // Auto-hide hover handlers
  const handleMouseEnter=()=>{
    if(!autoHide)return;
    clearTimeout(hideTimer.current);
    setRevealed(true);
  };
  const handleMouseLeave=()=>{
    if(!autoHide)return;
    hideTimer.current=setTimeout(()=>setRevealed(false),600);
  };

  // When autoHide is turned off, reset revealed state
  useEffect(()=>{if(!autoHide)setRevealed(false);},[autoHide]);

  const togglePlay=()=>{const el=audioEl.current;if(!el||!audioObjectUrl)return;playing?el.pause():el.play();};
  const seek=v=>{const el=audioEl.current;if(!el||!duration)return;el.currentTime=v;setCurrentTime(v);};
  const changeVol=v=>{const el=audioEl.current;if(!el)return;el.volume=v;setVolume(v);};
  const fmt=s=>{if(!s||!isFinite(s))return'0:00';const m=Math.floor(s/60),sec=Math.floor(s%60);return`${m}:${sec.toString().padStart(2,'0')}`;};

  const title=activeEntry?.title||meta?.title||audioFile?.name||'No track loaded';
  const artist=activeEntry?.artist||meta?.artist||'';
  const thumb=activeEntry?.albumArtThumb||(meta?.albumArt&&!meta.albumArt.startsWith('[stored]')?meta.albumArt:null);
  const hasTrack=!!audioObjectUrl;

  // Compute transform: autoHide takes precedence over manual minimized
  let translateY='translateY(0)';
  if(autoHide) translateY=revealed?'translateY(0)':'translateY(calc(100% - 4px))';
  else if(minimized) translateY='translateY(calc(100% - 6px))';

  // Pill slides up from bottom-center; collapses to a slim handle when minimized/auto-hidden
  let pillTranslateY='translateY(0)';
  if(autoHide) pillTranslateY=revealed?'translateY(0)':'translateY(calc(100% + 12px))';
  else if(minimized) pillTranslateY='translateY(calc(100% + 12px))';

  return(
    <div style={{position:'fixed',bottom:16,left:0,right:0,zIndex:500,display:'flex',justifyContent:'center',pointerEvents:'none'}}>
      {/* Hidden real audio element — lives outside pill so src persists through visibility changes */}
      <audio ref={audioEl} preload="metadata" style={{display:'none'}}/>

      {/* Minimized / auto-hide peek tab — always visible when pill is hidden */}
      {(minimized||(!revealed&&autoHide))&&(
        <div
          onMouseEnter={handleMouseEnter}
          onClick={()=>{if(!autoHide)setMinimized(false);}}
          style={{position:'fixed',bottom:0,left:'50%',transform:'translateX(-50%)',pointerEvents:'auto',cursor:'pointer',
            background:T.panel,border:`1px solid ${T.border}`,borderBottom:'none',
            borderRadius:T.r?`${T.r+3}px ${T.r+3}px 0 0`:'0',
            padding:'4px 18px 2px',display:'flex',alignItems:'center',gap:8}}>
          {playing&&<div style={{width:5,height:5,borderRadius:'50%',background:T.accent,animation:'tl-spin 1.2s linear infinite'}}/>}
          <div style={{fontSize:8,letterSpacing:'0.15em',textTransform:'uppercase',color:playing?T.accent:T.muted,maxWidth:160,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>
            {playing?title:'▶ Player'}
          </div>
          {playing&&<div style={{width:5,height:5,borderRadius:'50%',background:T.accent,animation:'tl-spin 1.2s linear infinite'}}/>}
        </div>
      )}

      {/* ── COMPACT PILL ── */}
      <div
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        style={{
          pointerEvents:'auto',
          width:'min(460px,calc(100vw - 32px))',
          background:T.panel,
          border:`1px solid ${T.border}`,
          borderRadius:T.r?T.r+20:0,
          boxShadow:'0 8px 32px rgba(0,0,0,0.6)',
          transition:'transform 0.3s cubic-bezier(0.4,0,0.2,1), opacity 0.25s ease',
          transform:pillTranslateY,
          opacity:(minimized||(autoHide&&!revealed))?0:1,
          overflow:'hidden',
        }}>

        {/* Top row: art + info + play + dismiss */}
        <div style={{display:'flex',alignItems:'center',gap:10,padding:'8px 12px 6px'}}>
          {/* Thumb */}
          <div style={{width:32,height:32,flexShrink:0,border:`1px solid ${T.border}`,borderRadius:T.r||0,overflow:'hidden',background:T.bg,display:'flex',alignItems:'center',justifyContent:'center'}}>
            {thumb?<img src={thumb} style={{width:'100%',height:'100%',objectFit:'cover'}} alt=""/>:<div style={{fontSize:12,opacity:0.2}}>♫</div>}
          </div>
          {/* Title + artist */}
          <div style={{flex:1,minWidth:0}}>
            <div style={{fontSize:10,fontWeight:700,color:hasTrack?T.bright:T.sub,whiteSpace:'nowrap',overflow:'hidden',textOverflow:'ellipsis',lineHeight:1.3}}>{title}</div>
            {artist&&<div style={{fontSize:8,color:T.muted,whiteSpace:'nowrap',overflow:'hidden',textOverflow:'ellipsis'}}>{artist}</div>}
          </div>
          {/* Play/Pause */}
          <button onClick={togglePlay} disabled={!hasTrack} style={{flexShrink:0,width:30,height:30,borderRadius:'50%',border:`1px solid ${hasTrack?T.accent:T.border}`,background:hasTrack?T.accent:'transparent',color:hasTrack?T.bg:T.muted,fontSize:11,cursor:hasTrack?'pointer':'default',display:'flex',alignItems:'center',justifyContent:'center',fontFamily:'inherit',lineHeight:1}}>
            {playing?'▮▮':'▶'}
          </button>
          {/* Collapse button */}
          <button onClick={()=>!autoHide&&setMinimized(true)} style={{flexShrink:0,background:'none',border:'none',color:T.muted,cursor:'pointer',fontSize:14,padding:'0 2px',lineHeight:1}} title="Minimise player">⌄</button>
        </div>

        {/* Progress row */}
        <div style={{display:'flex',alignItems:'center',gap:7,padding:'0 12px 8px'}}>
          <span style={{fontSize:7,color:T.muted,flexShrink:0,fontVariantNumeric:'tabular-nums',letterSpacing:'0.04em'}}>{fmt(currentTime)}</span>
          {/* Clickable progress bar */}
          <div style={{flex:1,height:20,display:'flex',alignItems:'center',cursor:hasTrack?'pointer':'default'}}
            onClick={e=>{if(!hasTrack||!duration)return;const r=e.currentTarget.getBoundingClientRect();seek((e.clientX-r.left)/r.width*duration);}}>
            <div style={{width:'100%',height:2,background:T.border,borderRadius:2,overflow:'hidden'}}>
              <div style={{width:`${duration?currentTime/duration*100:0}%`,height:'100%',background:T.accent,transition:'width 0.1s linear'}}/>
            </div>
          </div>
          <span style={{fontSize:7,color:T.muted,flexShrink:0,fontVariantNumeric:'tabular-nums',letterSpacing:'0.04em'}}>{fmt(duration)}</span>
          {/* Volume icon only (no slider — keeps pill tight) */}
          <span style={{fontSize:11,color:T.muted,cursor:'pointer',flexShrink:0,marginLeft:2}} onClick={()=>changeVol(volume>0?0:1)} title={volume===0?'Unmute':'Mute'}>
            {volume===0?'🔇':volume<0.5?'🔉':'🔊'}
          </span>
        </div>
      </div>
    </div>
  );
}
// ━━━━━━━━ LICENSE GATE [SCAFFOLD — v0.0.1] ━━━━━━━━
// Self-contained gate — no App state dependencies, no shared refs.
// This isolation makes it straightforward to obfuscate this block separately
// in a future build step.
//
// HOW TO ACTIVATE:
//   1. Change bypass=true → bypass=false in the <LicenseGate> call in App's return.
//   2. Replace VALID_KEY with a real value (or a hash comparison / server call).
//   3. Obfuscate only this block when shipping.
//
const LG_KEY='tl_lic_ok'; // localStorage key for unlock persistence
function LicenseGate({T,children,bypass=true}){
  if(bypass)return children; // dev/open mode — flip to false to enforce

  const [key,setKey]=useState('');
  const [err,setErr]=useState('');
  const [ok,setOk]=useState(()=>{
    try{return localStorage.getItem(LG_KEY)==='1';}catch{return false;}
  });

  const validate=()=>{
    // ── REPLACE with real validation (HMAC, server ping, etc.) ──
    const VALID_KEY='TRACK-LAB-DEMO-0000'; // placeholder
    if(key.trim().toUpperCase()===VALID_KEY){
      try{localStorage.setItem(LG_KEY,'1');}catch{}
      setOk(true);
    }else{
      setErr('Invalid key. Please check and try again.');
    }
  };

  if(ok)return children;

  return(
    <div style={{height:'100vh',display:'flex',alignItems:'center',justifyContent:'center',
      background:T.bg,flexDirection:'column',gap:16,padding:24}}>
      <div style={{fontSize:9,letterSpacing:'0.4em',textTransform:'uppercase',color:T.muted,marginBottom:4}}>
        Track Lab — Licensed Software
      </div>
      <div style={{fontSize:28,fontWeight:700,color:T.accent,letterSpacing:'0.08em'}}>
        TRACK LAB
      </div>
      <div style={{fontSize:10,color:T.text,marginBottom:8}}>Enter your license key to continue.</div>
      <input
        value={key}
        onChange={e=>{setKey(e.target.value);setErr('');}}
        onKeyDown={e=>e.key==='Enter'&&validate()}
        placeholder="XXXX-XXXX-XXXX-XXXX"
        autoFocus spellCheck={false}
        style={{
          background:T.panel,
          border:`1px solid ${err?'#f87171':T.border}`,
          color:T.bright,fontFamily:'monospace',fontSize:13,
          padding:'10px 18px',borderRadius:T.r||0,
          letterSpacing:'0.18em',textAlign:'center',width:300,outline:'none',
          transition:'border-color 0.2s',
        }}
      />
      {err&&<div style={{fontSize:8,color:'#f87171',letterSpacing:'0.06em'}}>{err}</div>}
      <button
        onClick={validate}
        style={{background:T.accent,border:'none',color:T.bg,fontFamily:'inherit',
          fontWeight:700,fontSize:9,letterSpacing:'0.2em',textTransform:'uppercase',
          padding:'11px 32px',cursor:'pointer',borderRadius:T.r||0,marginTop:4}}>
        UNLOCK
      </button>
      <div style={{fontSize:7,color:T.muted,marginTop:8,letterSpacing:'0.06em'}}>
        v{VERSION} · Key is stored locally after first unlock.
      </div>
    </div>
  );
}

// ━━━━━━━━ BATCH EXPORT HELPER ━━━━━━━━
// Renders one TrackLabel to a PNG Blob using html2canvas.
// Fully self-contained — mounts a hidden DOM node, captures it, then cleans up.
// Returns a Blob on success, throws on failure. Never touches React state.
const renderLabelToBlob=async(fields,labelSettings,scale=2)=>{
  const wrap=document.createElement('div');
  wrap.style.cssText=`position:fixed;left:-99999px;top:0;width:${labelSettings.labelW}px;overflow:visible;pointer-events:none;z-index:-1;`;
  document.body.appendChild(wrap);
  const el=document.createElement('div');
  wrap.appendChild(el);
  try{
    await new Promise(res=>ReactDOM.render(React.createElement(TrackLabel,{fields,settings:labelSettings}),el,res));
    await new Promise(r=>setTimeout(r,80)); // fonts + QR code must settle
    const sc=getColors(labelSettings);
    const canvas=await html2canvas(el.firstChild||el,{
      scale,width:labelSettings.labelW,height:labelSettings.labelH,
      useCORS:true,allowTaint:true,backgroundColor:sc.bg||'#fff',logging:false,
    });
    return await new Promise((res,rej)=>canvas.toBlob(b=>b?res(b):rej(new Error('toBlob returned null')),'image/png'));
  }finally{
    ReactDOM.unmountComponentAtNode(el);
    document.body.removeChild(wrap);
  }
};

// ━━━━━━━━ APP COMPONENT ━━━━━━━━
// ━━━━━━━━ ANALYSIS PANEL ━━━━━━━━
// ── AI / Digital Artifact Score helpers ──────────────────────────────────────
// Extracts raw numeric % from the stored aiProbability string.
// e.g. "⚠ Elevated (55%)" → 55    "✓ Low (0%)" → 0    "" → null
function parseAiProbability(val){
  if(!val) return null;
  var m=val.match(/\((\d+)%\)/);
  return m?parseInt(m[1],10):null;
}
// Returns the Origin Estimate tier object for a given numeric score.
// Deliberately avoids "AI" as a verdict — frames as signal quality indicator.
function getOriginTier(score){
  if(score===null) return null;
  if(score<20) return{label:'Human / Analogue',sublabel:'No significant digital artifacts detected',color:'#3fb950',borderColor:'rgba(63,185,80,0.35)',bg:'rgba(63,185,80,0.07)',icon:'\u2713'};
  if(score<50) return{label:'Inconclusive',sublabel:'Minor artifacts present \u2014 may be lossy encoding',color:'#7ca8c8',borderColor:'rgba(124,168,200,0.35)',bg:'rgba(124,168,200,0.07)',icon:'\u25c6'};
  if(score<70) return{label:'Digital Artifacts Present',sublabel:'Consistent with lossy codecs, heavy processing or AI tools',color:'#d29922',borderColor:'rgba(210,153,34,0.35)',bg:'rgba(210,153,34,0.07)',icon:'\u25c6'};
  return{label:'High Artifact Score',sublabel:'Multiple artifact signals detected \u2014 see breakdown below',color:'#f97316',borderColor:'rgba(249,115,22,0.35)',bg:'rgba(249,115,22,0.08)',icon:'\u26a0'};
}
// ── Origin Estimate Badge — score bar, tier label, sub-metric breakdown, disclaimer
function OriginEstimateBadge(props){
  var T=props.T;
  var meta=props.meta;
  var analyzing=props.analyzing;

  var score=parseAiProbability(meta.aiProbability);
  var tier=getOriginTier(score);
  var hasScore=score!==null&&!analyzing;

  if(!hasScore){
    return(
      <div style={{marginBottom:16,padding:'12px 14px',background:T.card,border:'1px solid '+T.border,borderRadius:T.r||0}}>
        <div style={{fontSize:8,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted,marginBottom:6}}>Digital Artifact Score</div>
        <div style={{fontSize:11,color:T.muted,fontStyle:'italic'}}>{analyzing?'Analyzing\u2026':'Upload an audio file to run the artifact scan'}</div>
      </div>
    );
  }

  var barWidth=Math.min(99,Math.max(0,score))+'%';
  var hasAiArtifact=!!(meta.aiArtifact);
  var hasStereo=!!(meta.stereoCorrelation);
  var artifactIsWarn=hasAiArtifact&&meta.aiArtifact.charAt(0)==='\u26a0';
  var artifactIsOk=hasAiArtifact&&meta.aiArtifact.charAt(0)==='\u2713';
  var stereoIsStatic=hasStereo&&meta.stereoCorrelation.indexOf('Static')!==-1;
  var stereoIsBlurred=hasStereo&&meta.stereoCorrelation.indexOf('Blurred')!==-1;
  var stereoIsNatural=hasStereo&&meta.stereoCorrelation.indexOf('Natural')!==-1;
  var stereoColor=stereoIsStatic?'#f85149':(stereoIsBlurred?'#d29922':(stereoIsNatural?'#3fb950':T.muted));
  var artifactColor=artifactIsWarn?'#f97316':(artifactIsOk?'#3fb950':T.muted);

  return(
    <div style={{marginBottom:16,border:'1px solid '+tier.borderColor,borderRadius:T.r||0,overflow:'hidden',background:tier.bg}}>
      <div style={{padding:'10px 14px 8px',borderBottom:'1px solid '+tier.borderColor}}>
        <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:2}}>
          <div style={{display:'flex',alignItems:'center',gap:7}}>
            <span style={{fontSize:14,color:tier.color,lineHeight:1}}>{tier.icon}</span>
            <span style={{fontSize:11,fontWeight:700,color:tier.color,letterSpacing:'0.04em',textTransform:'uppercase'}}>{tier.label}</span>
          </div>
          <span style={{fontSize:16,fontWeight:700,color:tier.color,fontFamily:'monospace',letterSpacing:'0.06em'}}>{score}%</span>
        </div>
        <div style={{fontSize:9,color:T.muted,letterSpacing:'0.02em',paddingLeft:21}}>{tier.sublabel}</div>
      </div>
      <div style={{padding:'10px 14px 8px'}}>
        <div style={{fontSize:7,letterSpacing:'0.12em',color:T.muted,textTransform:'uppercase',marginBottom:5}}>Digital Artifact Score</div>
        <div style={{position:'relative',height:6,background:T.bg,borderRadius:3,overflow:'hidden',marginBottom:4}}>
          <div style={{position:'absolute',left:0,top:0,height:'100%',width:barWidth,background:tier.color,borderRadius:3}}/>
          <div style={{position:'absolute',top:0,left:'20%',width:1,height:'100%',background:T.border,opacity:0.7}}/>
          <div style={{position:'absolute',top:0,left:'50%',width:1,height:'100%',background:T.border,opacity:0.7}}/>
          <div style={{position:'absolute',top:0,left:'70%',width:1,height:'100%',background:T.border,opacity:0.7}}/>
        </div>
        <div style={{display:'flex',justifyContent:'space-between',marginBottom:10}}>
          <span style={{fontSize:7,color:T.muted,fontFamily:'monospace'}}>0 Clean</span>
          <span style={{fontSize:7,color:T.muted,fontFamily:'monospace'}}>20 Low</span>
          <span style={{fontSize:7,color:T.muted,fontFamily:'monospace'}}>50 Moderate</span>
          <span style={{fontSize:7,color:T.muted,fontFamily:'monospace'}}>70 Elevated</span>
          <span style={{fontSize:7,color:T.muted,fontFamily:'monospace'}}>99</span>
        </div>
        {(hasAiArtifact||hasStereo)&&(
          <div style={{display:'flex',flexDirection:'column',gap:4,marginBottom:10}}>
            {hasAiArtifact&&(
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',padding:'4px 8px',background:T.bg,borderRadius:T.r||0,border:'1px solid '+T.border}}>
                <span style={{fontSize:8,color:T.muted,letterSpacing:'0.08em',textTransform:'uppercase'}}>Neural / Spectral</span>
                <span style={{fontSize:9,fontFamily:'monospace',color:artifactColor}}>{meta.aiArtifact}</span>
              </div>
            )}
            {hasStereo&&(
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',padding:'4px 8px',background:T.bg,borderRadius:T.r||0,border:'1px solid '+T.border}}>
                <span style={{fontSize:8,color:T.muted,letterSpacing:'0.08em',textTransform:'uppercase'}}>Stereo Field</span>
                <span style={{fontSize:9,fontFamily:'monospace',color:stereoColor}}>{meta.stereoCorrelation}</span>
              </div>
            )}
          </div>
        )}
      </div>
      <div style={{padding:'8px 14px 10px',borderTop:'1px solid '+tier.borderColor,background:'rgba(0,0,0,0.15)'}}>
        <div style={{fontSize:8,color:T.muted,lineHeight:1.7,letterSpacing:'0.01em'}}>
          <span style={{color:T.text,fontWeight:600}}>Note: </span>
          This is a <span style={{color:T.text}}>Digital Artifact Score</span>, not an AI detector. Low-quality MP3s (128kbps and below), heavily noise-reduced recordings, vinyl transfers, and files processed through lossy codecs produce <span style={{fontStyle:'italic'}}>identical signals</span> to AI-generated audio. A high score flags anomalies \u2014 it does not identify origin. Always verify with context before drawing conclusions.
        </div>
      </div>
    </div>
  );
}
function getMetricColor(key,val){
  var n=parseFloat(val);
  if(key==='lufs') return n>=-14?'#3fb950':n>=-18?'#d29922':'#f85149';
  if(key==='samplePeak') return n>=-1?'#f85149':n>=-3?'#d29922':'#3fb950';
  if(key==='crestFactor') return n<6?'#f85149':n<8?'#d29922':'#3fb950';
  if(key==='dcOffset') return n>=0.5?'#f85149':n>=0.1?'#d29922':'#3fb950';
  return '#7ca8c8';
}
function getMetricStatus(key,val){
  var n=parseFloat(val);
  if(key==='lufs') return n>=-14?'streaming-loud':n>=-18?'broadcast range':'quiet master';
  if(key==='lra') return n<4?'compressed':n<8?'moderate':n<15?'dynamic':'very dynamic';
  if(key==='samplePeak') return n>=-1?'at ceiling':n>=-3?'hot':n>=-6?'normal':'conservative';
  if(key==='crestFactor') return n<6?'over-compressed':n<8?'limited':n<14?'natural':'uncompressed';
  if(key==='dcOffset') return n>=0.5?'filter required':n>=0.1?'low DC present':'clean';
  return '';
}
function getMetricWarn(key,val){
  var n=parseFloat(val);
  if(key==='lufs'){
    if(n>-6) return {level:'red',msg:'Extremely loud — will be turned down heavily on all platforms'};
    if(n>-14) return {level:'amber',msg:'Above streaming targets — platforms will apply gain reduction'};
    if(n<-23) return {level:'amber',msg:'Very quiet — may feel low on streaming platforms'};
  }
  if(key==='lra'){
    if(n<3) return {level:'amber',msg:'Very compressed — dynamics are heavily limited'};
    if(n>20) return {level:'amber',msg:'Highly dynamic — check loudness consistency'};
  }
  if(key==='samplePeak'){
    if(n>0) return {level:'red',msg:'Clipping — samples exceed 0 dBFS'};
    if(n>=-1) return {level:'red',msg:'At 0 dBFS ceiling — encode overshoot will cause clipping'};
    if(n>=-3) return {level:'amber',msg:'Very hot — leave 1-2 dB headroom for encode safety'};
  }
  if(key==='crestFactor'){
    if(n<4) return {level:'red',msg:'Severely over-compressed — transients are completely crushed'};
    if(n<6) return {level:'amber',msg:'Heavy limiting detected — little dynamic headroom remains'};
  }
  if(key==='dcOffset'){
    if(n>=0.5) return {level:'red',msg:'High DC offset — apply DC filter in your DAW before mastering'};
    if(n>=0.1) return {level:'amber',msg:'Measurable DC offset — worth filtering if heading to vinyl'};
  }
  return null;
}
var AM_KEYS=[
  {key:'lufs',      label:'INTEGRATED LUFS',  desc:'K-weighted integrated loudness (EBU R128 / ITU-R BS.1770-4). Two-pass gated — silence excluded.',  targets:'Spotify -14 / Apple -16 / YouTube -14 / Tidal -14'},
  {key:'lra',       label:'LOUDNESS RANGE',   desc:'Dynamic spread loud-to-quiet in Loudness Units (EBU Tech 3342). Higher = more dynamic.',             targets:'Typical 6-15 LU / Heavy limiting below 4 LU / Classical above 15 LU'},
  {key:'samplePeak',label:'SAMPLE PEAK',      desc:'Highest absolute sample value. Above -1 dBFS risks clipping after MP3/AAC encode overshoot.',        targets:'Safe headroom -2 dBFS / True peak limit -1 dBTP'},
  {key:'crestFactor',label:'CREST FACTOR',    desc:'Peak-to-RMS ratio. Low values mean heavily compressed transients.',                                   targets:'Limited below 6 dB / Mastered 8-14 dB / Acoustic above 18 dB'},
  {key:'dcOffset',  label:'DC OFFSET',        desc:'Mean signal displacement. Causes clicks at edit points and wastes headroom.',                        targets:'Transparent below 0.1% / Acceptable below 0.5% / Problematic at or above 0.5%'},
];
// ── Badge card sub-component — hover tooltip included ────────────────────────
function MetricBadge(props){
  var T=props.T;
  var key=props.metricKey;
  var label=props.label;
  var val=props.val;
  var desc=props.desc;
  var targets=props.targets;
  var analyzing=props.analyzing;
  var w=getMetricWarn(key,val);
  var col=getMetricColor(key,val);
  var borderCol='';
  var bg='';
  if(w){
    borderCol=(w.level==='red')?'#f85149':'#d29922';
    bg=(w.level==='red')?'rgba(248,81,73,0.06)':'rgba(210,153,34,0.06)';
  } else if(val){
    borderCol='#3fb950';
    bg=T.card;
  } else {
    borderCol=T.border;
    bg=T.card;
  }
  var pipColor=(w&&w.level==='red')?'#f85149':'#d29922';
  var statusText=getMetricStatus(key,val);
  return(
    <div className="tl-metric-wrap">
      {/* Hover tooltip — pure CSS opacity transition, no JS needed */}
      <div className="tl-metric-tooltip">
        <div style={{fontSize:10,fontWeight:700,color:'#cccccc',letterSpacing:'0.1em',textTransform:'uppercase',marginBottom:6,fontFamily:"'Barlow Condensed',sans-serif"}}>{label}</div>
        {val&&<div style={{fontSize:13,fontWeight:700,color:col,fontFamily:'monospace',marginBottom:6}}>{val}</div>}
        <div style={{fontSize:11,color:'#aaaaaa',lineHeight:1.65,marginBottom:6}}>{desc}</div>
        <div style={{fontSize:10,color:'#888888',letterSpacing:'0.02em',borderTop:'1px solid #333',paddingTop:6}}>{targets}</div>
      </div>
      {/* Badge face */}
      <div style={{background:'#e8eaed',border:'1px solid '+borderCol,borderRadius:T.r||0,padding:'10px 12px',position:'relative',height:'100%',cursor:'default'}}>
        {(w)&&(
          <div style={{position:'absolute',top:8,right:8,width:7,height:7,borderRadius:'50%',background:pipColor}}/>
        )}
        <div style={{fontSize:8,letterSpacing:'0.16em',textTransform:'uppercase',color:'#555555',marginBottom:5,fontWeight:600,whiteSpace:'nowrap',overflow:'hidden',textOverflow:'ellipsis'}}>{label}</div>
        {(analyzing)&&(
          <div style={{fontSize:18,fontWeight:700,color:'#999999',fontFamily:'monospace',fontStyle:'italic'}}>—</div>
        )}
        {(!analyzing&&val)&&(
          <div>
            <div style={{fontSize:20,fontWeight:700,color:col,fontFamily:'monospace',lineHeight:1}}>{val}</div>
            <div style={{fontSize:9,color:'#666666',marginTop:5,letterSpacing:'0.06em'}}>{statusText}</div>
          </div>
        )}
        {(!analyzing&&!val)&&(
          <div style={{fontSize:13,color:'#999999',fontStyle:'italic'}}>—</div>
        )}
      </div>
    </div>
  );
}
// ── Warning row sub-component ─────────────────────────────────────────────────
function WarnRow(props){
  var T=props.T;
  var label=props.label;
  var level=props.level;
  var msg=props.msg;
  var color=(level==='red')?'#f85149':'#d29922';
  var icon=(level==='red')?'✕':'◆';
  return(
    <div style={{display:'flex',gap:12,alignItems:'flex-start',padding:'10px 14px',borderTop:'1px solid #cccccc'}}>
      <span style={{fontSize:12,color:color,flexShrink:0,marginTop:1}}>{icon}</span>
      <div>
        <div style={{fontSize:11,color:color,fontWeight:700,marginBottom:4,letterSpacing:'0.04em'}}>{label}</div>
        <div style={{fontSize:11,color:'#333333',lineHeight:1.6}}>{msg}</div>
      </div>
    </div>
  );
}
// ── Reference card sub-component ─────────────────────────────────────────────
function RefCard(props){
  var T=props.T;
  var label=props.label;
  var val=props.val;
  var desc=props.desc;
  var targets=props.targets;
  var col=getMetricColor(props.metricKey,val);
  return(
    <div style={{padding:'10px 14px',background:'#e8eaed',border:'1px solid '+T.border,borderRadius:T.r||0}}>
      <div style={{display:'flex',justifyContent:'space-between',alignItems:'baseline',marginBottom:6}}>
        <span style={{fontSize:10,fontWeight:700,color:'#555555',letterSpacing:'0.1em',textTransform:'uppercase'}}>{label}</span>
        <span style={{fontSize:13,fontWeight:700,color:col,fontFamily:'monospace'}}>{val||'—'}</span>
      </div>
      <div style={{fontSize:11,color:'#333333',lineHeight:1.7,marginBottom:5}}>{desc}</div>
      <div style={{fontSize:10,color:'#555555',letterSpacing:'0.02em'}}>{targets}</div>
    </div>
  );
}
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// LOUDNESS GRAPH — Reference scale with genre benchmarks
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function LoudnessGraph({ currentLufs, currentLra, currentPeak, containerWidth, section, activeGenre, setActiveGenre, targetGenre, setTargetGenre, T }) {
  // section: 'scale' | 'dynamics' | 'health' | 'legend'
  // activeGenre and targetGenre are lifted to AnalysisPanel so shared state works across section renders

  // ── Static data — no arrow functions ────────────────────────────────────────
  var GENRE_MAP = [
    { id: 'ambient',    label: 'Ambient',          lufs: -20, lra: 15, color: '#58a6ff',
      insight: 'Ambient music preserves wide dynamic range and quiet headroom — the journey from silence to sound IS the music. High LRA reflects natural, breathing dynamics rather than compressed density.' },
    { id: 'classical',  label: 'Classical',         lufs: -18, lra: 16, color: '#7c9ebf',
      insight: 'Classical masters preserve the full dynamic arc of a performance — from a single violin pianissimo to a full orchestra fortissimo. Wide LRA is a feature, not a flaw. Streaming normalization actually benefits these masters.' },
    { id: 'jazz',       label: 'Jazz',              lufs: -17, lra: 12, color: '#8ec4c4',
      insight: 'Jazz lives in the dynamic interplay between players. A wide LRA captures the breath of a horn, the ghost notes of a brush, the space between phrases. Over-compression destroys the very thing that makes it swing.' },
    { id: 'lofi',       label: 'Lo-Fi / Bedroom',  lufs: -16, lra: 9,  color: '#a08cc8',
      insight: 'Lo-Fi exists in the comfort zone — quiet enough to study to, warm enough to feel. Gentle limiting preserves the intimacy and crackle that defines the genre. Streaming normalization means going louder gains nothing.' },
    { id: 'streaming',  label: 'Streaming',         lufs: -14, lra: 10, color: '#3fb950',
      insight: 'Streaming platforms normalize to around −14 LUFS. Masters louder than this get turned DOWN, wasting effort. Masters quieter get turned up, potentially revealing noise. This is the sweet spot for modern delivery.' },
    { id: 'hiphop',     label: 'Hip-Hop / Trap',    lufs: -10, lra: 6,  color: '#c7a030',
      insight: 'Hip-hop and trap rely on pounding sub-bass and punchy 808s that need consistent punch across earbuds, car speakers, and Bluetooth. Moderate limiting keeps the kicks hard without destroying the mix. At −10, streaming platforms will apply minor gain reduction.' },
    { id: 'country',    label: 'Country / Americana', lufs: -12, lra: 8, color: '#c47c3c',
      insight: 'Country production balances organic dynamics — the snap of a snare, the bloom of a steel guitar — with the commercial loudness expected on country radio and streaming playlists. A wider LRA than rock preserves the storytelling dynamics of the genre.' },
    { id: 'rnb',        label: 'R&B / Soul',        lufs: -11, lra: 7,  color: '#b05888',
      insight: 'R&B and soul rely on the emotional weight of a vocal and a groove that locks in. Moderate compression gives the genre its polished, controlled feel without squashing the dynamics that carry the emotional performance.' },
    { id: 'rockpop',    label: 'Rock / Pop',         lufs: -9,  lra: 7,  color: '#d29922',
      insight: 'Rock and pop rely on perceived loudness for energy and impact. Tight dynamic range keeps the track punchy across earbuds, car stereos, and club PA — but at this level, streaming will reduce the volume.' },
    { id: 'club',       label: 'Club / EDM',          lufs: -6,  lra: 4,  color: '#f85149',
      insight: 'Club music needs maximum density to compete on high-SPL sound systems. Minimal LRA means the kick and bass stay consistent at 120dB. This sounds crushed on headphones but translates powerfully on big systems.' }
  ];

  // ── Platform normalization targets ───────────────────────────────────────────
  // Each platform normalizes to a specific LUFS target during playback.
  // Masters above the target are turned DOWN; below are turned UP (or left).
  var PLATFORM_MARKS = [
    { id: 'apple',   label: 'Apple',   lufs: -16, color: '#b8b8b8', note: 'Apple Music / iTunes normalizes to −16 LUFS. Quieter masters get a slight boost; louder masters are turned down, losing no quality.' },
    { id: 'spotify', label: 'Spotify', lufs: -14, color: '#1db954', note: 'Spotify normalizes to −14 LUFS (normal loudness). Loud masters get turned down on Normal setting; on Loud, the target shifts to −11 LUFS.' },
    { id: 'youtube', label: 'YouTube', lufs: -14, color: '#ff4444', note: 'YouTube normalizes to −14 LUFS. Content louder than −14 gets turned down; quieter content is left as-is (no gain-up on YouTube).' },
    { id: 'tiktok',  label: 'TikTok',  lufs: -14, color: '#69c9d0', note: 'TikTok targets approximately −14 LUFS for audio normalization. Consistent loudness matters especially for viral sound clips.' },
    { id: 'amazon',  label: 'Amazon',  lufs: -14, color: '#00a8e0', note: 'Amazon Music normalizes to −14 LUFS. Matches Spotify and YouTube targets — masters at −14 translate cleanly without gain reduction.' },
    { id: 'tidal',   label: 'Tidal',   lufs: -14, color: '#008aff', note: 'Tidal normalizes to −14 LUFS on standard quality. HiFi subscribers may hear the master more closely — headroom and peak safety matter more.' }
  ];

  var SCALE_MIN = -24;
  var SCALE_MAX = -3;
  var SCALE_RANGE = SCALE_MAX - SCALE_MIN; // 21

  function toPercent(db) {
    return ((db - SCALE_MIN) / SCALE_RANGE) * 100;
  }

  function getLufsZoneColor(v) {
    if (v >= -9) return '#f85149';
    if (v >= -14) return '#d29922';
    if (v >= -18) return '#3fb950';
    return '#58a6ff';
  }

  function getLraDynamics(lra) {
    var halfWidthPct = Math.min(lra * 2, 44);
    var opacity, r, g, b, label, desc;
    if (lra >= 12) {
      opacity = 0.22; r = 88;  g = 166; b = 255;
      label = 'Breathing'; desc = 'Wide dynamic range — natural, open, expressive.';
    } else if (lra >= 8) {
      opacity = 0.38; r = 63;  g = 185; b = 80;
      label = 'Dynamic'; desc = 'Healthy dynamics — punchy but not crushed.';
    } else if (lra >= 5) {
      opacity = 0.55; r = 210; g = 153; b = 34;
      label = 'Moderate'; desc = 'Moderate compression — some dynamics lost.';
    } else {
      opacity = 0.82; r = 248; g = 81;  b = 73;
      label = 'Compressed'; desc = 'Heavy limiting — the sausage. Minimal dynamic contrast.';
    }
    var colorSolid = 'rgb(' + r + ',' + g + ',' + b + ')';
    var colorFill  = 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
    return { halfWidthPct: halfWidthPct, colorSolid: colorSolid, colorFill: colorFill, label: label, desc: desc };
  }

  // ── Pre-compute all values — nothing computed inside JSX ────────────────────
  var hasLufs = currentLufs !== undefined && currentLufs !== null && currentLufs !== '' && !isNaN(parseFloat(currentLufs));
  var lufsVal  = hasLufs ? parseFloat(currentLufs) : null;
  var clampedLufs = hasLufs ? Math.max(SCALE_MIN, Math.min(SCALE_MAX, lufsVal)) : null;
  var lufsPos  = hasLufs ? toPercent(clampedLufs) : 0;

  var hasLra  = currentLra !== undefined && currentLra !== null && currentLra !== '' && !isNaN(parseFloat(currentLra));
  var lraVal  = hasLra ? Math.max(0, parseFloat(currentLra)) : null;
  var lraDyn  = (hasLra && lraVal !== null) ? getLraDynamics(lraVal) : null;
  var hasBoth = hasLufs && lraDyn !== null;

  // ── Peak Safety Valve ────────────────────────────────────────────────────────
  var hasPeak      = currentPeak !== undefined && currentPeak !== null && currentPeak !== '' && !isNaN(parseFloat(currentPeak));
  var peakVal      = hasPeak ? parseFloat(currentPeak) : null;
  var peakBreached = hasPeak && peakVal > -0.1;   // true peak above −0.1 dBFS = danger
  var peakDotClass = peakBreached ? 'tl-peak-blink' : '';
  var peakDotColor = !hasPeak ? T.border : peakBreached ? '#f85149' : '#3fb950';
  var peakDotTitle = !hasPeak ? 'No peak data' : peakBreached ? 'TRUE PEAK: ' + peakVal + ' dBFS — above −0.1 dBFS ceiling. Encode overshoot will cause clipping.' : 'TRUE PEAK: ' + peakVal + ' dBFS — safe headroom';
  var peakLabelText = hasPeak ? (peakVal > 0 ? 'CLIP' : peakVal + ' dB') : 'PEAK';
  var peakLabelColor = peakBreached ? '#f85149' : T.muted;

  // ── Platform normalization bar — above the scale ─────────────────────────────
  // Pre-compute positions and build element arrays for all platform marks
  // Grouped by unique LUFS values to stack labels without overlap
  var platformTickEls = [];
  var platformLabelEls = [];

  // Track which LUFS positions have already been used so we can stack labels vertically
  var platformLabelOffsets = {};  // key: lufs value string, value: count of labels placed

  for (var pi = 0; pi < PLATFORM_MARKS.length; pi++) {
    var pm = PLATFORM_MARKS[pi];
    var pmPos = toPercent(pm.lufs);
    var pmLeft = pmPos + '%';
    var pmKey = String(pm.lufs);
    var pmStackCount = platformLabelOffsets[pmKey] || 0;
    var pmTopOffset  = pmStackCount * 14;   // stack labels 14px apart if same LUFS
    platformLabelOffsets[pmKey] = pmStackCount + 1;

    var pmLabelLeft = 'calc(' + pmPos + '% - 1px)';

    platformTickEls.push(
      <div
        key={pm.id}
        title={pm.note}
        style={{
          position: 'absolute', left: pmLeft,
          top: 0, width: 2, height: '100%',
          background: pm.color,
          opacity: 0.85,
          cursor: 'help',
          zIndex: 3
        }}
      />
    );

    platformLabelEls.push(
      <div
        key={pm.id}
        title={pm.note}
        style={{
          position: 'absolute', left: pmLabelLeft,
          top: pmTopOffset,
          transform: 'translateX(-50%)',
          fontSize: 9,
          color: pm.color,
          fontFamily: "'Share Tech Mono', monospace",
          fontWeight: 700,
          whiteSpace: 'nowrap',
          lineHeight: 1,
          cursor: 'help',
          letterSpacing: '0.02em'
        }}
      >
        {pm.label}
      </div>
    );
  }

  // Height needed for platform label area (based on max stack depth)
  var maxPlatformStack = 0;
  for (var pmk in platformLabelOffsets) {
    if (platformLabelOffsets[pmk] > maxPlatformStack) maxPlatformStack = platformLabelOffsets[pmk];
  }
  var platformLabelAreaH = maxPlatformStack * 14 + 4;
  var platformLabelAreaHpx = platformLabelAreaH + 'px';

  // Legacy spotifyLeft kept for backwards compatibility with existing JSX refs — points to −14
  var spotifyPos       = toPercent(-14);
  var spotifyLeft      = spotifyPos + '%';
  var spotifyLabelLeft = 'calc(' + spotifyPos + '% - 1px)';

  // ── Scale gradient ────────────────────────────────────────────────────────────
  // Maps the −24 to −3 dB range to a perceptually meaningful color ramp:
  //  −24  deep blue    (quiet / ambient space)
  //  −18  teal-blue    (dynamic / broadcast lower boundary)
  //  −14  bright green (streaming sweet spot — Spotify target)
  //  −11  yellow-green (getting loud)
  //   −9  amber        (rock/pop territory, platforms will normalize down)
  //   −6  orange-red   (club / EDM — aggressive limiting)
  //   −3  hard red     (danger zone, right edge)
  // Each stop is computed as a % of the 21 dB range
  var gradStop = function(db, hex) { return hex + ' ' + toPercent(db).toFixed(1) + '%'; };
  var scaleGradient = 'linear-gradient(to right, '
    + gradStop(-24, '#0d2a4a') + ', '
    + gradStop(-18, '#0d4a3a') + ', '
    + gradStop(-14, '#1a5e2a') + ', '
    + gradStop(-11, '#4a6a10') + ', '
    + gradStop(-9,  '#6a4a08') + ', '
    + gradStop(-6,  '#7a2208') + ', '
    + gradStop(-3,  '#8a0808') + ')';

  // Pre-computed positions for user marker on main scale
  var markerLeft     = lufsPos + '%';
  var markerWrapLeft = 'calc(' + lufsPos + '% - 5px)';

  // Pre-computed dynamic width bar positions
  var dynHalfW        = hasBoth ? lraDyn.halfWidthPct : 0;
  var dynBarLeft      = 'calc(' + lufsPos + '% - ' + dynHalfW + '%)';
  var dynBarWidth     = (dynHalfW * 2) + '%';
  var dynEdgeLeftPos  = 'calc(' + lufsPos + '% - ' + dynHalfW + '% - 1px)';
  var dynEdgeRightPos = 'calc(' + lufsPos + '% + ' + dynHalfW + '%)';
  var dynDiamondLeft  = 'calc(' + lufsPos + '% - 4px)';

  // Pre-computed range label strings
  var rangeMin = hasBoth ? (lufsVal - lraVal / 2).toFixed(1) : '';
  var rangeMax = hasBoth ? (lufsVal + lraVal / 2).toFixed(1) : '';
  var rangeLabelLeft  = '← ' + rangeMin;
  var rangeLabelRight = rangeMax + ' →';

  // Pre-computed lra callout string (avoids inline expression in JSX)
  var lraCalloutText = hasLra && lraVal > 0 ? ' · LRA ' + lraVal + ' LU' : '';
  var dynHeaderText  = hasBoth ? lraDyn.label + ' · LRA ' + lraVal + ' LU' : '';

  // Convenience
  var borderRadius = T.r || 0;

  // Pre-compute activeInsight — no arrow function
  var activeInsight = null;
  for (var i = 0; i < GENRE_MAP.length; i++) {
    if (GENRE_MAP[i].id === activeGenre) { activeInsight = GENRE_MAP[i]; break; }
  }
  var legendMarginBottom = activeInsight ? 8 : 0;

  // ── Target genre lookup — no arrow function ─────────────────────────────────
  var targetData = null;
  for (var ti2 = 0; ti2 < GENRE_MAP.length; ti2++) {
    if (GENRE_MAP[ti2].id === targetGenre) { targetData = GENRE_MAP[ti2]; break; }
  }

  // ── T-themed color aliases ───────────────────────────────────────────────────
  // T.accent = user-defined highlight = the "Your Master" marker color
  // T.bright = primary heading/value text
  // T.muted  = secondary labels
  // T.panel  = card/badge backgrounds
  // T.border = structural borders
  // T.text   = body text
  var userMarkerColor  = T.accent;              // live marker = theme accent
  var userMarkerShadow = '0 0 6px ' + T.accent;
  var userMarkerGlow   = '0 0 4px ' + T.accent;

  // ── Mastering Health Score (1–100) ──────────────────────────────────────────
  // Formula: two weighted dimensions — LUFS proximity (60%) + LRA proximity (40%)
  // Each dimension: 100 at perfect match, drops linearly toward 0 at ±12 dB/LU tolerance.
  var healthScore   = null;
  var healthLabel   = '';
  var healthColor   = T.muted;
  var healthDesc    = '';
  var healthBarW    = '0%';
  var healthLufsScore  = 0;
  var healthLraScore   = 0;

  if (hasBoth && targetData) {
    // LUFS score: tolerance window ±8 LUFS from target centre
    var lufsDiff  = Math.abs(lufsVal - targetData.lufs);
    var lufsScore = Math.max(0, Math.round((1 - lufsDiff / 8) * 100));

    // LRA score: tolerance window ±8 LU from target centre
    var lraDiff  = Math.abs(lraVal - targetData.lra);
    var lraScore = Math.max(0, Math.round((1 - lraDiff / 8) * 100));

    // Weighted composite
    var raw = Math.round(lufsScore * 0.60 + lraScore * 0.40);
    healthScore = Math.max(1, Math.min(100, raw));

    healthLufsScore = Math.min(100, lufsScore);
    healthLraScore  = Math.min(100, lraScore);

    // Grade thresholds
    if (healthScore >= 85) {
      healthLabel = 'Excellent';
      healthColor = '#3fb950';
      healthDesc  = 'Master sits well within the target zone for ' + targetData.label + '.';
    } else if (healthScore >= 65) {
      healthLabel = 'Good';
      healthColor = '#58a6ff';
      healthDesc  = 'Broadly in range — minor adjustments could bring it closer to the ' + targetData.label + ' target.';
    } else if (healthScore >= 40) {
      healthLabel = 'Fair';
      healthColor = '#d29922';
      healthDesc  = 'Some distance from the ' + targetData.label + ' ideal. Consider revisiting compression or limiting.';
    } else {
      healthLabel = 'Off-Target';
      healthColor = '#f85149';
      healthDesc  = 'Master diverges significantly from the ' + targetData.label + ' benchmark. Both LUFS and LRA may need attention.';
    }

    healthBarW = healthScore + '%';
  }

  // ── Mastering Health sub-score label strings ─────────────────────────────────
  var healthLufsStr = hasBoth && targetData ? healthLufsScore + '%' : '—';
  var healthLraStr  = hasBoth && targetData ? healthLraScore  + '%' : '—';
  var healthScoreStr = healthScore !== null ? healthScore + '%' : '—';

  // Target genre dropdown option strings — built before return()
  var targetSelectEls = [];
  for (var tsi = 0; tsi < GENRE_MAP.length; tsi++) {
    var tsg = GENRE_MAP[tsi];
    targetSelectEls.push(
      <option key={tsg.id} value={tsg.id}>{tsg.label}</option>
    );
  }

  // ── Pre-build JSX arrays before return() ────────────────────────────────────

  // 1. Genre notch markers on main scale bar
  var genreNotchEls = [];
  for (var ni = 0; ni < GENRE_MAP.length; ni++) {
    var ng   = GENRE_MAP[ni];
    var nPos = toPercent(ng.lufs) + '%';
    var nIsActive = activeGenre === ng.id;
    var nOpacity  = nIsActive ? 1 : 0.65;
    var nId = ng.id; // capture for closure
    genreNotchEls.push(
      <div
        key={ng.id}
        onClick={function(gid) { return function() { setActiveGenre(activeGenre === gid ? null : gid); }; }(nId)}
        title={ng.label + ': ' + ng.lufs + ' LUFS'}
        style={{
          position: 'absolute', left: nPos, top: -1,
          width: 2, height: 16,
          background: ng.color, opacity: nOpacity,
          cursor: 'pointer', transition: 'opacity 0.15s', zIndex: 2
        }}
      />
    );
  }

  // 2. dB scale tick labels
  var DB_TICKS = [-24, -21, -18, -15, -12, -9, -6, -3];
  var dbTickEls = [];
  for (var ti = 0; ti < DB_TICKS.length; ti++) {
    var tdb  = DB_TICKS[ti];
    var tPos = toPercent(tdb) + '%';
    dbTickEls.push(
      <div key={tdb} style={{
        position: 'absolute', left: tPos,
        transform: 'translateX(-50%)',
        fontSize: 10, color: T.muted,
        fontFamily: "'Share Tech Mono', monospace",
        letterSpacing: 0, lineHeight: 1
      }}>
        {tdb}
      </div>
    );
  }

  // 3. Genre name labels — collision-aware 2-row layout
  // Each label has an approximate pixel width. We assign row 0 first, then push colliders to row 1.
  // Approximate px per character at fontSize 9px, Barlow Condensed: ~5.5px/char
  var CHAR_W = 5.5;
  var HALF_PAD = 6; // half of minimum gap between labels (px)

  // Scale bar total rendered width: use live measured containerWidth prop when available.
  // 56px = 2 × 28px horizontal padding inside the analysis content wrapper.
  // Falls back to 520 on first render before measurement completes.
  var SCALE_BAR_W_PX = (containerWidth && containerWidth > 100) ? (containerWidth - 56) : 520;

  // Compute label half-widths in % of scale bar
  var labelHalfWidths = [];
  for (var lhw = 0; lhw < GENRE_MAP.length; lhw++) {
    var charCount = GENRE_MAP[lhw].label.length;
    var halfPx = (charCount * CHAR_W / 2) + HALF_PAD;
    labelHalfWidths.push(halfPx / SCALE_BAR_W_PX * 100);
  }

  // Assign rows: greedily try row 0 first, fall back to row 1 if it collides with any row-0 label
  var labelRows = [];
  var row0Occupancy = []; // array of {left, right} in % for row-0 placed labels
  for (var lri = 0; lri < GENRE_MAP.length; lri++) {
    var lrPos   = toPercent(GENRE_MAP[lri].lufs);
    var lrLeft  = lrPos - labelHalfWidths[lri];
    var lrRight = lrPos + labelHalfWidths[lri];
    var collides = false;
    for (var ci = 0; ci < row0Occupancy.length; ci++) {
      var occ = row0Occupancy[ci];
      if (lrLeft < occ.right && lrRight > occ.left) { collides = true; break; }
    }
    if (!collides) {
      labelRows.push(0);
      row0Occupancy.push({ left: lrLeft, right: lrRight });
    } else {
      labelRows.push(1);
    }
  }

  var genreLabelEls = [];
  for (var li = 0; li < GENRE_MAP.length; li++) {
    var lg        = GENRE_MAP[li];
    var lPos      = toPercent(lg.lufs) + '%';
    var lIsActive = activeGenre === lg.id;
    var lColor    = lIsActive ? lg.color : T.sub;
    var lWeight   = lIsActive ? 700 : 500;
    var lDecor    = lIsActive ? 'underline' : 'none';
    var lId       = lg.id;
    var lTop      = labelRows[li] === 0 ? 0 : 15;
    genreLabelEls.push(
      <div
        key={lg.id}
        onClick={function(gid) { return function() { setActiveGenre(activeGenre === gid ? null : gid); }; }(lId)}
        style={{
          position: 'absolute', left: lPos, top: lTop,
          transform: 'translateX(-50%)',
          fontSize: 9, color: lColor,
          fontFamily: "'Barlow Condensed', sans-serif",
          fontWeight: lWeight, letterSpacing: '0.04em',
          textTransform: 'uppercase', cursor: 'pointer',
          whiteSpace: 'nowrap', lineHeight: 1,
          transition: 'color 0.15s', textDecoration: lDecor
        }}
      >
        {lg.label}
      </div>
    );
  }

  // 4. Ghost grid reference lines inside dynamics bar
  var LRA_REFS = [4, 8, 12, 16];
  var dynGridEls = [];
  for (var gi = 0; gi < LRA_REFS.length; gi++) {
    var refLra   = LRA_REFS[gi];
    var refHalfW = Math.min(refLra * 2, 44);
    var refLeftL = 'calc(' + lufsPos + '% - ' + refHalfW + '%)';
    var refLeftR = 'calc(' + lufsPos + '% + ' + refHalfW + '%)';
    dynGridEls.push(
      <React.Fragment key={refLra}>
        <div style={{ position: 'absolute', left: refLeftL, top: 0, width: 1, height: '100%', background: T.border, opacity: 0.4 }} />
        <div style={{ position: 'absolute', left: refLeftR, top: 0, width: 1, height: '100%', background: T.border, opacity: 0.4 }} />
      </React.Fragment>
    );
  }

  // 5. Genre legend row + click
  var genreLegendEls = [];
  for (var gi2 = 0; gi2 < GENRE_MAP.length; gi2++) {
    var gg      = GENRE_MAP[gi2];
    var gIsActive = activeGenre === gg.id;
    var gOpacity  = (activeGenre && !gIsActive) ? 0.4 : 1;
    var gTextCol  = gIsActive ? gg.color : T.sub;
    var gFontW    = gIsActive ? 700 : 400;
    var gId2 = gg.id;
    genreLegendEls.push(
      <div
        key={gg.id}
        onClick={function(gid) { return function() { setActiveGenre(activeGenre === gid ? null : gid); }; }(gId2)}
        style={{ display: 'flex', alignItems: 'center', gap: 5, cursor: 'pointer', opacity: gOpacity, transition: 'opacity 0.15s' }}
      >
        <div style={{ width: 9, height: 9, background: gg.color, borderRadius: 1, flexShrink: 0 }} />
        <span style={{ fontSize: 10, color: gTextCol, fontFamily: "'Barlow Condensed', sans-serif", fontWeight: gFontW, letterSpacing: '0.06em', textTransform: 'uppercase' }}>
          {gg.label} · {gg.lufs} LUFS
        </span>
      </div>
    );
  }

  // ── Section: SCALE ────────────────────────────────────────────────────────────
  var scaleSection = (
    <div style={{ marginBottom: 8 }}>
      {/* Platform bar above scale */}
      <div style={{ position: 'relative', marginBottom: 4 }}>
        <div style={{
          position: 'relative', height: 8, background: T.panel,
          border: '1px solid ' + T.border, borderRadius: 2, overflow: 'visible', marginBottom: 4
        }}>
          {platformTickEls}
        </div>
        <div style={{ position: 'relative', height: platformLabelAreaHpx }}>
          {platformLabelEls}
        </div>
      </div>

      {/* Scale container */}
      <div style={{ position: 'relative', paddingBottom: 36, paddingTop: 4 }}>
        <div style={{
          position: 'relative', height: 16, borderRadius: 2,
          background: scaleGradient, border: '1px solid ' + T.border, overflow: 'visible'
        }}>
          {genreNotchEls}
          {/* Peak Safety Dot */}
          <div className={peakDotClass} title={peakDotTitle} style={{
            position: 'absolute', right: -8, top: -8, width: 11, height: 11,
            borderRadius: '50%', background: peakDotColor, border: '1px solid ' + T.border,
            zIndex: 12, cursor: 'default', boxShadow: peakBreached ? '0 0 6px #f85149' : 'none'
          }} />
          {/* User LUFS marker */}
          {hasLufs && (
            <div style={{ position: 'absolute', left: markerWrapLeft, top: -5, width: 10, height: 26, zIndex: 10, pointerEvents: 'none' }}>
              <div style={{
                width: 10, height: 10, background: userMarkerColor, borderRadius: 1,
                transform: 'rotate(45deg)', margin: '8px auto 0', boxShadow: userMarkerShadow
              }} />
            </div>
          )}
        </div>

        {/* dB tick labels */}
        <div style={{ position: 'relative', height: 16, marginTop: 4 }}>{dbTickEls}</div>

        {/* Genre name labels — collision-aware two-row */}
        <div style={{ position: 'relative', height: 32, marginTop: 2 }}>{genreLabelEls}</div>

        {/* Peak legend flush right */}
        <div style={{ position: 'absolute', right: 0, top: -22, display: 'flex', alignItems: 'center', gap: 4 }}>
          <div className={peakDotClass} style={{ width: 8, height: 8, borderRadius: '50%', background: peakDotColor, flexShrink: 0, boxShadow: peakBreached ? '0 0 5px #f85149' : 'none' }} />
          <div style={{ fontSize: 9, color: peakLabelColor, fontFamily: "'Share Tech Mono', monospace", letterSpacing: '0.04em' }}>{peakLabelText}</div>
        </div>
      </div>

      {/* LUFS callout */}
      {hasLufs && (
        <div style={{
          display: 'flex', alignItems: 'center', gap: 10,
          padding: '6px 10px', background: T.panel,
          border: '1px solid ' + userMarkerColor, borderRadius: borderRadius, marginBottom: 0
        }}>
          <div style={{ width: 8, height: 8, background: userMarkerColor, borderRadius: 1, transform: 'rotate(45deg)', flexShrink: 0, boxShadow: userMarkerGlow }} />
          <div style={{ fontSize: 11, color: T.text, fontFamily: "'Share Tech Mono', monospace", flex: 1 }}>
            Your master: <span style={{ color: userMarkerColor, fontWeight: 700 }}>{lufsVal} LUFS</span>
            <span style={{ color: T.muted }}>{lraCalloutText}</span>
          </div>
        </div>
      )}
    </div>
  );

  // ── Section: DYNAMICS ────────────────────────────────────────────────────────
  var dynamicsSection = hasBoth ? (
    <div style={{ marginBottom: 0 }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 5 }}>
        <div style={{ fontSize: 11, letterSpacing: '0.15em', textTransform: 'uppercase', color: T.muted }}>Dynamic Width</div>
        <div style={{ fontSize: 10, fontFamily: "'Barlow Condensed', monospace", fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: lraDyn.colorSolid }}>{dynHeaderText}</div>
      </div>
      <div style={{ position: 'relative', height: 24, background: T.panel, border: '1px solid ' + T.border, borderRadius: 2, overflow: 'hidden' }}>
        {dynGridEls}
        <div style={{ position: 'absolute', left: dynBarLeft, top: 0, width: dynBarWidth, height: '100%', background: lraDyn.colorFill, transition: 'all 0.4s ease' }} />
        <div style={{ position: 'absolute', left: dynBarLeft, top: 0, width: dynBarWidth, height: '100%', border: '1px solid ' + lraDyn.colorSolid, borderRadius: 1, opacity: 0.6, pointerEvents: 'none', boxSizing: 'border-box', transition: 'all 0.4s ease' }} />
        <div style={{ position: 'absolute', left: markerLeft, top: 0, width: 1, height: '100%', background: userMarkerColor, opacity: 0.9, zIndex: 3 }} />
        <div style={{ position: 'absolute', left: dynDiamondLeft, top: '50%', transform: 'translateY(-50%) rotate(45deg)', width: 7, height: 7, background: userMarkerColor, zIndex: 4, boxShadow: userMarkerShadow }} />
        <div style={{ position: 'absolute', left: dynEdgeLeftPos, top: 0, width: 2, height: '100%', background: lraDyn.colorSolid, opacity: 0.85, zIndex: 3 }} />
        <div style={{ position: 'absolute', left: dynEdgeRightPos, top: 0, width: 2, height: '100%', background: lraDyn.colorSolid, opacity: 0.85, zIndex: 3 }} />
      </div>
      <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: 3 }}>
        <div style={{ fontSize: 10, color: T.muted, fontFamily: "'Share Tech Mono', monospace" }}>{rangeLabelLeft}</div>
        <div style={{ fontSize: 10, color: lraDyn.colorSolid, fontFamily: "'Share Tech Mono', monospace", textAlign: 'center' }}>{lraDyn.desc}</div>
        <div style={{ fontSize: 10, color: T.muted, fontFamily: "'Share Tech Mono', monospace" }}>{rangeLabelRight}</div>
      </div>
    </div>
  ) : (
    <div style={{ padding: '8px 12px', border: '1px dashed ' + T.border, borderRadius: borderRadius, display: 'flex', alignItems: 'center', gap: 8 }}>
      <div style={{ fontSize: 11, letterSpacing: '0.12em', textTransform: 'uppercase', color: T.muted }}>Dynamic Width</div>
      <div style={{ fontSize: 10, color: T.muted, fontStyle: 'italic' }}>— run analysis to visualize LRA</div>
    </div>
  );

  // ── Section: MASTERING HEALTH ────────────────────────────────────────────────
  var healthSection = (
    <div>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 6 }}>
        <div style={{ fontSize: 11, letterSpacing: '0.15em', textTransform: 'uppercase', color: T.muted }}>Mastering Health</div>
        <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
          <div style={{ fontSize: 10, color: T.muted, letterSpacing: '0.08em', textTransform: 'uppercase' }}>Target:</div>
          <select value={targetGenre} onChange={function(e) { setTargetGenre(e.target.value); }} style={{
            fontSize: 10, fontFamily: "'Share Tech Mono', monospace",
            background: T.panel, color: T.text,
            border: '1px solid ' + T.border, borderRadius: borderRadius,
            padding: '2px 4px', cursor: 'pointer', outline: 'none', letterSpacing: '0.04em'
          }}>
            {targetSelectEls}
          </select>
        </div>
      </div>
      {hasBoth ? (
        <div style={{ background: T.panel, border: '1px solid ' + healthColor, borderRadius: borderRadius, overflow: 'hidden' }}>
          <div style={{ position: 'relative', height: 6, background: T.border }}>
            <div style={{ position: 'absolute', left: 0, top: 0, height: '100%', width: healthBarW, background: healthColor, transition: 'width 0.5s ease, background 0.3s ease' }} />
          </div>
          <div style={{ padding: '8px 12px' }}>
            <div style={{ display: 'flex', alignItems: 'baseline', gap: 10, marginBottom: 6 }}>
              <div style={{ fontSize: 28, fontWeight: 700, color: healthColor, fontFamily: "'Share Tech Mono', monospace", lineHeight: 1 }}>{healthScoreStr}</div>
              <div style={{ fontSize: 11, fontWeight: 700, color: healthColor, fontFamily: "'Barlow Condensed', sans-serif", letterSpacing: '0.1em', textTransform: 'uppercase' }}>{healthLabel}</div>
            </div>
            <div style={{ fontSize: 11, color: T.text, lineHeight: 1.6, marginBottom: 8 }}>{healthDesc}</div>
            <div style={{ display: 'flex', gap: 16 }}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                <div style={{ fontSize: 9, color: T.muted, letterSpacing: '0.1em', textTransform: 'uppercase' }}>LUFS match</div>
                <div style={{ fontSize: 12, fontWeight: 700, color: T.bright, fontFamily: "'Share Tech Mono', monospace" }}>{healthLufsStr}</div>
              </div>
              <div style={{ width: 1, background: T.border, alignSelf: 'stretch' }} />
              <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                <div style={{ fontSize: 9, color: T.muted, letterSpacing: '0.1em', textTransform: 'uppercase' }}>LRA match</div>
                <div style={{ fontSize: 12, fontWeight: 700, color: T.bright, fontFamily: "'Share Tech Mono', monospace" }}>{healthLraStr}</div>
              </div>
              <div style={{ width: 1, background: T.border, alignSelf: 'stretch' }} />
              <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                <div style={{ fontSize: 9, color: T.muted, letterSpacing: '0.1em', textTransform: 'uppercase' }}>Target LUFS</div>
                <div style={{ fontSize: 12, fontWeight: 700, color: T.bright, fontFamily: "'Share Tech Mono', monospace" }}>{targetData ? targetData.lufs : '—'}</div>
              </div>
              <div style={{ width: 1, background: T.border, alignSelf: 'stretch' }} />
              <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                <div style={{ fontSize: 9, color: T.muted, letterSpacing: '0.1em', textTransform: 'uppercase' }}>Target LRA</div>
                <div style={{ fontSize: 12, fontWeight: 700, color: T.bright, fontFamily: "'Share Tech Mono', monospace" }}>{targetData ? targetData.lra + ' LU' : '—'}</div>
              </div>
            </div>
          </div>
        </div>
      ) : (
        <div style={{ padding: '8px 12px', border: '1px dashed ' + T.border, borderRadius: borderRadius, display: 'flex', alignItems: 'center', gap: 8 }}>
          <div style={{ fontSize: 10, color: T.muted, fontStyle: 'italic' }}>— run analysis to calculate health score</div>
        </div>
      )}
    </div>
  );

  // ── Section: LEGEND ──────────────────────────────────────────────────────────
  var legendSection = (
    <div>
      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px 12px', marginBottom: legendMarginBottom }}>
        {genreLegendEls}
      </div>
      {activeInsight && (
        <div style={{
          marginTop: 8, padding: '8px 12px', background: T.panel,
          border: '1px solid ' + activeInsight.color, borderRadius: borderRadius,
          borderLeft: '3px solid ' + activeInsight.color
        }}>
          <div style={{ fontSize: 10, fontWeight: 700, color: activeInsight.color, letterSpacing: '0.12em', textTransform: 'uppercase', marginBottom: 4, fontFamily: "'Barlow Condensed', sans-serif" }}>
            {activeInsight.label} · {activeInsight.lufs} LUFS / LRA {activeInsight.lra} LU
          </div>
          <div style={{ fontSize: 11, color: T.text, lineHeight: 1.6, fontFamily: "'Share Tech Mono', monospace" }}>
            {activeInsight.insight}
          </div>
        </div>
      )}
    </div>
  );

  // ── render — section-aware ───────────────────────────────────────────────────
  if (section === 'scale')    return scaleSection;
  if (section === 'dynamics') return dynamicsSection;
  if (section === 'health')   return healthSection;
  if (section === 'legend')   return legendSection;

  // Default: render all sections (backwards compat)
  return (
    <div style={{ marginBottom: 20 }}>
      {scaleSection}
      {dynamicsSection}
      {healthSection}
      {legendSection}
    </div>
  );
}

// ── Main panel ────────────────────────────────────────────────────────────────
function AnalysisPanel(props){
  var T=props.T;
  var meta=props.meta;
  var audioFile=props.audioFile;
  var lufsAnalyzing=props.lufsAnalyzing;
  var recalculate=props.recalculate;
  var hasData=!!meta.lufs;

  // Lifted state — shared across all LoudnessGraph section renders
  var [activeGenre,setActiveGenre]=React.useState(null);
  var [targetGenre,setTargetGenre]=React.useState('streaming');

  // Measure panel width for collision detection
  var panelRef=React.useRef(null);
  var [panelWidth,setPanelWidth]=React.useState(0);
  React.useEffect(function(){
    if(!panelRef.current)return;
    var ro=new ResizeObserver(function(entries){
      if(entries[0])setPanelWidth(entries[0].contentRect.width);
    });
    ro.observe(panelRef.current);
    setPanelWidth(panelRef.current.offsetWidth);
    return function(){ro.disconnect();};
  },[]);

  var warnings=[];
  if(hasData){
    for(var i=0;i<AM_KEYS.length;i++){
      var m=AM_KEYS[i];
      var w=meta[m.key]?getMetricWarn(m.key,meta[m.key]):null;
      if(w){ warnings.push({m:m,w:w}); }
    }
  }
  var hasRed=warnings.some(function(x){ return x.w.level==='red'; });
  var hasAmber=!hasRed&&warnings.some(function(x){ return x.w.level==='amber'; });
  var statusColor=hasRed?'#f85149':(hasAmber?'#d29922':'#3fb950');
  var statusText=hasRed?'Issues found':(hasAmber?'Review recommended':'All clear');
  var warnBorder='1px solid '+(hasRed?'#f85149':'#d29922');
  var warnBg=hasRed?'rgba(248,81,73,0.1)':'rgba(210,153,34,0.1)';
  var warnTitleColor=hasRed?'#f85149':'#d29922';
  var btnOpacity=(!audioFile||lufsAnalyzing)?0.4:1;
  var btnCursor=(!audioFile||lufsAnalyzing)?'default':'pointer';
  var issueLabel=warnings.length+' Issue'+(warnings.length>1?'s':'')+' Detected';

  // Shared LoudnessGraph props
  var lgProps={
    currentLufs:meta.lufs, currentLra:meta.lra, currentPeak:meta.samplePeak,
    containerWidth:panelWidth,
    activeGenre:activeGenre, setActiveGenre:setActiveGenre,
    targetGenre:targetGenre, setTargetGenre:setTargetGenre,
    T:T
  };

  var sectionLabel={
    fontSize:10,letterSpacing:'0.18em',textTransform:'uppercase',
    color:T.muted,marginBottom:8,fontFamily:"'Barlow Condensed',sans-serif",
    fontWeight:600,display:'block'
  };

  return(
    <div ref={panelRef} style={{width:'100%',paddingBottom:40}}>
      {/* Page header */}
      <div style={{display:'flex',alignItems:'flex-start',justifyContent:'space-between',marginBottom:20}}>
        <div>
          <div style={{fontSize:12,fontWeight:700,color:T.bright,marginBottom:4,letterSpacing:'0.06em',textTransform:'uppercase'}}>Technical Analysis</div>
          <div style={{fontSize:10,color:T.muted}}>ITU-R BS.1770-4 / EBU R128 / Two-pass gated</div>
        </div>
        <div style={{display:'flex',gap:8,alignItems:'center',marginTop:2}}>
          {(hasData&&!lufsAnalyzing)&&(
            <div style={{fontSize:8,padding:'3px 8px',borderRadius:2,border:'1px solid '+statusColor,color:statusColor}}>
              {statusText}
            </div>
          )}
          <button onClick={recalculate} disabled={!audioFile||lufsAnalyzing}
            style={{padding:'6px 12px',background:T.panel,color:T.text,border:'1px solid '+T.border,
              fontFamily:'inherit',fontSize:9,letterSpacing:'0.1em',textTransform:'uppercase',
              cursor:btnCursor,opacity:btnOpacity,borderRadius:T.r||0}}>
            {lufsAnalyzing?'Analyzing...':'Recalculate'}
          </button>
        </div>
      </div>

      {!audioFile&&(
        <div style={{padding:24,textAlign:'center',border:'1px dashed '+T.border,borderRadius:T.r||0,color:T.text,fontSize:11}}>
          Upload an audio file to run analysis
        </div>
      )}

      {audioFile&&(
        <div>

          {/* ── A. LOUDNESS READINGS ────────────────────────────────────────── */}
          <div style={{marginBottom:20}}>
            <span style={sectionLabel}>Loudness Readings</span>
            <div style={{display:'flex',gap:8,alignItems:'stretch'}}>
              {AM_KEYS.map(function(metric){
                return(
                  <MetricBadge
                    key={metric.key}
                    T={T}
                    metricKey={metric.key}
                    label={metric.label}
                    val={meta[metric.key]}
                    desc={metric.desc}
                    targets={metric.targets}
                    analyzing={lufsAnalyzing}
                  />
                );
              })}
            </div>
          </div>

          {/* ── B. DYNAMIC WIDTH ────────────────────────────────────────────── */}
          <div style={{marginBottom:20}}>
            <span style={sectionLabel}>Dynamic Range</span>
            <LoudnessGraph {...lgProps} section='dynamics'/>
          </div>

          {/* ── C. ISSUES DETECTED ──────────────────────────────────────────── */}
          {(!lufsAnalyzing&&warnings.length>0)&&(
            <div style={{marginBottom:20,border:warnBorder,borderRadius:T.r||0,overflow:'hidden'}}>
              <div style={{padding:'6px 12px',background:warnBg,fontSize:8,letterSpacing:'0.15em',textTransform:'uppercase',color:warnTitleColor}}>
                {issueLabel}
              </div>
              {warnings.map(function(item){
                return(
                  <WarnRow key={item.m.key} T={T} label={item.m.label} level={item.w.level} msg={item.w.msg}/>
                );
              })}
            </div>
          )}

          {/* ── D. LOUDNESS REFERENCE SCALE ─────────────────────────────────── */}
          <div style={{marginBottom:20}}>
            <span style={sectionLabel}>Loudness Reference Scale</span>
            <LoudnessGraph {...lgProps} section='scale'/>
          </div>

          {/* ── E. MASTERING HEALTH ─────────────────────────────────────────── */}
          <div style={{marginBottom:20}}>
            <LoudnessGraph {...lgProps} section='health'/>
          </div>

          {/* ── F. GENRE LEGEND ─────────────────────────────────────────────── */}
          <div style={{marginBottom:20}}>
            <span style={sectionLabel}>Genre Benchmarks</span>
            <LoudnessGraph {...lgProps} section='legend'/>
          </div>

          {/* ── G. SPECTRAL / ARTIFACT ANALYSIS ────────────────────────────── */}
          <div style={{marginBottom:20}}>
            <span style={sectionLabel}>Spectral Analysis</span>
            <OriginEstimateBadge T={T} meta={meta} analyzing={lufsAnalyzing}/>
          </div>

        </div>
      )}
    </div>
  );
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// FILE SYSTEM ACCESS API (FSAPI)
// Thin wrapper — every method can be swapped 1-for-1 with
// Electron's fs module in a future desktop build.
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const FSAPI={
  supported:typeof window.showDirectoryPicker==='function',

  async pickFolder(){
    if(!this.supported)return null;
    try{
      return await window.showDirectoryPicker({mode:'readwrite',startIn:'documents',id:'tracklab-lib'});
    }catch(e){
      if(e.name==='AbortError')return null;
      console.error('[FSAPI] pickFolder:',e);return null;
    }
  },

  async verifyPermission(h){
    if(!h)return false;
    try{
      const s=await h.queryPermission({mode:'readwrite'});
      if(s==='granted')return true;
      return(await h.requestPermission({mode:'readwrite'}))==='granted';
    }catch{return false;}
  },

  // Get or create a nested subfolder: getDir(root, 'Profiles', 'My Artist', 'My Track')
  async getDir(root,...parts){
    let cur=root;
    for(const p of parts){
      if(!p)continue;
      cur=await cur.getDirectoryHandle(p,{create:true});
    }
    return cur;
  },

  async writeFile(dir,filename,data){
    // data: string | ArrayBuffer | Blob
    try{
      const fh=await dir.getFileHandle(filename,{create:true});
      const w=await fh.createWritable();
      await w.write(data);
      await w.close();
      return{ok:true};
    }catch(e){console.error('[FSAPI] writeFile:',e);return{ok:false,error:e.message};}
  },

  async readFile(dir,filename){
    try{
      const fh=await dir.getFileHandle(filename);
      const file=await fh.getFile();
      return file; // caller decides: .text(), .arrayBuffer(), etc.
    }catch{return null;}
  },

  async fileExists(dir,filename){
    try{await dir.getFileHandle(filename);return true;}catch{return false;}
  },

  // Delete a subfolder and all its contents recursively.
  // parent: the DirectoryHandle that contains the folder to delete.
  // dirName: string name of the folder to remove.
  async removeDir(parent,dirName){
    if(!parent||!dirName)return false;
    try{
      await parent.removeEntry(dirName,{recursive:true});
      return true;
    }catch(e){
      // NotFoundError is fine — folder was already gone
      if(e.name!=='NotFoundError')console.warn('[FSAPI] removeDir:',e);
      return false;
    }
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// LIBRARY HELPERS
// Folder-safe name: strip chars that break filesystems
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const safeName=s=>(s||'untitled').replace(/[<>:"/\\|?*\x00-\x1f]/g,'_').replace(/\.+$/,'').trim().slice(0,80)||'untitled';

const README_TEXT=`TRACK LAB — USER LIBRARY
${'━'.repeat(50)}

Created: ${new Date().toLocaleDateString('en-GB',{day:'2-digit',month:'short',year:'numeric'})}
App Version: TrackLab 0.1.2

This folder is your TrackLab library. It is managed automatically
by the app but is fully readable and portable without it.

FOLDER STRUCTURE
${'─'.repeat(40)}
Each top-level folder is an Artist Profile or Project.
Inside each profile, every track has its own folder:

  [Profile Name]/
    _profile.json              — profile metadata
    [Track Title]/
      audio.[ext]              — your audio file
      artwork.jpg              — album art (if set)
      metadata.json            — all tags, codes & label data

ROOT FILES
${'─'.repeat(40)}
  tracklab-catalog.json        — full catalog (used for fast restore)
  README.txt                   — this file (safe to edit)

RESTORING YOUR LIBRARY
${'─'.repeat(40)}
Open TrackLab → Settings (⚙) → Save Location → Choose this folder.
The app reads tracklab-catalog.json and restores everything instantly.

If tracklab-catalog.json is missing, the app will walk each track
folder and rebuild the catalog from individual metadata.json files.

BACKING UP
${'─'.repeat(40)}
Copy this entire folder to Dropbox, Google Drive, or an external
drive. Everything TrackLab needs is contained here.

${'━'.repeat(50)}
Track Lab ${VERSION} · All data stored locally · No account required
`;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// useSavePath HOOK
// Manages the chosen library folder across sessions.
// The DirectoryHandle is persisted in IndexedDB (Chrome supports this).
// On every page load we re-verify permission — if still granted,
// we restore silently. If not, we show the reconnect banner.
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const FS_HANDLE_KEY='tl_fs_dir_handle';

function useSavePath(){
  const [rootDir,setRootDir]=useState(null);
  const [folderName,setFolderName]=useState(()=>loadLS('tl_save_folder_name',''));
  const [permState,setPermState]=useState('idle'); // 'idle'|'checking'|'granted'|'needs-prompt'|'unsupported'
  const [diskSaving,setDiskSaving]=useState(false);
  const [diskLastSaved,setDiskLastSaved]=useState(null);
  const [diskSaveError,setDiskSaveError]=useState('');

  // On mount: try to restore persisted handle
  useEffect(()=>{
    if(!FSAPI.supported){setPermState('unsupported');return;}
    setPermState('checking');
    (async()=>{
      try{
        const stored=await IDB.get(FS_HANDLE_KEY,'assets');
        if(!stored){setPermState('idle');return;}
        // Check permission without prompting the user
        const perm=await stored.queryPermission({mode:'readwrite'});
        if(perm==='granted'){
          setRootDir(stored);
          setFolderName(stored.name||'');
          setPermState('granted');
        }else{
          // Handle exists but needs user gesture to re-grant — show banner
          setPermState('needs-prompt');
          setFolderName(stored.name||'');
        }
      }catch{setPermState('idle');}
    })();
  },[]);

  // One-click reconnect (called from the banner — requires user gesture)
  const reconnect=async()=>{
    if(!FSAPI.supported)return false;
    try{
      const stored=await IDB.get(FS_HANDLE_KEY,'assets');
      if(!stored){setPermState('idle');return false;}
      const ok=await FSAPI.verifyPermission(stored);
      if(ok){
        setRootDir(stored);
        setFolderName(stored.name||'');
        setPermState('granted');
        setDiskSaveError('');
        return true;
      }else{
        setPermState('needs-prompt');
        return false;
      }
    }catch{setPermState('needs-prompt');return false;}
  };

  // Full folder picker (first-time setup or change folder)
  const pickFolder=async()=>{
    const h=await FSAPI.pickFolder();
    if(!h)return false;
    try{await IDB.set(FS_HANDLE_KEY,h,'assets');}catch{}
    saveLS('tl_save_folder_name',h.name||'');
    setRootDir(h);
    setFolderName(h.name||'');
    setPermState('granted');
    setDiskSaveError('');
    // Write README on first use (never overwrite if already exists)
    try{
      const exists=await FSAPI.fileExists(h,'README.txt');
      if(!exists)await FSAPI.writeFile(h,'README.txt',README_TEXT);
    }catch{}
    return true;
  };

  const clearFolder=async()=>{
    try{await IDB.del(FS_HANDLE_KEY,'assets');}catch{}
    saveLS('tl_save_folder_name','');
    setRootDir(null);setFolderName('');
    setPermState('idle');setDiskSaveError('');setDiskLastSaved(null);
  };

  // ── saveCatalog: writes tracklab-catalog.json (fast, metadata only)
  // rootDirRef: always points to the live handle — passed to App so its
  // interval callbacks always use the current value, never a stale closure.
  const rootDirRef=useRef(null);
  useEffect(()=>{rootDirRef.current=rootDir;},[rootDir]);

  // All save helpers receive `dir` explicitly — no closure over rootDir state.
  const _saveCatalog=async(dir,profiles,entries)=>{
    if(!dir)return false;
    const payload={app:'tracklab',version:VERSION,savedAt:new Date().toISOString(),profiles,
      entries:entries.map(e=>({...e,albumArtThumb:undefined}))};
    const result=await FSAPI.writeFile(dir,'tracklab-catalog.json',JSON.stringify(payload,null,2));
    if(result.ok){setDiskLastSaved(new Date());setDiskSaveError('');}
    else setDiskSaveError(result.error||'Write failed');
    return result.ok;
  };

  // ── syncEntry: the single source-of-truth for writing one track to disk.
  // Handles: first-write, metadata updates, renames, numbered prefix, audio/art files.
  // sortIndex: 0-based position in the UI track list (used for folder name prefix).
  // Returns the new diskFolderName string so callers can stamp it back onto the entry.
  const _syncEntry=async(dir,profiles,entry,sortIndex,audioBuf,artBuf)=>{
    if(!dir)return null;
    try{
      const profile=profiles.find(p=>p.id===entry.profileId);
      // Profile folder: use stored diskFolderName if present, else derive it
      const profileFolderName=profile?.diskFolderName||safeName(profile?.name||'Unknown Profile');
      const profileDir=await FSAPI.getDir(dir,profileFolderName);
      if(profile)await FSAPI.writeFile(profileDir,'_profile.json',JSON.stringify({...profile,diskFolderName:profileFolderName},null,2));

      // Track folder: zero-padded index prefix keeps disk order matching UI order
      const idx=typeof sortIndex==='number'?sortIndex:0;
      const prefix=String(idx+1).padStart(2,'0');
      const newFolderName=`${prefix}_${safeName(entry.title||entry.id)}`;
      const oldFolderName=entry.diskFolderName;

      // Write to the new/current folder
      const trackDir=await FSAPI.getDir(profileDir,newFolderName);
      await FSAPI.writeFile(trackDir,'metadata.json',JSON.stringify(
        {...entry,diskFolderName:newFolderName,albumArtThumb:undefined},null,2));
      if(audioBuf){
        const ext=(entry.audioFilename||'audio.mp3').split('.').pop()||'mp3';
        await FSAPI.writeFile(trackDir,`audio.${ext}`,audioBuf);
      }
      if(artBuf)await FSAPI.writeFile(trackDir,'artwork.jpg',artBuf);

      // If the folder was renamed (title changed or sort position shifted), delete the old folder
      if(oldFolderName&&oldFolderName!==newFolderName){
        await FSAPI.removeDir(profileDir,oldFolderName);
      }

      return newFolderName;
    }catch(e){console.error('[syncEntry]',e);return null;}
  };

  // Public API — callers pass dir from rootDirRef.current so it's always live.
  // updateEntryDiskName: optional callback (id, diskFolderName) to stamp the name back onto app state.
  const saveAll=async(dir,profiles,entries,updateEntryDiskName)=>{
    if(!dir)return false;
    setDiskSaving(true);setDiskSaveError('');
    try{
      // Build a per-profile sort order map so each track gets the right index
      // Uses the same manual order that the UI uses (entryManualOrder is external —
      // so saveAll is called with the pre-sorted entries array by the caller)
      const profileIndexMap={}; // {pid: counter}
      await _saveCatalog(dir,profiles,entries);
      for(const entry of entries){
        const pid=entry.profileId;
        if(profileIndexMap[pid]===undefined)profileIndexMap[pid]=0;
        const sortIndex=profileIndexMap[pid]++;
        let audioBuf=null,artBuf=null;
        try{audioBuf=await IDB.get(`audio_${entry.id}`,'assets');}catch{}
        try{artBuf=await IDB.get(`art_${entry.id}`,'assets');}catch{}
        if(audioBuf||artBuf||entry.title){
          const newFolderName=await _syncEntry(dir,profiles,entry,sortIndex,audioBuf,artBuf);
          if(newFolderName&&newFolderName!==entry.diskFolderName&&updateEntryDiskName){
            updateEntryDiskName(entry.id,newFolderName);
          }
        }
      }
      setDiskLastSaved(new Date());
      return true;
    }catch(e){setDiskSaveError(e.message||'Save failed');return false;}
    finally{setDiskSaving(false);}
  };

  // Save one entry immediately — used after the manual Save button press.
  // sortIndex: the entry's current position in the profile's displayed track list.
  // Returns the new diskFolderName (or null) so the caller can stamp it back.
  const saveEntryNow=async(dir,profiles,entry,sortIndex)=>{
    if(!dir||!entry)return null;
    let audioBuf=null,artBuf=null;
    try{audioBuf=await IDB.get(`audio_${entry.id}`,'assets');}catch{}
    try{artBuf=await IDB.get(`art_${entry.id}`,'assets');}catch{}
    return await _syncEntry(dir,profiles,entry,sortIndex??0,audioBuf,artBuf);
  };

  return{rootDir,rootDirRef,folderName,permState,diskSaving,diskLastSaved,diskSaveError,
    pickFolder,clearFolder,reconnect,saveAll,saveEntryNow,_saveCatalog,_syncEntry};
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// useDragResize — draggable sidebar width
// key: localStorage key to persist width across sessions
// defaultW: fallback width in px
// min/max: clamp range
// side: 'right' (handle on right edge) | 'left' (handle on left edge)
// Returns { width, handle } — spread handle props onto the drag-handle div
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function useDragResize({key,defaultW,min=80,max=600,side='right',label=''}){
  const [width,setWidth]=useState(()=>loadLS(key,defaultW));
  const [collapsed,setCollapsed]=useState(()=>loadLS(key+'_col',false));
  const dragging=useRef(false);
  const startX=useRef(0);
  const startW=useRef(0);

  const toggle=useCallback(()=>{
    setCollapsed(c=>{
      const next=!c;
      saveLS(key+'_col',next);
      return next;
    });
  },[key]);

  const onMouseDown=useCallback(e=>{
    if(collapsed)return;
    e.preventDefault();
    dragging.current=true;
    startX.current=e.clientX;
    startW.current=width;
    const onMove=ev=>{
      if(!dragging.current)return;
      const delta=side==='right'?ev.clientX-startX.current:startX.current-ev.clientX;
      const newW=Math.max(min,Math.min(max,startW.current+delta));
      setWidth(newW);
    };
    const onUp=()=>{
      dragging.current=false;
      saveLS(key,Math.max(min,Math.min(max,startW.current+(side==='right'
        ?window._tlLastX-startX.current
        :startX.current-window._tlLastX))));
      window.removeEventListener('mousemove',onMove);
      window.removeEventListener('mouseup',onUp);
      document.body.style.cursor='';
      document.body.style.userSelect='';
    };
    document.body.style.cursor='col-resize';
    document.body.style.userSelect='none';
    window.addEventListener('mousemove',ev=>{window._tlLastX=ev.clientX;onMove(ev);});
    window.addEventListener('mouseup',onUp);
  },[collapsed,width,key,min,max,side]);

  // Drag handle (invisible hit zone on the border)
  const handleEdge=side==='right'?'right':'left';
  const handleStyle={position:'absolute',top:0,width:6,height:'100%',zIndex:50,background:'transparent'};
  handleStyle[handleEdge]=-3;
  const collapsedHandleStyle=Object.assign({},handleStyle,{display:'none'});
  const activeHandleStyle=collapsed?collapsedHandleStyle:Object.assign({},handleStyle,{cursor:'col-resize'});
  const handle={onMouseDown,style:activeHandleStyle};

  // Sleek collapse tab.
  // When EXPANDED: pill sits absolute on the outer border of the panel (inside panel div).
  // When COLLAPSED: panel is width:0 overflow:hidden, so pill must render as a
  //   standalone sibling in the flex row instead — a thin visible strip with the chevron.
  const chevronExp=side==='right'?'‹':'›';
  const chevronCol=side==='right'?'›':'‹';
  const chevron=collapsed?chevronCol:chevronExp;
  const pillEdgeKey=side==='right'?'right':'left';
  const pillStyle={
    position:'absolute',
    top:'50%',
    transform:'translateY(-50%)',
    width:16,
    height:40,
    borderRadius:8,
    background:'var(--app-panel)',
    border:'1px solid var(--app-border)',
    boxShadow:'0 2px 12px rgba(0,0,0,0.5)',
    display:'flex',
    alignItems:'center',
    justifyContent:'center',
    cursor:'pointer',
    zIndex:60,
    userSelect:'none',
    opacity:0.45,
    transition:'opacity 0.18s, box-shadow 0.18s, background 0.18s',
  };
  pillStyle[pillEdgeKey]=-9;

  // The pill rendered inside the panel (only visible when expanded)
  const tab=(
    <div
      onClick={toggle}
      title="Collapse panel"
      style={pillStyle}
      onMouseEnter={e=>{e.currentTarget.style.opacity=1;e.currentTarget.style.boxShadow='0 2px 18px rgba(0,0,0,0.7)';e.currentTarget.style.background='var(--app-accent)';}}
      onMouseLeave={e=>{e.currentTarget.style.opacity=0.45;e.currentTarget.style.boxShadow='0 2px 12px rgba(0,0,0,0.5)';e.currentTarget.style.background='var(--app-panel)';}}
    >
      <span style={{fontSize:9,color:'var(--app-text)',lineHeight:1,fontWeight:700,pointerEvents:'none'}}>{chevron}</span>
    </div>
  );

  // Standalone re-expand stub rendered as a flex sibling when collapsed
  const stubBorderL=side==='left'?'1px solid var(--app-border)':'none';
  const stubBorderR=side==='right'?'1px solid var(--app-border)':'none';
  const expandStub=collapsed?(
    <div
      onClick={toggle}
      title="Expand panel"
      style={{width:14,flexShrink:0,display:'flex',alignItems:'center',justifyContent:'center',
        cursor:'pointer',background:'var(--app-panel)',borderLeft:stubBorderL,borderRight:stubBorderR,
        userSelect:'none',opacity:0.5,transition:'opacity 0.18s, background 0.18s'}}
      onMouseEnter={e=>{e.currentTarget.style.opacity=1;e.currentTarget.style.background='var(--app-accent)';}}
      onMouseLeave={e=>{e.currentTarget.style.opacity=0.5;e.currentTarget.style.background='var(--app-panel)';}}
    >
      <span style={{fontSize:9,color:'var(--app-text)',lineHeight:1,fontWeight:700,pointerEvents:'none'}}>{chevron}</span>
    </div>
  ):null;

  const currentWidth=collapsed?0:width;

  return{width:currentWidth,collapsed,toggle,handle,tab,expandStub};
}

// ━━━━━━━━ SPLIT SHEET COMPONENT ━━━━━━━━
function SplitSheet({T,credits,onChange,trackTitle}){
  const total=credits.reduce((s,c)=>s+(parseFloat(c.split)||0),0);
  const totalOk=credits.length===0||Math.abs(total-100)<0.01;
  const colGrid={display:'grid',gridTemplateColumns:'140px 1fr 70px 90px 100px 24px',gap:4,alignItems:'center'};
  const colH={fontSize:8,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted};
  const inp=(ex)=>({...mkIS(T),padding:'4px 6px',fontSize:10,...ex});

  const addRow=()=>onChange([...credits,{id:mkUid(),role:'Songwriter',name:'',split:'',pro:'—',ipi:''}]);
  const delRow=id=>onChange(credits.filter(c=>c.id!==id));
  const updRow=(id,k,v)=>onChange(credits.map(c=>c.id===id?{...c,[k]:v}:c));

  const copyEmail=()=>{
    if(!credits.length)return;
    const pad=(s,n)=>String(s||'').padEnd(n);
    const div='─'.repeat(62);
    const lines=[
      `SPLIT SHEET${trackTitle?' — '+trackTitle:''}`,
      `Generated by Track Lab · ${new Date().toLocaleDateString()}`,
      div,
      pad('NAME',22)+pad('ROLE',22)+pad('SPLIT',8)+'PRO / IPI',
      div,
      ...credits.map(c=>{
        const proStr=[c.pro&&c.pro!=='—'?c.pro:'',c.ipi?'IPI:'+c.ipi:''].filter(Boolean).join(' · ');
        return pad(c.name||'—',22)+pad(c.role,22)+pad((parseFloat(c.split)||0)+'%',8)+proStr;
      }),
      div,
      'TOTAL: '+(Number.isInteger(total)?total:total.toFixed(2))+'%'+(totalOk?'  ✓ Balanced':credits.length?'  ⚠ Does not total 100%':''),
    ];
    navigator.clipboard.writeText(lines.join('\n')).then(()=>alert('Split sheet copied to clipboard.')).catch(()=>alert('Copy failed — check browser permissions.'));
  };

  return(
    <div style={{maxWidth:740}}>
      <div style={{fontSize:14,fontWeight:700,color:T.bright,marginBottom:4,letterSpacing:'0.04em'}}>Split Sheet</div>
      <div style={{fontSize:10,color:T.muted,lineHeight:1.7,marginBottom:16,maxWidth:580}}>
        Log all contributors and their royalty splits for this track. Splits must total <strong style={{color:T.text}}>100%</strong> before export or filing.
        <br/><strong style={{color:T.text}}>PRO</strong> — performing rights organization. <strong style={{color:T.text}}>IPI/CAE</strong> — your 9-digit PRO member number.
      </div>

      {credits.length===0?(
        <div style={{padding:'28px 20px',textAlign:'center',background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,marginBottom:14}}>
          <div style={{fontSize:10,color:'#f87171',marginBottom:8,letterSpacing:'0.06em'}}>⚠ NO CREDITS LOGGED</div>
          <div style={{fontSize:9,color:T.muted,lineHeight:1.65,marginBottom:14,maxWidth:360,margin:'0 auto 14px'}}>
            Royalty disputes are the #1 legal issue in indie music. Logging credits here creates a timestamped record inside your archive backup.
          </div>
          <button onClick={addRow} style={{...mkBtn(T,true),padding:'8px 20px',fontSize:9}}>+ Add First Contributor</button>
        </div>
      ):(
        <>
          <div style={{...colGrid,marginBottom:5,paddingBottom:7,borderBottom:`1px solid ${T.border}`}}>
            <span style={colH}>Role</span>
            <span style={colH}>Full Name</span>
            <span style={{...colH,textAlign:'right'}}>Split %</span>
            <span style={colH}>PRO</span>
            <span style={colH}>IPI / CAE</span>
            <span/>
          </div>
          {credits.map(c=>(
            <div key={c.id} style={{...colGrid,marginBottom:4}}>
              <select value={c.role} onChange={e=>updRow(c.id,'role',e.target.value)} style={inp()}>
                {CREDIT_ROLES.map(r=><option key={r} value={r}>{r}</option>)}
              </select>
              <input value={c.name} onChange={e=>updRow(c.id,'name',e.target.value)} placeholder="Full legal name" style={inp()}/>
              <input type="number" min={0} max={100} step={0.5} value={c.split} onChange={e=>updRow(c.id,'split',e.target.value)} placeholder="0" style={inp({textAlign:'right',borderColor:(parseFloat(c.split)>100||parseFloat(c.split)<0)?'#f85149':T.border})}/>
              <select value={c.pro} onChange={e=>updRow(c.id,'pro',e.target.value)} style={inp()}>
                {PRO_LIST.map(pr=><option key={pr} value={pr}>{pr}</option>)}
              </select>
              <input value={c.ipi} onChange={e=>updRow(c.id,'ipi',e.target.value.replace(/\D/g,'').slice(0,9))} placeholder="000000000" style={inp({letterSpacing:'0.1em'})}/>
              <button onClick={()=>delRow(c.id)} style={{background:'none',border:'none',color:'#f87171',cursor:'pointer',fontSize:12,padding:0,lineHeight:1,textAlign:'center'}}>✕</button>
            </div>
          ))}
          {/* Total bar */}
          <div style={{marginTop:12,padding:'10px 12px',background:T.card,border:`1px solid ${totalOk?T.border:'#f85149'}`,borderRadius:T.r||0,display:'flex',alignItems:'center',gap:10}}>
            <div style={{flex:1,height:4,background:T.bg,borderRadius:2,overflow:'hidden'}}>
              <div style={{height:'100%',width:`${Math.min(total,100)}%`,background:totalOk?'#3fb950':total>100?'#f85149':'#d29922',borderRadius:2,transition:'width 0.2s'}}/>
            </div>
            <span style={{fontSize:10,fontWeight:700,color:totalOk?'#3fb950':total>100?'#f85149':'#d29922',minWidth:60,textAlign:'right'}}>
              {Number.isInteger(total)?total:total.toFixed(1)}% {totalOk?'✓':total>100?`(+${(total-100).toFixed(1)}% over)`:`(${(100-total).toFixed(1)}% left)`}
            </span>
          </div>
          <div style={{display:'flex',gap:6,marginTop:10}}>
            <button onClick={addRow} style={{...mkBtn(T,true),padding:'7px 14px',fontSize:9}}>+ Add Contributor</button>
            <button onClick={copyEmail} style={{...mkBtn(T),padding:'7px 14px',fontSize:9}}>📋 Copy as Text</button>
          </div>
        </>
      )}
    </div>
  );
}

function App(){
  // Theme
  // ── Validate stored appTheme on startup — repair it if it came from an older/different version
  const [appTheme,setAppThemeRaw]=useState(()=>{
    const stored=loadLS('tl_apptheme',DEFAULT_APP_THEME);
    // If stored themeKey doesn't exist in current APP_THEMES and isn't 'custom', reset to default key
    if(stored.themeKey && stored.themeKey!=='custom' && !APP_THEMES[stored.themeKey]){
      const repaired={...DEFAULT_APP_THEME,...stored,themeKey:'void'};
      saveLS('tl_apptheme',repaired);
      return repaired;
    }
    // Merge with defaults so any missing keys from old versions get filled in
    return{...DEFAULT_APP_THEME,...stored};
  });
  const setAppTheme=useCallback(upd=>setAppThemeRaw(a=>{const na=typeof upd==='function'?upd(a):{...a,...upd};saveLS('tl_apptheme',na);return na;}),[]);
  const [showTheme,setShowTheme]=useState(false);
  const T=getAppTheme(appTheme);

  // ── FILE SYSTEM (disk library)
  const {rootDir,rootDirRef,folderName,permState,diskSaving,diskLastSaved,diskSaveError,
    pickFolder,clearFolder,reconnect,saveAll,saveEntryNow,_saveCatalog,_syncEntry}=useSavePath();
  // Always-current ref so disk-save intervals never capture stale state
  const diskSaveAllRef=useRef();

  useEffect(()=>{
    document.body.style.filter=`brightness(${appTheme.brightness||100}%)`;
    document.body.style.background=T.bg;document.body.style.color=T.text;
    document.documentElement.style.background=T.bg;
    // Apply UI font — falls back to Share Tech Mono if not set
    const uiFont=appTheme.uiFontCss||'"Share Tech Mono",monospace';
    document.body.style.fontFamily=uiFont;
    const r=document.documentElement;
    [['--app-bg',T.bg],['--app-border',T.border],['--app-accent',T.accent],['--app-panel',T.panel],['--app-text',T.text]].forEach(([k,v])=>r.style.setProperty(k,v));
    // UI Scale — zoom scales the entire layout (all px values, panels, buttons, gaps)
    const root=document.getElementById('root');
    if(root)root.style.zoom=`${(appTheme.uiFontSize||100)/100}`;
  },[appTheme,T]);

  // ── GLOBAL DRAG GUARD — prevent browser from hijacking file drops and opening them in a new tab
  useEffect(()=>{
    const stop=e=>e.preventDefault();
    window.addEventListener('dragover',stop);
    window.addEventListener('drop',stop);
    return()=>{
      window.removeEventListener('dragover',stop);
      window.removeEventListener('drop',stop);
    };
  },[]);

  const [tab,setTab]=useState('archive');
  // ── SIDEBAR RESIZE
  const archiveSidebar=useDragResize({key:'tl_w_archive_sidebar',defaultW:220,min:140,max:400,label:'Profiles'});
  const archiveDetail=useDragResize({key:'tl_w_archive_detail',defaultW:240,min:160,max:420,side:'left',label:'Detail'});
  const metaSidebar=useDragResize({key:'tl_w_meta_sidebar',defaultW:155,min:100,max:320,label:'Sections'});
  const labelPanel=useDragResize({key:'tl_w_label_panel',defaultW:288,min:180,max:480,label:'Controls'});
  const batchPanel=useDragResize({key:'tl_w_batch_panel',defaultW:232,min:160,max:400,side:'left',label:'Batch'});
  const [savedFlash,setSavedFlash]=useState(false);
  const [autoSaving,setAutoSaving]=useState(false);
  const [zipping,setZipping]=useState(false);

  // ━━━━━━━━ UNDO / REDO ━━━━━━━━
  // metaHistory  — tracks the active editing state: meta, fields, settings, credits, artState
  //               Snapshot taken on: every field blur/change (debounced 800ms), before save, on tab switch away
  // catalogHistory — tracks structural catalog state: entries[], profiles[], order maps
  //               Snapshot taken on: before delete, before reorder, before bulk-status change
  //
  // Art pointer rule: albumArt data is stored in IndexedDB, NOT in the snapshot.
  // We keep the '[stored]' flag string so restore knows to leave it intact.
  // History stacks — seeded with null; populated on first snapshot after real state is ready.
  // Using null as the initial slot means undo() can never return an empty-state snapshot.
  // The stacks are seeded by a one-shot useEffect once all state is declared (see below).
  const metaHistory=useHistory(null);
  const catalogHistory=useHistory(null);
  // Debounce timer ref for meta snapshot (avoids a snapshot per keypress)
  const metaSnapTimer=useRef(null);
  // Flag to suppress pushing a snapshot during an undo/redo restore itself
  const suppressMetaSnap=useRef(false);
  const suppressCatalogSnap=useRef(false);

  // ── Snapshot helpers (called at mutation points)
  // scheduleMetaSnap: debounced 800ms — safe to call on every keystroke
  const scheduleMetaSnap=useCallback((m,f,s,c,a)=>{
    if(suppressMetaSnap.current)return;
    clearTimeout(metaSnapTimer.current);
    metaSnapTimer.current=setTimeout(()=>{
      metaHistory.push({
        meta:{...m,albumArt:m?.albumArt&&!m.albumArt.startsWith('[stored]')?'[stored]':m?.albumArt},
        fields:{...f},
        settings:{...s},
        credits:[...(c||[])],
        artState:a?JSON.parse(JSON.stringify(a)):null,
      });
    },800);
  },[metaHistory]);

  const pushMetaSnapNow=useCallback((m,f,s,c,a)=>{
    if(suppressMetaSnap.current)return;
    clearTimeout(metaSnapTimer.current);
    metaHistory.push({
      meta:{...m,albumArt:m?.albumArt&&!m.albumArt.startsWith('[stored]')?'[stored]':m?.albumArt},
      fields:{...f},
      settings:{...s},
      credits:[...(c||[])],
      artState:a?JSON.parse(JSON.stringify(a)):null,
    });
  },[metaHistory]);

  const pushCatalogSnap=useCallback((ents,profs,profOrd,entOrd)=>{
    if(suppressCatalogSnap.current)return;
    catalogHistory.push({
      entries:ents.map(e=>({...e,albumArtThumb:undefined})),
      profiles:[...profs],
      profileOrder:[...profOrd],
      entryManualOrder:{...entOrd},
    });
  },[catalogHistory]);

  // ── PROFILES
  const [profiles,setProfilesRaw]=useState(()=>loadLS('tl_profiles',[]));
  const setProfiles=ps=>{
    // Accepts either a new array or a functional updater (prev=>newArr)
    if(typeof ps==='function'){
      setProfilesRaw(prev=>{const next=ps(prev);saveLS('tl_profiles',next);return next;});
    }else{
      setProfilesRaw(ps);saveLS('tl_profiles',ps);
    }
  };
  const [activePid,setActivePidRaw]=useState(()=>loadLS('tl_active_profile',null));
  const setActivePid=id=>{setActivePidRaw(id);saveLS('tl_active_profile',id);};
  const [newProf,setNewProf]=useState({open:false,name:'',desc:''});
  const [editProf,setEditProf]=useState(null); // {id,name,desc} when editing
  const createProfile=()=>{
    if(!newProf.name.trim())return;
    const folderName=safeName(newProf.name.trim());
    const p={id:mkUid(),name:newProf.name.trim(),description:newProf.desc.trim(),created:todayStr(),diskFolderName:folderName};
    setProfiles([...profiles,p]);setActivePid(p.id);
    setNewProf({open:false,name:'',desc:''});
    // Adopt any orphaned entries (profileId not matching any existing profile)
    // This preserves tracks that were dropped before a profile existed
    setEntriesRaw(prev=>{
      const knownPids=new Set([...profiles.map(x=>x.id),p.id]);
      const hasOrphans=prev.some(e=>!knownPids.has(e.profileId));
      if(!hasOrphans)return prev;
      const next=prev.map(e=>knownPids.has(e.profileId)?e:{...e,profileId:p.id});
      saveLS('tl_entries',next);
      return next;
    });
  };
  const saveEditProfile=async()=>{
    if(!editProf||!editProf.name.trim())return;
    const oldProfile=profiles.find(p=>p.id===editProf.id);
    const updatedProfile={...oldProfile,name:editProf.name.trim(),description:editProf.desc.trim()};
    const dir=rootDirRef.current;
    // If a disk folder exists under the old name, rename it by writing new _profile.json
    // and letting the next saveAll re-sync the new folder name
    if(dir&&oldProfile){
      try{
        const oldFolderName=oldProfile.diskFolderName||safeName(oldProfile.name||'Unknown Profile');
        const newFolderName=safeName(updatedProfile.name||'Unknown Profile');
        if(oldFolderName!==newFolderName){
          // Create new folder, copy _profile.json, schedule a full sync to move track folders
          const newProfileDir=await FSAPI.getDir(dir,newFolderName);
          await FSAPI.writeFile(newProfileDir,'_profile.json',
            JSON.stringify({...updatedProfile,diskFolderName:newFolderName},null,2));
          // Stamp new diskFolderName — old folder will be abandoned (tracks re-saved under new name)
          updatedProfile.diskFolderName=newFolderName;
          // Clear diskFolderName on all entries in this profile so _syncEntry re-creates them
          setEntriesRaw(prev=>{
            const ns=prev.map(e=>e.profileId===editProf.id?{...e,diskFolderName:undefined}:e);
            saveLS('tl_entries',ns);return ns;
          });
          // Remove old profile folder after a brief delay so new one is ready
          setTimeout(async()=>{
            try{await FSAPI.removeDir(dir,oldFolderName);}catch{}
          },1500);
        }
      }catch(e){console.warn('[saveEditProfile] disk rename:',e);}
    }
    const updatedProfiles=profiles.map(p=>p.id===editProf.id?updatedProfile:p);
    setProfiles(updatedProfiles);
    setEditProf(null);
    // Trigger a full disk save to rebuild track folders under the new profile folder name
    if(dir)setTimeout(()=>diskSaveAllRef.current?.(),600);
  };
  // Fix stale closure: use functional updaters for entries so we always have fresh state
  const deleteProfile=async id=>{
    const profile=profiles.find(p=>p.id===id);
    // Snapshot catalog state BEFORE the delete so it can be undone
    pushCatalogSnap(entries,profiles,profileOrder,entryManualOrder);
    // 1. Remove all track blobs from IndexedDB
    entries.filter(e=>e.profileId===id).forEach(async e=>{
      try{await IDB.del(`audio_${e.id}`);await IDB.del(`art_${e.id}`);}catch{}
    });
    // 2. Remove the profile's entire folder from disk
    const dir=rootDirRef.current;
    if(dir&&profile){
      try{
        const profileFolderName=profile.diskFolderName||safeName(profile.name||'Unknown Profile');
        await FSAPI.removeDir(dir,profileFolderName);
      }catch(e){console.warn('[deleteProfile] disk cleanup:',e);}
    }
    // 3. Update app state
    const remainingEntries=entries.filter(e=>e.profileId!==id);
    const remainingProfiles=profiles.filter(p=>p.id!==id);
    setProfiles(remainingProfiles);
    setEntriesRaw(prev=>{const next=prev.filter(e=>e.profileId!==id);saveLS('tl_entries',next);return next;});
    setProfileOrder(prev=>prev.filter(pid=>pid!==id));
    if(activePid===id){
      setActivePid(null);
      // Stop playback if the playing track belonged to this profile
      const deletedEids=new Set(entries.filter(e=>e.profileId===id).map(e=>e.id));
      if(deletedEids.has(playingEid)){
        const el=audioElRef.current;
        if(el){el.pause();el.src='';}
        setPlayingEid(null);
        setPlaying(false);
        _setAudioUrl(null);
      }
      // Reset all metadata fields since the active entry is gone
      setActiveEid(null);
      setMetaRaw({...DEFAULT_METADATA});saveLS('tl_metadata',{...DEFAULT_METADATA});
      setFieldsRaw({...DEFAULT_FIELDS});saveLS('tl_fields',{...DEFAULT_FIELDS});
      setSettingsRaw({...DEFAULT_SETTINGS});saveLS('tl_settings',{...DEFAULT_SETTINGS});
      setCreditsRaw([]);saveLS('tl_credits',[]);
      setAudioFile(null);
    }
    // 4. Re-save catalog without this profile
    if(dir)try{await _saveCatalog(dir,remainingProfiles,remainingEntries);}catch{}
  };
  const activeProfile=profiles.find(p=>p.id===activePid)||null;

  // ── ENTRIES
  const [entries,setEntriesRaw]=useState(()=>loadLS('tl_entries',[]));
  const setEntries=es=>{
    if(typeof es==='function'){
      setEntriesRaw(prev=>{const next=es(prev);saveLS('tl_entries',next);return next;});
    }else{
      setEntriesRaw(es);saveLS('tl_entries',es);
    }
  };
  const [activeEid,setActiveEidRaw]=useState(()=>{const saved=loadLS('tl_active_eid',null);return saved;});
  const setActiveEid=id=>{setActiveEidRaw(id);saveLS('tl_active_eid',id);};
  const activeEidRef=useRef(activeEid);
  useEffect(()=>{activeEidRef.current=activeEid;},[activeEid]);
  const activeEntry=entries.find(e=>e.id===activeEid)||null;
  const profEntries=useMemo(()=>entries.filter(e=>e.profileId===activePid).sort((a,b)=>(b.updated||'').localeCompare(a.updated||'')),[entries,activePid]);

  // ── DRAG-TO-REORDER STATE
  // profileOrder: array of profile IDs in display order (persisted)
  // entryManualOrder: {[pid]: [eid, eid, ...]} per-profile manual track order (persisted)
  const [profileOrder,setProfileOrderRaw]=useState(()=>loadLS('tl_profile_order',[]));
  const setProfileOrder=o=>{
    if(typeof o==='function'){setProfileOrderRaw(prev=>{const n=o(prev);saveLS('tl_profile_order',n);return n;});}
    else{setProfileOrderRaw(o);saveLS('tl_profile_order',o);}
  };
  const [entryManualOrder,setEntryManualOrderRaw]=useState(()=>loadLS('tl_entry_order',{}));
  const setEntryManualOrder=o=>{setEntryManualOrderRaw(o);saveLS('tl_entry_order',o);};
  const profileDragRef=useRef(null);   // id of profile being dragged
  const profileDragOverRef=useRef(null);
  const [profileDragOverId,setProfileDragOverId]=useState(null);
  const entryDragRef=useRef(null);     // id of entry being dragged
  const entryDragOverRef=useRef(null);
  const [entryDragOverId,setEntryDragOverId]=useState(null);

  // orderedProfiles: profiles in user-defined drag order
  const orderedProfiles=useMemo(()=>{
    if(!profileOrder.length)return profiles;
    const map=Object.fromEntries(profiles.map(p=>[p.id,p]));
    const ordered=profileOrder.map(id=>map[id]).filter(Boolean);
    // Append any profiles not yet in the order array (newly created)
    const inOrder=new Set(profileOrder);
    profiles.forEach(p=>{if(!inOrder.has(p.id))ordered.push(p);});
    return ordered;
  },[profiles,profileOrder]);

  // Profile drag reorder — uses functional setProfileOrder to avoid stale closure
  const reorderProfiles=(dragId,overId)=>{
    if(dragId===overId)return;
    setProfileOrder(prev=>{
      const order=[...prev];
      const from=order.indexOf(dragId),to=order.indexOf(overId);
      if(from===-1||to===-1)return prev;
      order.splice(from,1);order.splice(to,0,dragId);
      return order;
    });
  };

  // Entry drag reorder — uses functional updaters to avoid stale closure
  const reorderEntries=(dragId,overId,pid)=>{
    if(dragId===overId||!pid)return;
    // Snapshot before reorder so it can be undone
    pushCatalogSnap(entries,profiles,profileOrder,entryManualOrder);
    setEntriesRaw(prev=>{
      // Build current order for this profile from raw entries
      const allProfIds=prev.filter(e=>e.profileId===pid).map(e=>e.id);
      setEntryManualOrder(curOrder=>{
        const existing=curOrder[pid]||[];
        // Merge: start with existing manual order, add any new entries at end
        const working=[...new Set([...existing,...allProfIds])].filter(id=>allProfIds.includes(id));
        const from=working.indexOf(dragId),to=working.indexOf(overId);
        if(from===-1||to===-1)return curOrder;
        working.splice(from,1);working.splice(to,0,dragId);
        return{...curOrder,[pid]:working};
      });
      return prev; // entries array unchanged — only order changes
    });
    setArchiveSort('manual');
    // Re-save catalog so disk order stays in sync — full folder rename on next timed save
    const dir=rootDirRef.current;
    if(dir)setTimeout(()=>diskSaveAllRef.current?.(),400);
  };
  const [archiveSearch,setArchiveSearch]=useState('');
  const [archiveDragOver,setArchiveDragOver]=useState(false);
  const [dropProfilePrompt,setDropProfilePrompt]=useState(false);
  const [dropProfileName,setDropProfileName]=useState('');
  const pendingDropFilesRef=useRef([]);
  const [selectMode,setSelectMode]=useState(false);
  const [selectedEids,setSelectedEids]=useState(new Set());
  const [bulkStatus,setBulkStatus]=useState('complete');
  const [archiveSort,setArchiveSort]=useState('updated');
  const [archiveStatusFilter,setArchiveStatusFilter]=useState('all');
  const filteredEntries=useMemo(()=>{
    const q=archiveSearch.trim().toLowerCase();
    let base=entries.filter(e=>e.profileId===activePid);
    if(archiveStatusFilter!=='all')base=base.filter(e=>(e.status||'draft')===archiveStatusFilter);
    if(q)base=base.filter(e=>(e.title||'').toLowerCase().includes(q)||(e.artist||'').toLowerCase().includes(q)||(e.classCode||'').toLowerCase().includes(q)||(e.status||'').toLowerCase().includes(q));
    return base.sort((a,b)=>{
      if(archiveSort==='manual'){
        const order=entryManualOrder[activePid]||[];
        const ai=order.indexOf(a.id),bi=order.indexOf(b.id);
        if(ai===-1&&bi===-1)return(b.updated||'').localeCompare(a.updated||'');
        if(ai===-1)return 1;if(bi===-1)return -1;
        return ai-bi;
      }
      if(archiveSort==='title')return(a.title||'').localeCompare(b.title||'');
      if(archiveSort==='created')return(b.created||'').localeCompare(a.created||'');
      if(archiveSort==='status')return(a.status||'draft').localeCompare(b.status||'draft');
      return(b.updated||'').localeCompare(a.updated||'');
    });
  },[entries,activePid,archiveSearch,archiveSort,archiveStatusFilter,entryManualOrder]);
  const toggleSelectMode=()=>{setSelectMode(m=>!m);setSelectedEids(new Set());};
  const toggleEid=id=>setSelectedEids(prev=>{const n=new Set(prev);n.has(id)?n.delete(id):n.add(id);return n;});
  const selectAll=()=>setSelectedEids(new Set(filteredEntries.map(e=>e.id)));
  const applyBulkStatus=()=>{
    if(!selectedEids.size)return;
    // Snapshot before bulk change
    pushCatalogSnap(entries,profiles,profileOrder,entryManualOrder);
    setEntriesRaw(es=>{const ns=es.map(e=>selectedEids.has(e.id)?{...e,status:bulkStatus,updated:todayStr()}:e);saveLS('tl_entries',ns);return ns;});
    setSelectedEids(new Set());
  };

  const duplicateEntry=e=>{
    const newId=mkUid();
    const dupe={...e,id:newId,title:(e.title||'Untitled')+' (copy)',created:todayStr(),updated:todayStr(),hasAudio:false,hasArt:false,audioFilename:'',audioType:'',albumArtThumb:null,metadata:{...e.metadata,albumArt:null}};
    setEntries([...entries,dupe]);
    setActiveEid(newId);
  };

  const createEntry=()=>{
    if(!activePid)return;
    const e={id:mkUid(),profileId:activePid,title:'',artist:'',created:todayStr(),updated:todayStr(),status:'draft',
      metadata:{...DEFAULT_METADATA},labelFields:{...DEFAULT_FIELDS},labelSettings:{...DEFAULT_SETTINGS},
      artState:{...DEFAULT_ART_STATE},studioSubTab:'label',
      classCode:'',hasAudio:false,hasArt:false,audioFilename:'',audioType:'',albumArtThumb:null};
    setEntries([...entries,e]);
    setActiveEid(e.id);
    // Reset all working state to defaults for the fresh entry
    setFieldsRaw({...DEFAULT_FIELDS});saveLS('tl_fields',{...DEFAULT_FIELDS});
    setSettingsRaw({...DEFAULT_SETTINGS});saveLS('tl_settings',{...DEFAULT_SETTINGS});
    setMetaRaw({...DEFAULT_METADATA});saveLS('tl_metadata',{...DEFAULT_METADATA});
    setCreditsRaw([]);saveLS('tl_credits',[]);
    setAudioFile(null);
    setAudioObjectUrl(null);
    setTab('metadata');
  };

  const updateEntry=(id,changes)=>{setEntriesRaw(es=>{const ns=es.map(e=>e.id===id?{...e,...changes,updated:todayStr()}:e);saveLS('tl_entries',ns);return ns;});};

  const deleteEntry=async id=>{
    const entry=entries.find(e=>e.id===id);
    // Snapshot catalog state BEFORE the delete so it can be undone
    pushCatalogSnap(entries,profiles,profileOrder,entryManualOrder);
    // 1. Remove blobs from IndexedDB
    try{await IDB.del(`audio_${id}`);await IDB.del(`art_${id}`);}catch{}
    // 2. Remove folder from disk library
    const dir=rootDirRef.current;
    if(dir&&entry?.diskFolderName){
      try{
        const profile=profiles.find(p=>p.id===entry.profileId);
        const profileFolderName=profile?.diskFolderName||safeName(profile?.name||'Unknown Profile');
        const profileDir=await FSAPI.getDir(dir,profileFolderName);
        await FSAPI.removeDir(profileDir,entry.diskFolderName);
      }catch(e){console.warn('[deleteEntry] disk cleanup:',e);}
    }
    // 3. Update app state and re-save catalog without this entry
    const remaining=entries.filter(e=>e.id!==id);
    setEntries(remaining);
    // If the deleted entry is currently playing, stop the audio immediately
    if(playingEid===id){
      const el=audioElRef.current;
      if(el){el.pause();el.src='';}
      setPlayingEid(null);
      setPlaying(false);
      _setAudioUrl(null);
    }
    // If the deleted entry is the active (selected) one, clear all metadata fields
    if(activeEid===id){
      setActiveEid(null);
      setMetaRaw({...DEFAULT_METADATA});saveLS('tl_metadata',{...DEFAULT_METADATA});
      setFieldsRaw({...DEFAULT_FIELDS});saveLS('tl_fields',{...DEFAULT_FIELDS});
      setSettingsRaw({...DEFAULT_SETTINGS});saveLS('tl_settings',{...DEFAULT_SETTINGS});
      setCreditsRaw([]);saveLS('tl_credits',[]);
      setAudioFile(null);
      // Only clear audio URL if not already cleared above (i.e. wasn't playing)
      if(playingEid!==id)_setAudioUrl(null);
    }
    // 4. Re-number remaining tracks on disk so folder prefixes stay sequential
    if(dir)setTimeout(()=>diskSaveAllRef.current?.(),300);
  };

  // ── FOLDER-AWARE DROP EXTRACTION
  // Returns {files, folderName|null} — reads recursively from dropped folders via FileSystem API
  const extractDropItems=async(dataTransfer)=>{
    const AUDIO_RE=/\.(mp3|wav|flac|aiff?|m4a|ogg|opus|wma)$/i;
    const isAudio=f=>f.type.startsWith('audio/')||AUDIO_RE.test(f.name);

    // Try FileSystem API (Chrome/Edge) for folder support
    const items=Array.from(dataTransfer.items||[]);
    const entries_=[...items].map(i=>i.webkitGetAsEntry&&i.webkitGetAsEntry()).filter(Boolean);
    const hasFolder=entries_.some(e=>e.isDirectory);

    if(hasFolder){
      const readDir=async(dirEntry)=>{
        return new Promise(res=>{
          const reader=dirEntry.createReader();
          const all=[];
          const readBatch=()=>{
            reader.readEntries(batch=>{
              if(!batch.length)return res(all);
              all.push(...batch);
              readBatch();
            },()=>res(all));
          };
          readBatch();
        });
      };
      const getFileFromEntry=entry=>new Promise(res=>entry.file(res,()=>res(null)));
      const collectFiles=async(entry)=>{
        if(entry.isFile){
          const f=await getFileFromEntry(entry);
          return f&&isAudio(f)?[f]:[];
        }
        if(entry.isDirectory){
          const children=await readDir(entry);
          const nested=await Promise.all(children.map(collectFiles));
          return nested.flat();
        }
        return[];
      };
      const allFiles=(await Promise.all(entries_.map(collectFiles))).flat();
      const dirEntries=entries_.filter(e=>e.isDirectory);
      const folderName=dirEntries.length===1?dirEntries[0].name:null;
      return{files:allFiles,folderName};
    }

    // Plain files — no folder involved
    const files=Array.from(dataTransfer.files).filter(isAudio);
    return{files,folderName:null};
  };

  // ── BATCH AUDIO IMPORT — shared by drop handler and no-profile drop flow
  const importAudioFiles=(files,pid)=>{
    if(!files.length||!pid)return;
    const newEntries=files.map(file=>{
      const eid=mkUid();
      const title=file.name.replace(/\.[^.]+$/,'');
      return{entry:{id:eid,profileId:pid,title,artist:'',created:todayStr(),updated:todayStr(),status:'draft',
        metadata:{...DEFAULT_METADATA,title},labelFields:{...DEFAULT_FIELDS},labelSettings:{...DEFAULT_SETTINGS},
        artState:{...DEFAULT_ART_STATE},studioSubTab:'label',
        classCode:'',hasAudio:false,hasArt:false,audioFilename:file.name,audioType:file.type,albumArtThumb:null,analyzing:true},file};
    });
    setEntries(prev=>[...prev,...newEntries.map(x=>x.entry)]);
    const last=newEntries[newEntries.length-1];
    setActiveEid(last.entry.id);
    setMetaRaw({...DEFAULT_METADATA,title:last.entry.title});saveLS('tl_metadata',{...DEFAULT_METADATA,title:last.entry.title});
    setCreditsRaw([]);saveLS('tl_credits',[]);
    newEntries.forEach(async({entry:ent,file})=>{
      try{
        const buf=await file.arrayBuffer();
        const key=`audio_${ent.id}`;
        await IDB.set(key,buf,'assets');
        const blob=new Blob([buf],{type:file.type});
        const objUrl=URL.createObjectURL(blob);
        setEntries(prev=>prev.map(e=>e.id===ent.id?{...e,hasAudio:true,analyzing:false}:e));
        if(activeEidRef.current===ent.id){_setAudioUrl(objUrl);setPlayingEid(ent.id);}
        if(typeof jsmediatags!=='undefined'){
          jsmediatags.read(file,{
            onSuccess(tag){
              const t=tag.tags,ch={};
              if(t.title)ch.title=t.title;
              if(t.artist)ch.artist=t.artist;
              if(t.album)ch.album=t.album;
              if(t.year)ch.year=String(t.year);
              if(t.genre)ch.genre=t.genre;
              if(t.track)ch.trackNum=String(t.track).split('/')[0];
              if(t.comment?.text)ch.comment=t.comment.text;
              setEntries(prev=>prev.map(e=>e.id===ent.id?{...e,metadata:{...e.metadata,...ch},title:ch.title||e.title,artist:ch.artist||e.artist}:e));
              if(activeEidRef.current===ent.id&&Object.keys(ch).length)setMetaObj(ch);
              if(t.picture){
                const bytes=new Uint8Array(t.picture.data);
                const b64=btoa(bytes.reduce((a,b)=>a+String.fromCharCode(b),''));
                const artData=`data:${t.picture.format};base64,${b64}`;
                setEntries(prev=>prev.map(e=>e.id===ent.id?{...e,metadata:{...e.metadata,albumArt:'[stored]'},hasArt:true,albumArtThumb:artData}:e));
                if(activeEidRef.current===ent.id)setMetaObj({albumArt:artData});
              }
            },onError(){}
          });
        }
        try{
          // Queue analysis serially — running multiple OfflineAudioContexts simultaneously
          // bogs down the browser's audio engine and makes the UI janky.
          analysisQueueRef.current=analysisQueueRef.current.then(async()=>{
            try{
              const audioContext=new (window.AudioContext||window.webkitAudioContext)();
              const decoded=await audioContext.decodeAudioData(buf.slice(0));
              audioContext.close();
              const analysis=await performFullAudioAnalysis(decoded);
              if(analysis){
                setEntries(prev=>prev.map(e=>e.id===ent.id?{...e,metadata:{...e.metadata,...analysis}}:e));
                if(activeEidRef.current===ent.id)setMetaRaw(m=>{const nm={...m,...analysis};saveLS('tl_metadata',nm);return nm;});
              }
            }catch{}
          });
          await analysisQueueRef.current;
        }catch{}
      }catch(err){
        console.warn('Batch import failed for',file.name,err);
        setEntries(prev=>prev.map(e=>e.id===ent.id?{...e,analyzing:false}:e));
      }
    });
  };

  const loadEntryRef=useRef(null);

  const loadEntry=async e=>{
    // Snapshot the current editing state before switching entries (so user can undo back)
    pushMetaSnapNow(metaRef.current,fieldsRef.current,settingsRef.current,creditsRef.current,artStateRef.current);
    // Suppress any snap triggers that fire during the bulk state restore below
    suppressMetaSnap.current=true;
    setFieldsRaw({...DEFAULT_FIELDS,...e.labelFields});saveLS('tl_fields',{...DEFAULT_FIELDS,...e.labelFields});
    setSettingsRaw({...DEFAULT_SETTINGS,...e.labelSettings});saveLS('tl_settings',{...DEFAULT_SETTINGS,...e.labelSettings});
    // Always land on art when loading an entry — explicit label/classify actions override this
    if(e.artState){setArtState({...DEFAULT_ART_STATE,...e.artState});saveLS('tl_art_state',{...DEFAULT_ART_STATE,...e.artState});}
    setStudioSubTab('art');saveLS('tl_studio_sub','art');
    // Restore full albumArt from IDB if the entry used the "[stored]" sentinel
    let restoredMeta={...DEFAULT_METADATA,...e.metadata};
    if(e.hasArt&&restoredMeta.albumArt&&restoredMeta.albumArt.startsWith('[stored]')){
      try{
        let buf=await IDB.get(`art_${e.id}`,'assets');
        if(!buf)buf=await IDB.get(`art_${e.id}`,'blobs');
        if(buf){
          const blob=new Blob([buf],{type:'image/jpeg'});
          const dataUrl=await new Promise(res=>{const r=new FileReader();r.onload=ev=>res(ev.target.result);r.readAsDataURL(blob);});
          restoredMeta={...restoredMeta,albumArt:dataUrl};
        }
      }catch{}
    }
    setMetaRaw(restoredMeta);saveLS('tl_metadata',restoredMeta);
    setCreditsRaw(e.credits||[]);saveLS('tl_credits',e.credits||[]);
    setActiveEid(e.id);
    setAudioFile(e.hasAudio?{name:e.audioFilename,type:e.audioType,key:`audio_${e.id}`}:null);
    // Re-enable meta snapshots now that the load is complete
    requestAnimationFrame(()=>{suppressMetaSnap.current=false;});
    // Load audio into the element so it's ready, but do NOT set playingEid —
    // that only happens when the user explicitly presses Play.
    if(e.id!==activeEid){
      if(e.hasAudio){
        try{
          let buf=await IDB.get(`audio_${e.id}`,'assets');
          if(!buf)buf=await IDB.get(`audio_${e.id}`,'blobs');
          if(buf){
            const blob=new Blob([buf],{type:e.audioType||'audio/mpeg'});
            _setAudioUrl(URL.createObjectURL(blob));
            // Don't touch playingEid here — let onPlayPause set it
          }else{
            _setAudioUrl(null);setPlayingEid(null);
          }
        }catch{_setAudioUrl(null);setPlayingEid(null);}
      }else{
        _setAudioUrl(null);setPlayingEid(null);
      }
    }
  };
  // Keep loadEntryRef current so the audio 'ended' handler can call it without stale closure
  loadEntryRef.current=loadEntry;

  // ━━━━━━━━ UNDO / REDO RESTORE HANDLERS ━━━━━━━━
  // Metadata undo: restores meta, fields, settings, credits, artState from snapshot
  const doMetaUndo=useCallback(()=>{
    const snap=metaHistory.undo();
    if(!snap||!snap.meta)return; // null = uninitialised slot, skip
    suppressMetaSnap.current=true;
    setMetaRaw(snap.meta);saveLS('tl_metadata',snap.meta);
    setFieldsRaw(snap.fields);saveLS('tl_fields',snap.fields);
    setSettingsRaw(snap.settings);saveLS('tl_settings',snap.settings);
    setCreditsRaw(snap.credits);saveLS('tl_credits',snap.credits);
    if(snap.artState)setArtState(snap.artState);
    requestAnimationFrame(()=>{suppressMetaSnap.current=false;});
  },[metaHistory]);

  const doMetaRedo=useCallback(()=>{
    const snap=metaHistory.redo();
    if(!snap||!snap.meta)return;
    suppressMetaSnap.current=true;
    setMetaRaw(snap.meta);saveLS('tl_metadata',snap.meta);
    setFieldsRaw(snap.fields);saveLS('tl_fields',snap.fields);
    setSettingsRaw(snap.settings);saveLS('tl_settings',snap.settings);
    setCreditsRaw(snap.credits);saveLS('tl_credits',snap.credits);
    if(snap.artState)setArtState(snap.artState);
    requestAnimationFrame(()=>{suppressMetaSnap.current=false;});
  },[metaHistory]);

  // Catalog undo: restores entries, profiles, order maps from snapshot
  // NOTE: this restores the catalog list state only — audio/art blobs in IndexedDB
  // are NOT restored (we can't undelete files from disk). The entry record reappears
  // in the list but hasAudio/hasArt flags reflect whether blobs still exist.
  const doCatalogUndo=useCallback(()=>{
    const snap=catalogHistory.undo();
    if(!snap||!snap.entries)return; // null = uninitialised slot, skip
    suppressCatalogSnap.current=true;
    setEntriesRaw(snap.entries);saveLS('tl_entries',snap.entries);
    setProfilesRaw(snap.profiles);saveLS('tl_profiles',snap.profiles);
    setProfileOrderRaw(snap.profileOrder);saveLS('tl_profile_order',snap.profileOrder);
    setEntryManualOrderRaw(snap.entryManualOrder);saveLS('tl_entry_order',snap.entryManualOrder);
    requestAnimationFrame(()=>{suppressCatalogSnap.current=false;});
  },[catalogHistory]);

  const doCatalogRedo=useCallback(()=>{
    const snap=catalogHistory.redo();
    if(!snap||!snap.entries)return;
    suppressCatalogSnap.current=true;
    setEntriesRaw(snap.entries);saveLS('tl_entries',snap.entries);
    setProfilesRaw(snap.profiles);saveLS('tl_profiles',snap.profiles);
    setProfileOrderRaw(snap.profileOrder);saveLS('tl_profile_order',snap.profileOrder);
    setEntryManualOrderRaw(snap.entryManualOrder);saveLS('tl_entry_order',snap.entryManualOrder);
    requestAnimationFrame(()=>{suppressCatalogSnap.current=false;});
  },[catalogHistory]);

  const saveToEntry=()=>{
    if(!activeEid){alert('No archive entry selected. Open an entry from the Archive tab first.');return;}
    try{
      const changes={
        title:fields.title||meta.title||'',
        artist:fields.artist||meta.artist||'',
        metadata:{...meta,albumArt:meta.albumArt&&!meta.albumArt.startsWith('[stored]')?'[stored]':meta.albumArt},
        labelFields:{...fields},
        labelSettings:{...settings},
        artState:{...artState},
        studioSubTab,
        classCode:fields.classCode||'',
        credits:[...credits],
      };
      updateEntry(activeEid,changes);
      // Sync to disk immediately — compute sort index from current profile order
      const dir=rootDirRef.current;
      if(dir){
        const updatedEntry={...activeEntry,...changes,updated:todayStr()};
        const profEntries=getSortedEntriesForDisk().filter(e=>e.profileId===updatedEntry.profileId);
        const sortIndex=profEntries.findIndex(e=>e.id===activeEid);
        saveEntryNow(dir,profiles,updatedEntry,sortIndex>=0?sortIndex:0).then(newFolderName=>{
          if(newFolderName)updateEntryDiskName(activeEid,newFolderName);
          _saveCatalog(dir,profiles,getSortedEntriesForDisk());
        });
      }
      setTimeout(()=>setSavedFlash(false),1500);
    }catch(err){console.error('Save failed:',err);alert('Save failed: '+err.message);}
  };

  // ── AUTO-SAVE
  // saveRef always holds the freshest closure so the interval doesn't stale-capture
  const saveRef=useRef();
  const analysisQueueRef=useRef(Promise.resolve()); // serial queue — one analysis at a time
  saveRef.current=()=>{
    if(!activeEid)return;
    try{
      updateEntry(activeEid,{
        title:fields.title||meta.title||'',
        artist:fields.artist||meta.artist||'',
        metadata:{...meta,albumArt:meta.albumArt&&!meta.albumArt.startsWith('[stored]')?'[stored]':meta.albumArt},
        labelFields:{...fields},
        labelSettings:{...settings},
        artState:{...artState},
        studioSubTab,
        classCode:fields.classCode||'',
        credits:[...credits],
      });
      setAutoSaving(true);
      setTimeout(()=>setAutoSaving(false),1200);
    }catch(err){console.warn('Auto-save failed:',err);}
  };
  useEffect(()=>{
    if(!appTheme.playerAutoSave||!activeEid)return;
    const ms=(appTheme.playerAutoSaveInterval||60)*1000;
    const id=setInterval(()=>saveRef.current?.(),ms);
    return()=>clearInterval(id);
  },[appTheme.playerAutoSave,appTheme.playerAutoSaveInterval,activeEid]);

  // ── DISK AUTO-SAVE: ref always carries live rootDir, profiles, entries — no stale closures
  // We pass filteredEntries-style sorted arrays so _syncEntry gets correct sort indices per profile.
  // getSortedEntriesForDisk: returns all entries sorted by profile in UI display order.
  const getSortedEntriesForDisk=useCallback(()=>{
    // For each profile, apply the same manual order the UI uses, then concatenate
    const result=[];
    profiles.forEach(p=>{
      const profEntries=entries.filter(e=>e.profileId===p.id);
      const order=entryManualOrder[p.id]||[];
      const sorted=[...profEntries].sort((a,b)=>{
        const ai=order.indexOf(a.id),bi=order.indexOf(b.id);
        if(ai===-1&&bi===-1)return(b.updated||'').localeCompare(a.updated||'');
        if(ai===-1)return 1;if(bi===-1)return -1;
        return ai-bi;
      });
      result.push(...sorted);
    });
    return result;
  },[profiles,entries,entryManualOrder]);

  // updateEntryDiskName: stamps the new diskFolderName back onto an entry after a sync
  const updateEntryDiskName=useCallback((id,diskFolderName)=>{
    setEntriesRaw(es=>{
      const ns=es.map(e=>e.id===id?{...e,diskFolderName}:e);
      saveLS('tl_entries',ns);return ns;
    });
  },[]);

  diskSaveAllRef.current=()=>saveAll(rootDirRef.current,profiles,getSortedEntriesForDisk(),updateEntryDiskName);
  useEffect(()=>{
    if(!rootDir)return;
    const ms=(appTheme.diskSaveInterval||120)*1000;
    const id=setInterval(()=>diskSaveAllRef.current?.(),ms);
    return()=>clearInterval(id);
  },[rootDir,appTheme.diskSaveInterval]);


  const [fields,setFieldsRaw]=useState(()=>loadLS('tl_fields',DEFAULT_FIELDS));
  const [settings,setSettingsRaw]=useState(()=>loadLS('tl_settings',DEFAULT_SETTINGS));
  // setS and setF are declared below after meta/credits (they need scheduleMetaSnap and refs)
  const setFields=nf=>{setFieldsRaw(nf);saveLS('tl_fields',nf);};
  // ── STUDIO state
  const [studioSubTab,setStudioSubTab]=useState(()=>loadLS('tl_studio_sub','label'));
  const [artState,setArtState]=useState(()=>loadLS('tl_art_state',DEFAULT_ART_STATE));
  const setArt=useCallback(upd=>setArtState(s=>{const ns=typeof upd==='function'?upd(s):{...s,...upd};saveLS('tl_art_state',ns);return ns;}),[]);
  const [panelTab,setPanelTab]=useState('content');
  const [showBatch,setShowBatch]=useState(false);
  const [metaSection,setMetaSection]=useState('core');
  const [metaPanelDragOver,setMetaPanelDragOver]=useState(false);
  // ── METADATA — key fix: useCallback prevents remount by keeping setter reference stable
  const [meta,setMetaRaw]=useState(()=>loadLS('tl_metadata',DEFAULT_METADATA));
  // History-aware setMeta: schedules a debounced snapshot after each change
  const setMeta=useCallback((k,v)=>setMetaRaw(m=>{
    const nm={...m,[k]:v};saveLS('tl_metadata',nm);
    // Schedule snapshot using latest fields/settings/credits via refs (avoids stale closures)
    scheduleMetaSnap(nm,fieldsRef.current,settingsRef.current,creditsRef.current,artStateRef.current);
    return nm;
  }),[scheduleMetaSnap]);
  const setMetaObj=useCallback(obj=>setMetaRaw(m=>{const nm={...m,...obj};saveLS('tl_metadata',nm);return nm;}),[]);
  const resetMeta=()=>{
    pushMetaSnapNow(meta,fields,settings,credits,artState);
    setMetaRaw(DEFAULT_METADATA);saveLS('tl_metadata',DEFAULT_METADATA);
  };
  const [credits,setCreditsRaw]=useState(()=>loadLS('tl_credits',[]));
  const setCredits=cs=>{
    scheduleMetaSnap(meta,fields,settings,cs,artState);
    setCreditsRaw(cs);saveLS('tl_credits',cs);
  };

  // Always-current refs so history snapshot callbacks can read latest values without stale closures
  const fieldsRef=useRef(fields);
  const settingsRef=useRef(settings);
  const creditsRef=useRef(credits);
  const metaRef=useRef(meta);
  const artStateRef=useRef(artState);
  useEffect(()=>{fieldsRef.current=fields;},[fields]);
  useEffect(()=>{settingsRef.current=settings;},[settings]);
  useEffect(()=>{creditsRef.current=credits;},[credits]);
  useEffect(()=>{metaRef.current=meta;},[meta]);
  useEffect(()=>{artStateRef.current=artState;},[artState]);

  // Override setF and setS to also schedule meta snapshots
  const setFWithHistory=(k,v)=>{
    setFieldsRaw(f=>{const nf={...f,[k]:v};saveLS('tl_fields',nf);
      scheduleMetaSnap(metaRef.current,nf,settingsRef.current,creditsRef.current,artStateRef.current);
      return nf;});
  };
  const setSWithHistory=useCallback(upd=>setSettingsRaw(s=>{
    const ns=typeof upd==='function'?upd(s):{...s,...upd};saveLS('tl_settings',ns);
    scheduleMetaSnap(metaRef.current,fieldsRef.current,ns,creditsRef.current,artStateRef.current);
    return ns;
  }),[scheduleMetaSnap]);

  // Expose as setF / setS so all existing call sites work unchanged
  const setF=setFWithHistory;
  const setS=setSWithHistory;

  // ── ONE-SHOT SEED: populate both history stacks with real app state on first mount.
  // This replaces the null placeholder so cursor=0 always holds a valid restore point.
  // suppressCatalogSnap/suppressMetaSnap guards prevent the push helpers from firing
  // during undo/redo restores, but they're false here so the push goes through cleanly.
  const historiesSeededRef=useRef(false);
  useEffect(()=>{
    if(historiesSeededRef.current)return;
    historiesSeededRef.current=true;
    // Seed catalog history with real current state
    catalogHistory.push({
      entries:entries.map(e=>({...e,albumArtThumb:undefined})),
      profiles:[...profiles],
      profileOrder:[...profileOrder],
      entryManualOrder:{...entryManualOrder},
    });
    // Seed meta history with real current state
    metaHistory.push({
      meta:{...meta,albumArt:meta?.albumArt&&!meta.albumArt.startsWith('[stored]')?'[stored]':meta?.albumArt},
      fields:{...fields},
      settings:{...settings},
      credits:[...(credits||[])],
      artState:artState?JSON.parse(JSON.stringify(artState)):null,
    });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  },[]);// intentionally [] — runs once after first render when all state is initialised (debounced 1.5s)
  const metaAutoSaveTimer=useRef();
  useEffect(()=>{
    if(!activeEid)return;
    clearTimeout(metaAutoSaveTimer.current);
    metaAutoSaveTimer.current=setTimeout(()=>{
      updateEntry(activeEid,{
        title:meta.title||'',
        artist:meta.artist||'',
        metadata:{...meta,albumArt:meta.albumArt&&!meta.albumArt.startsWith('[stored]')?'[stored]':meta.albumArt},
      });
    },1500);
    return()=>clearTimeout(metaAutoSaveTimer.current);
  },[meta,activeEid]);

  // ── AUDIO
  const [audioFile,setAudioFile]=useState(null);
  const [audioObjectUrl,setAudioObjectUrl]=useState(null);
  const [lufsAnalyzing,setLufsAnalyzing]=useState(false);
  const audioRef=useRef();
  const audioElRef=useRef();
  // Tracks the live object URL so we can revoke it before creating a new one (memory-leak guard)
  const _activeObjectUrl=useRef(null);

  // ── DB BOOT + UNMOUNT CLEANUP
  useEffect(()=>{
    initDB().catch(err=>console.warn('[TrackLab] IndexedDB init failed:',err));
    return()=>{if(_activeObjectUrl.current)URL.revokeObjectURL(_activeObjectUrl.current);};
  },[]);

  // ── App-level playing state — mirrors the audioElRef element so any component can read it
  const [playing,setPlaying]=useState(false);
  const [playingEid,setPlayingEid]=useState(null); // which entry the audio element is actually playing
  // Always-current refs so the ended handler (in a [] effect) can read fresh state
  const playingEidRef=useRef(null);
  const entriesRef=useRef([]);
  const activePidRef=useRef(null);
  useEffect(()=>{playingEidRef.current=playingEid;},[playingEid]);
  useEffect(()=>{entriesRef.current=entries;},[entries]);
  useEffect(()=>{activePidRef.current=activePid;},[activePid]);

  useEffect(()=>{
    const el=audioElRef.current;if(!el)return;
    const onPlay=()=>setPlaying(true);
    const onPause=()=>setPlaying(false);
    const onEnd=async()=>{
      setPlaying(false);
      // Auto-advance: find the next entry in the current profile list
      const pid=activePidRef.current;
      const allEntries=entriesRef.current;
      const profList=allEntries
        .filter(e=>e.profileId===pid)
        .sort((a,b)=>(b.updated||'').localeCompare(a.updated||''));
      const curId=playingEidRef.current;
      const idx=profList.findIndex(e=>e.id===curId);
      if(idx===-1||idx>=profList.length-1)return; // no next track
      const next=profList[idx+1];
      // Load it and play
      await loadEntryRef.current(next);
      setPlayingEid(next.id);
      requestAnimationFrame(()=>requestAnimationFrame(()=>audioElRef.current?.play()));
    };
    el.addEventListener('play',onPlay);el.addEventListener('pause',onPause);el.addEventListener('ended',onEnd);
    return()=>{el.removeEventListener('play',onPlay);el.removeEventListener('pause',onPause);el.removeEventListener('ended',onEnd);};
  },[]); // audioElRef is stable — refs bypass stale closure

  // ── KEYBOARD SHORTCUTS: Space=play/pause, ←=−10s, →=+10s (ignored when typing)
  // Undo/redo (Ctrl+Z / Ctrl+Shift+Z) work globally but are context-aware:
  // archive tab → catalog history, all other tabs → meta history.
  useEffect(()=>{
    const onKey=e=>{
      // Undo / Redo — works even when not in an input
      const isUndo=(e.ctrlKey||e.metaKey)&&e.key==='z'&&!e.shiftKey;
      const isRedo=(e.ctrlKey||e.metaKey)&&(e.key==='y'||(e.key==='z'&&e.shiftKey));
      if(isUndo||isRedo){
        // Let the browser handle native text-field undo inside inputs/textareas
        if(['INPUT','TEXTAREA'].includes(e.target.tagName))return;
        e.preventDefault();
        const isCatalogTab=tab==='archive';
        if(isUndo){isCatalogTab?doCatalogUndo():doMetaUndo();}
        else{isCatalogTab?doCatalogRedo():doMetaRedo();}
        return;
      }
      if(['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName))return;
      const el=audioElRef.current;if(!el||!audioObjectUrl)return;
      if(e.code==='Space'){e.preventDefault();playing?el.pause():el.play();}
      else if(e.code==='ArrowRight'){e.preventDefault();el.currentTime=Math.min(el.duration||0,el.currentTime+10);}
      else if(e.code==='ArrowLeft'){e.preventDefault();el.currentTime=Math.max(0,el.currentTime-10);}
    };
    document.addEventListener('keydown',onKey);
    return()=>document.removeEventListener('keydown',onKey);
  },[playing,audioObjectUrl,tab,doCatalogUndo,doCatalogRedo,doMetaUndo,doMetaRedo]);

  // ── Centralised URL setter: always revokes the previous blob URL before setting the next
  const _setAudioUrl=url=>{
    if(_activeObjectUrl.current)URL.revokeObjectURL(_activeObjectUrl.current);
    _activeObjectUrl.current=url;
    setAudioObjectUrl(url);
  };

  // ── Full Audio Analysis — single-pass, pure JS, ITU-R BS.1770-4 / EBU R128 ──
  // Returns: { lufs, lra, samplePeak, crestFactor, dcOffset }
  //
  // SINGLE PASS DESIGN:
  //   For each channel, one loop advances the K-weighting biquad chain on every
  //   sample (preserving filter phase) and simultaneously accumulates:
  //     • K-weighted MS per 3-second block       → LUFS + LRA
  //     • Raw sum-of-squares                     → RMS → Crest Factor
  //     • Running max |sample|                   → Sample Peak
  //     • Running sum of raw samples             → DC Offset
  //   LRA needs a second pass over the block array (O(seconds/3)) — trivially cheap.
  //
  // K-weighted accumulator strides every 4th sample (±0.3 dB). Raw stats are
  // full-rate for maximum accuracy on peak and DC.
  // ── Full Audio Analysis — ITU-R BS.1770-4 / EBU R128 ──────────────────────
  // Uses OfflineAudioContext to run K-weighting filters natively (audio engine,
  // not JS), then computes gating + stats on the resulting buffer.
  // This is 5–10x faster than the pure-JS biquad loop for typical track lengths.
  const performFullAudioAnalysis=async audioBuffer=>{
    try{
      const sr=audioBuffer.sampleRate;
      const numCh=audioBuffer.numberOfChannels;
      const len=audioBuffer.length;

      // ── Step 1: K-weighting via OfflineAudioContext ───────────────────────────
      // Stage 1: high-shelf +4 dB @ 1500 Hz  Stage 2: high-pass 38 Hz Q=0.5
      // The audio engine runs these natively — no JS sample loop needed.
      const offCtx=new OfflineAudioContext(numCh,len,sr);
      const src=offCtx.createBufferSource();
      src.buffer=audioBuffer;

      // High-shelf biquad — +4 dB @ 1500 Hz
      const hs=offCtx.createBiquadFilter();
      hs.type='highshelf';hs.frequency.value=1500;hs.gain.value=4;

      // High-pass biquad — 38 Hz, Q=0.5
      const hp=offCtx.createBiquadFilter();
      hp.type='highpass';hp.frequency.value=38;hp.Q.value=0.5;

      src.connect(hs);hs.connect(hp);hp.connect(offCtx.destination);
      src.start(0);
      const kwBuf=await offCtx.startRendering();

      // ── Step 2: compute gating, peak, RMS, DC in JS (on K-weighted buffer) ──
      // LRA uses 3-second non-overlapping blocks per EBU R128
      const BLOCK_SAMPLES=Math.round(3*sr);
      const numBlocks=Math.ceil(len/BLOCK_SAMPLES);
      const blockKwSums=new Float64Array(numBlocks);
      let globalPeak=0,globalSumSq=0,globalDcSum=0;

      for(let c=0;c<numCh;c++){
        const kw=kwBuf.getChannelData(c);
        const raw=audioBuffer.getChannelData(c);
        for(let i=0;i<len;i++){
          // Raw stats from original (pre-filter) signal
          const s=raw[i];
          const absS=s<0?-s:s;
          if(absS>globalPeak)globalPeak=absS;
          globalSumSq+=s*s;
          globalDcSum+=s;
          // K-weighted MS accumulation into 3-second blocks
          const b=Math.floor(i/BLOCK_SAMPLES);
          blockKwSums[b]+=kw[i]*kw[i];
        }
      }
      // Normalise each block's sum to a per-sample mean across channels
      const samplesPerBlock=BLOCK_SAMPLES*numCh;
      for(let b=0;b<numBlocks;b++)blockKwSums[b]/=samplesPerBlock;

      const globalN=len*numCh;

      // ── Integrated LUFS — EBU R128 two-pass gating ───────────────────────────
      const ABS_GATE_LIN=Math.pow(10,(-70+0.691)/10);
      let p1Sum=0,p1Count=0;
      for(let b=0;b<numBlocks;b++){if(blockKwSums[b]>ABS_GATE_LIN){p1Sum+=blockKwSums[b];p1Count++;}}
      if(p1Count===0)return null;
      const p1Mean=p1Sum/p1Count;
      const REL_GATE_LIN=p1Mean*Math.pow(10,-10/10);
      let p2Sum=0,p2Count=0;
      for(let b=0;b<numBlocks;b++){if(blockKwSums[b]>ABS_GATE_LIN&&blockKwSums[b]>REL_GATE_LIN){p2Sum+=blockKwSums[b];p2Count++;}}
      if(p2Count===0)return null;
      const lufs=Math.round((-0.691+10*Math.log10(p2Sum/p2Count))*10)/10;

      // ── LRA (EBU R128) ───────────────────────────────────────────────────────
      const LRA_REL=p1Mean*Math.pow(10,-20/10);
      const blockLoudness=[];
      for(let b=0;b<numBlocks;b++){
        if(blockKwSums[b]>ABS_GATE_LIN&&blockKwSums[b]>LRA_REL)
          blockLoudness.push(-0.691+10*Math.log10(blockKwSums[b]));
      }
      let lra=0;
      if(blockLoudness.length>=2){
        blockLoudness.sort((a,b)=>a-b);
        const n=blockLoudness.length;
        lra=Math.round((blockLoudness[Math.floor(n*0.95)]-blockLoudness[Math.floor(n*0.10)])*10)/10;
      }

      // ── Sample Peak, RMS, Crest Factor, DC Offset ────────────────────────────
      const samplePeakDb=globalPeak>0?Math.round(20*Math.log10(globalPeak)*10)/10:null;
      const rms=globalN>0?Math.sqrt(globalSumSq/globalN):0;
      const crestFactor=(rms>0&&globalPeak>0)?Math.round(20*Math.log10(globalPeak/rms)*10)/10:0;
      const dcMean=globalN>0?globalDcSum/globalN:0;
      const dcOffset=globalPeak>0?Math.round((Math.abs(dcMean)/globalPeak)*1000)/10:0;

      // ── Stereo Consistency — phase correlation per 1-second window ───────────
      // Pearson correlation r = Σ(L·R) / √(Σ(L²)·Σ(R²)) per window.
      // Natural stereo oscillates widely; AI/locked stereo stays near constant.
      // Static: stddev < 0.05, mean > 0.85  →  suspiciously locked field
      // Blurred: mean near 0, stddev < 0.08  →  constant artificial widening
      let stereoCorrelation='N/A (mono)';
      let aiProbabilityScore=0;

      if(numCh>=2){
        const chL=audioBuffer.getChannelData(0);
        const chR=audioBuffer.getChannelData(1);
        const STEREO_WIN=Math.round(sr); // 1-second windows
        const numWins=Math.floor(len/STEREO_WIN);
        const corrPerWindow=new Float32Array(numWins);

        for(let w=0;w<numWins;w++){
          const start=w*STEREO_WIN;
          let sumLR=0,sumLL=0,sumRR=0;
          for(let i=start;i<start+STEREO_WIN;i++){
            sumLR+=chL[i]*chR[i];
            sumLL+=chL[i]*chL[i];
            sumRR+=chR[i]*chR[i];
          }
          const denom=Math.sqrt(sumLL*sumRR);
          corrPerWindow[w]=denom>0?(sumLR/denom):1;
        }

        let corrSum=0;
        for(let w=0;w<numWins;w++) corrSum+=corrPerWindow[w];
        const corrMean=numWins>0?corrSum/numWins:1;

        let corrVarSum=0;
        for(let w=0;w<numWins;w++){const d=corrPerWindow[w]-corrMean;corrVarSum+=d*d;}
        const corrStdDev=Math.sqrt(numWins>1?corrVarSum/(numWins-1):0);

        const corrMeanR=Math.round(corrMean*100)/100;
        const corrStdDevR=Math.round(corrStdDev*1000)/1000;

        // Thresholds calibrated against real-world stereo masters:
        //   Natural music stddev typically 0.15–0.45
        //   AI/locked stereo stddev often < 0.05
        //   Blurred (constant widener) mean near 0 with low variance
        const isStatic=(corrStdDev<0.05&&corrMean>0.85);
        const isBlurred=(Math.abs(corrMean)<0.15&&corrStdDev<0.08);

        let stereoLabel;
        if(isStatic)         stereoLabel='Static';
        else if(isBlurred)   stereoLabel='Blurred';
        else if(corrMean>0.7)stereoLabel='Wide-Mono';
        else if(corrMean>0.3)stereoLabel='Natural';
        else if(corrMean>-0.1)stereoLabel='Wide';
        else                 stereoLabel='Out-of-Phase';

        stereoCorrelation=corrMeanR+' / \u03c3 '+corrStdDevR+' \u2014 '+stereoLabel;

        if(isStatic)  aiProbabilityScore+=45;
        if(isBlurred) aiProbabilityScore+=35;
        if(isStatic&&corrMean>0.97) aiProbabilityScore+=15;
      }

      // ── Run AI artifact scan (spectral ceiling + neural compression) ──────────
      const aiScan=await detectAiArtifacts(audioBuffer);
      if(aiScan&&aiScan.aiArtifact&&aiScan.aiArtifact.startsWith('\u26a0'))aiProbabilityScore+=30;
      const aiProbabilityFinal=Math.min(99,aiProbabilityScore);

      // Build human-readable probability label
      let probLabel;
      if(aiProbabilityFinal===0)       probLabel='\u2713 Low (0%)';
      else if(aiProbabilityFinal<25)   probLabel='Low ('+aiProbabilityFinal+'%)';
      else if(aiProbabilityFinal<50)   probLabel='\u25c6 Moderate ('+aiProbabilityFinal+'%)';
      else if(aiProbabilityFinal<75)   probLabel='\u26a0 Elevated ('+aiProbabilityFinal+'%)';
      else                              probLabel='\u26d4 High ('+aiProbabilityFinal+'%)';

      return{
        lufs:String(lufs),lra:String(lra),
        samplePeak:samplePeakDb!==null?`${samplePeakDb} dBFS`:'-\u221e dBFS',
        crestFactor:`${crestFactor} dB`,dcOffset:`${dcOffset}%`,
        stereoCorrelation,
        aiArtifact:aiScan?aiScan.aiArtifact:'',
        spectralCeiling:aiScan?aiScan.spectralCeiling:'',
        aiProbability:probLabel,
      };
    }catch(e){console.warn('Audio analysis error:',e);return null;}
  };

  // ── AI Artifact Scan — Spectral Ceiling & Neural Compression Detection ──────
  // Uses an OfflineAudioContext + AnalyserNode to snapshot frequency-domain energy,
  // then detects a hard 40dB+ spectral drop above 8kHz (neural codec cliff).
  const detectAiArtifacts=async audioBuffer=>{
    try{
      const sr=audioBuffer.sampleRate;
      if(sr<34000) return{aiArtifact:'N/A (low SR)',spectralCeiling:'N/A'};

      const FFT_SIZE=16384;
      const fftHalf=FFT_SIZE/2;

      // Downmix to mono for speed — spectral shape is channel-agnostic
      const offCtx=new OfflineAudioContext(1,Math.min(audioBuffer.length,sr*10),sr);
      const src=offCtx.createBufferSource();

      if(audioBuffer.numberOfChannels>1){
        const mono=offCtx.createBuffer(1,audioBuffer.length,sr);
        const out=mono.getChannelData(0);
        const scale=1/audioBuffer.numberOfChannels;
        for(let c=0;c<audioBuffer.numberOfChannels;c++){
          const ch=audioBuffer.getChannelData(c);
          for(let i=0;i<audioBuffer.length;i++) out[i]+=ch[i]*scale;
        }
        src.buffer=mono;
      }else{
        src.buffer=audioBuffer;
      }

      const analyser=offCtx.createAnalyser();
      analyser.fftSize=FFT_SIZE;
      analyser.smoothingTimeConstant=0;
      src.connect(analyser);
      analyser.connect(offCtx.destination);
      src.start(0);
      await offCtx.startRendering();

      const freqData=new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(freqData);

      // Convert analyser Uint8 magnitude to dBFS (analyser default range -100 to 0 dBFS)
      const toDB=function(byte){return byte===0?-100:(byte/255)*100-100;};
      const binHz=sr/FFT_SIZE;
      const freqToBin=function(hz){return Math.min(Math.round(hz/binHz),fftHalf-1);};

      const bandEnergy=function(loHz,hiHz){
        const lo=freqToBin(loHz);
        const hi=freqToBin(hiHz);
        if(hi<=lo) return -100;
        let sum=0;
        for(let b=lo;b<=hi;b++) sum+=toDB(freqData[b]);
        return sum/(hi-lo+1);
      };

      // 1. Spectral Ceiling — average energy 16kHz → Nyquist
      const nyquist=sr/2;
      const ceilingDb=bandEnergy(16000,nyquist);
      const ceilingStr=ceilingDb.toFixed(1)+' dBFS';

      // 2. Neural Compression — scan for 40dB+ cliff from 8kHz upward in 500Hz bands
      const BAND_W=500;
      let artifactFreq=null;
      let prevEnergy=bandEnergy(8000,8000+BAND_W);
      for(let f=8000+BAND_W;f<nyquist-BAND_W;f+=BAND_W){
        const curEnergy=bandEnergy(f,f+BAND_W);
        if(prevEnergy-curEnergy>=40){artifactFreq=f;break;}
        prevEnergy=curEnergy;
      }

      let aiArtifact;
      if(artifactFreq!==null){
        aiArtifact='\u26a0 Neural Compression @ '+(artifactFreq/1000).toFixed(1)+'kHz';
      }else if(ceilingDb<-80){
        aiArtifact='\u26a0 Spectral Ceiling Detected (>16kHz absent)';
      }else{
        aiArtifact='\u2713 No Artifact Detected';
      }

      return{aiArtifact,spectralCeiling:ceilingStr};
    }catch(e){
      console.warn('AI artifact scan failed:',e);
      return{aiArtifact:'Scan Error',spectralCeiling:'\u2013'};
    }
  };

  const loadAudioFile=async file=>{
    if(!file)return;
    // ── Full reset: clear ALL metadata fields so no ghost data from previous track ──
    // Analysis fields + all tag fields. Only persists after jsmediatags fills what it finds.
    setMetaRaw(m=>{
      const nm={...DEFAULT_METADATA,lufs:'',lra:'',samplePeak:'',crestFactor:'',dcOffset:'',
        stereoCorrelation:'',aiArtifact:'',spectralCeiling:'',aiProbability:'',
        // preserve artwork and notes only if we already have an active entry loaded
        albumArt:'',notes:''};
      saveLS('tl_metadata',nm);
      return nm;
    });
    const buf=await file.arrayBuffer();
    const key=activeEid?`audio_${activeEid}`:'audio_scratch';
    await IDB.set(key,buf,'assets'); // write to canonical 'assets' store
    const af={name:file.name,type:file.type,size:file.size,key};
    setAudioFile(af);
    if(activeEid)updateEntry(activeEid,{hasAudio:true,audioFilename:file.name,audioType:file.type});
    // Revoke previous URL before creating the new one — prevents memory leaks
    const blob=new Blob([buf],{type:file.type});
    _setAudioUrl(URL.createObjectURL(blob));
    setPlayingEid(activeEid||null);
    // ── Write audio to disk library immediately (non-blocking)
    if(activeEid&&rootDir){
      const currentEntry=entries.find(e=>e.id===activeEid);
      if(currentEntry){
        const profEntries=getSortedEntriesForDisk().filter(e=>e.profileId===currentEntry.profileId);
        const sortIndex=profEntries.findIndex(e=>e.id===activeEid);
        saveEntryNow(rootDirRef.current,profiles,{...currentEntry,hasAudio:true,audioFilename:file.name,audioType:file.type},sortIndex>=0?sortIndex:0)
          .then(newFolderName=>{if(newFolderName)updateEntryDiskName(activeEid,newFolderName);})
          .catch(()=>{});
      }
    }
    // ── Full audio analysis (non-blocking via setTimeout yield inside function) ──
    setLufsAnalyzing(true);
    try{
      const audioContext=new (window.AudioContext||window.webkitAudioContext)();
      const arrayBuffer=await file.arrayBuffer(); // fresh read — decodeAudioData detaches it
      const decoded=await audioContext.decodeAudioData(arrayBuffer);
      audioContext.close();
      const analysis=await performFullAudioAnalysis(decoded);
      if(analysis){
        const date=new Date().toISOString().slice(0,10);
        const stamp=`[ANALYSIS] ${file.name} · ${date} | LUFS: ${analysis.lufs} · LRA: ${analysis.lra} LU · Peak: ${analysis.samplePeak} · Crest: ${analysis.crestFactor} · DC: ${analysis.dcOffset}`;
        setMetaRaw(m=>{
          const existing=m.notes||'';
          // Replace previous stamp for this file rather than stack duplicates
          const filtered=existing.split('\n').filter(l=>!l.includes(`] ${file.name} \u00b7`)).join('\n');
          const newNotes=stamp+(filtered?'\n'+filtered:'');
          const nm={...m,...analysis,notes:newNotes};
          saveLS('tl_metadata',nm);
          return nm;
        });
      }
    }catch(e){console.warn('Audio analysis failed:',e);}
    finally{setLufsAnalyzing(false);}
    // Read tags if jsmediatags is available
    if(typeof jsmediatags!=='undefined'){
      jsmediatags.read(file,{
        onSuccess(tag){
          const t=tag.tags,ch={};
          if(t.title&&!meta.title)ch.title=t.title;
          if(t.artist&&!meta.artist)ch.artist=t.artist;
          if(t.album&&!meta.album)ch.album=t.album;
          if(t.year&&!meta.year)ch.year=String(t.year);
          if(t.genre&&!meta.genre)ch.genre=t.genre;
          if(t.track)ch.trackNum=String(t.track).split('/')[0];
          if(t.comment?.text&&!meta.comment)ch.comment=t.comment.text;
          if(Object.keys(ch).length)setMetaObj(ch);
          if(t.picture){
            const bytes=new Uint8Array(t.picture.data);
            const b64=btoa(bytes.reduce((a,b)=>a+String.fromCharCode(b),''));
            setMetaObj({albumArt:`data:${t.picture.format};base64,${b64}`});
          }
        },onError(){}
      });
    }
  };

  const recalculateAnalysis=async()=>{
    if(!audioFile?.key||lufsAnalyzing)return;
    setLufsAnalyzing(true);
    setMetaRaw(m=>{const nm={...m,lufs:'',lra:'',samplePeak:'',crestFactor:'',dcOffset:'',stereoCorrelation:'',aiArtifact:'',spectralCeiling:'',aiProbability:''};saveLS('tl_metadata',nm);return nm;});
    try{
      const buf=await IDB.get(audioFile.key,'assets');
      if(!buf)throw new Error('Audio not in IDB');
      const audioContext=new (window.AudioContext||window.webkitAudioContext)();
      const decoded=await audioContext.decodeAudioData(buf.slice(0));
      audioContext.close();
      const analysis=await performFullAudioAnalysis(decoded);
      if(analysis){
        const date=new Date().toISOString().slice(0,10);
        const name=audioFile.name;
        const stamp=`[ANALYSIS] ${name} · ${date} | LUFS: ${analysis.lufs} · LRA: ${analysis.lra} LU · Peak: ${analysis.samplePeak} · Crest: ${analysis.crestFactor} · DC: ${analysis.dcOffset}`;
        setMetaRaw(m=>{
          const filtered=(m.notes||'').split('\n').filter(l=>!l.includes(`] ${name} \u00b7`)).join('\n');
          const nm={...m,...analysis,notes:stamp+(filtered?'\n'+filtered:'')};
          saveLS('tl_metadata',nm);return nm;
        });
      }
    }catch(e){console.warn('Recalculate failed:',e);}
    finally{setLufsAnalyzing(false);}
  };

  const exportTaggedAudio=async()=>{
    const key=activeEid?`audio_${activeEid}`:'audio_scratch';
    const buf=await IDB.get(key);
    if(!buf){alert('No audio file loaded. Upload an audio file in Tags → Audio File first.');return;}
    if(typeof ID3Writer==='undefined'){alert('ID3 writer not loaded. Please check your internet connection.');return;}
    try{
      const writer=new ID3Writer(buf);
      if(meta.title)writer.setFrame('TIT2',meta.title);
      if(meta.artist)writer.setFrame('TPE1',[meta.artist]);
      if(meta.albumArtist)writer.setFrame('TPE2',meta.albumArtist);
      if(meta.album)writer.setFrame('TALB',meta.album);
      if(meta.year)writer.setFrame('TYER',meta.year);
      if(meta.genre)writer.setFrame('TCON',[meta.genre]);
      if(meta.trackNum)writer.setFrame('TRCK',meta.trackTotal?`${meta.trackNum}/${meta.trackTotal}`:meta.trackNum);
      if(meta.discNum)writer.setFrame('TPOS',meta.discTotal?`${meta.discNum}/${meta.discTotal}`:meta.discNum);
      if(meta.bpm)writer.setFrame('TBPM',+meta.bpm||0);
      if(meta.isrc)writer.setFrame('TSRC',meta.isrc.replace(/-/g,''));
      if(meta.composer)writer.setFrame('TCOM',[meta.composer]);
      if(meta.publisher)writer.setFrame('TPUB',meta.publisher);
      if(meta.copyright)writer.setFrame('TCOP',meta.copyright);
      if(meta.language)writer.setFrame('TLAN',meta.language);
      if(meta.comment)writer.setFrame('COMM',{description:'',text:meta.comment});
      if(meta.upc)writer.setFrame('TXXX',{description:'UPC',value:meta.upc});
      if(meta.iswc)writer.setFrame('TXXX',{description:'ISWC',value:meta.iswc});
      if(meta.mood)writer.setFrame('TXXX',{description:'MOOD',value:meta.mood});
      if(meta.producer)writer.setFrame('TXXX',{description:'PRODUCER',value:meta.producer});
      if(meta.albumArt&&!meta.albumArt.startsWith('[stored]')){
        const res=await fetch(meta.albumArt);const artBuf=await res.arrayBuffer();
        writer.setFrame('APIC',{type:3,data:artBuf,description:'Cover',useUnicodeEncoding:false});
      }
      writer.addTag();
      const blob=writer.getBlob();
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');a.href=url;
      const base=audioFile?.name||`${meta.title||'track'}.mp3`;
      const dot=base.lastIndexOf('.');
      a.download=dot>0?`${base.slice(0,dot)}-tagged${base.slice(dot)}`:`${base}-tagged.mp3`;
      a.click();setTimeout(()=>URL.revokeObjectURL(url),3000);
    }catch(err){console.error(err);alert('Tag embedding failed. MP3 (ID3v2) only. For FLAC/WAV/AIFF use a dedicated tagger (Metaflac, bwfmetaedit, etc).');}
  };

  // ── ALBUM ART
  const artRef=useRef();
  const loadAlbumArt=file=>{
    if(!file||!file.type.startsWith('image/'))return;
    const r=new FileReader();
    r.onload=e=>{
      const img=new Image();img.onload=()=>{
        const sz=+meta.albumArtSize||3000;
        const c=document.createElement('canvas');c.width=sz;c.height=sz;
        const ctx=c.getContext('2d');
        const side=Math.min(img.width,img.height);
        const ox=(img.width-side)/2,oy=(img.height-side)/2;
        ctx.drawImage(img,ox,oy,side,side,0,0,sz,sz);
        const data=c.toDataURL('image/jpeg',0.92);
        setMetaObj({albumArt:data});
        if(activeEid){c.toBlob(async blob=>{const buf=await blob.arrayBuffer();await IDB.set(`art_${activeEid}`,buf);const thumb=c.toDataURL('image/jpeg',0.3);updateEntry(activeEid,{hasArt:true,albumArtThumb:thumb});});}
      };img.src=e.target.result;
    };r.readAsDataURL(file);
  };

  // ━━━━━━━━ LABEL TAB — ID3 AUTO-FILL ━━━━━━━━
  // Reads ID3 tags from any audio file and fills label fields + BPM meta row.
  // Non-destructive: only overwrites fields that are currently blank.
  const labelTagFileRef=useRef();
  // null | 'reading' | {found:{title,artist,bpm}, filled:{title,artist,bpm}} | {err:string}
  const [labelTagStatus,setLabelTagStatus]=useState(null);

  const readLabelTags=file=>{
    if(!file||typeof jsmediatags==='undefined'){setLabelTagStatus({err:'jsmediatags not available'});return;}
    setLabelTagStatus('reading');
    jsmediatags.read(file,{
      onSuccess(tag){
        const t=tag.tags;
        // Collect what the file actually has
        const found={
          title:t.title||'',
          artist:t.artist||'',
          // BPM may live in various frames; TBPM is standard
          bpm:t.TBPM?.data||t.bpm||''
        };
        // Track what we actually wrote (skip if field already has content)
        const filled={title:false,artist:false,bpm:false};
        if(found.title&&!fields.title){setF('title',found.title);filled.title=true;}
        if(found.artist&&!fields.artist){setF('artist',found.artist);filled.artist=true;}
        if(found.bpm){
          // Find the BPM meta row field (label match, case-insensitive) and fill if blank
          setS(s=>{
            const mf=(s.metaFields||[]).map(f=>{
              if(f.label.toUpperCase()==='BPM'&&!f.value){filled.bpm=true;return{...f,value:String(found.bpm)};}
              return f;
            });
            return{...s,metaFields:mf};
          });
          // Mark filled after the setS closes — check synchronously via current state
          if(!settings.metaFields?.find(f=>f.label.toUpperCase()==='BPM'&&f.value))filled.bpm=true;
        }
        setLabelTagStatus({found,filled});
      },
      onError(err){setLabelTagStatus({err:err.type||'Could not read tags — file may have no ID3 data'});}
    });
  };

  // ── CLASSIFY
  const [sel,setSel]=useState({digit1:'',digit2:'',digit3:'',digit4:''});
  const [genCode,setGenCode]=useState('');
  const [savedCodes,setSavedCodesRaw]=useState(()=>loadLS('tl_codes',[]));
  const setSavedCodes=cs=>{setSavedCodesRaw(cs);saveLS('tl_codes',cs);};
  const [copied,setCopied]=useState(false);
  const [showGuide,setShowGuide]=useState(false);
  const [decInput,setDecInput]=useState('');
  const [decResult,setDecResult]=useState(null);

  const buildCode=(ov={})=>{const v={...sel,...ov};const pick=(opts,key)=>{const ks=Object.keys(opts);return v[key]||(ks[Math.floor(Math.random()*ks.length)]);};return`${pick(CLS.digit1.options,'digit1')}${pick(CLS.digit2.options,'digit2')}${pick(CLS.digit3.options,'digit3')}.${pick(CLS.digit4.options,'digit4')}`;};
  const generateCode=()=>setGenCode(buildCode());
  const randomGenerate=()=>{setSel({digit1:'',digit2:'',digit3:'',digit4:''});setGenCode(buildCode({digit1:'',digit2:'',digit3:'',digit4:''}));};
  const decodeCode=()=>{
    const clean=decInput.trim().replace(/\s/g,'').toUpperCase();
    const m=clean.match(/^([0-9A-Z])([0-9A-Z])([0-9A-Z])\.([0-9A-Z])$/);
    if(!m){setDecResult({valid:false,error:'Expected: XXX.X (e.g. 142.7 or S3K.F)'});return;}
    const[,d1,d2,d3,d4]=m;
    setDecResult({valid:true,code:clean,full:getCodeDesc(clean),bd:[
      {p:'1',v:d1,cat:CLS.digit1.name,m:CLS.digit1.options[d1]||'Unknown'},
      {p:'2',v:d2,cat:CLS.digit2.name,m:CLS.digit2.options[d2]||'Unknown'},
      {p:'3',v:d3,cat:CLS.digit3.name,m:CLS.digit3.options[d3]||'Unknown'},
      {p:'4',v:d4,cat:CLS.digit4.name,m:CLS.digit4.options[d4]||'Unknown'},
    ]});
  };
  const saveCode=()=>{if(genCode&&!savedCodes.find(c=>c.code===genCode))setSavedCodes([...savedCodes,{code:genCode,desc:getCodeDesc(genCode),saved:todayStr()}]);};
  const sendToLabel=code=>{setF('classCode',code);setF('classDesc',getCodeDesc(code));setS({showClass:true});setTab('studio');setStudioSubTab('label');saveLS('tl_studio_sub','label');};
  const exportGuide=()=>{let g='TRACK LAB — CLASSIFICATION GUIDE\n'+'='.repeat(50)+'\n\n';Object.entries(CLS).forEach(([k,d])=>{g+=`Position ${k.replace('digit','')}: ${d.name}\n`+'─'.repeat(40)+'\n';Object.entries(d.options).forEach(([n,dd])=>g+=`  ${n.padEnd(3)} — ${dd}\n`);g+='\n';});const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([g],{type:'text/plain'}));a.download='tracklab-classification-guide.txt';a.click();};

  // ── PRESETS
  const [presets,setPresetsRaw]=useState(()=>loadLS('tl_presets',[]));
  const setPresets=ps=>{setPresetsRaw(ps);saveLS('tl_presets',ps);};
  const [lastPid,setLastPid]=useState(()=>loadLS('tl_last_preset',null));

  // ── LABEL EXPORT
  const [exporting,setExporting]=useState(false);
  const [exportMsg,setExportMsg]=useState('');
  const exportLabel=async()=>{
    setExporting(true);setExportMsg('Rendering…');
    const wrap=document.createElement('div');wrap.style.cssText=`position:fixed;left:-99999px;top:0;width:${settings.labelW}px;overflow:visible;pointer-events:none;z-index:-1;`;
    document.body.appendChild(wrap);const el=document.createElement('div');wrap.appendChild(el);
    await new Promise(res=>ReactDOM.render(React.createElement(TrackLabel,{fields,settings}),el,res));
    await new Promise(r=>setTimeout(r,120));
    try{
      const sc=getColors(settings);
      const canvas=await html2canvas(el.firstChild||el,{scale:settings.exportScale,width:settings.labelW,height:settings.labelH,useCORS:true,allowTaint:true,backgroundColor:sc.bg||'#fff',logging:false});
      const fmt=settings.exportFormat,mime=fmt==='jpeg'?'image/jpeg':'image/png',ext=fmt==='jpeg'?'jpg':'png';
      const url=canvas.toDataURL(mime,fmt==='jpeg'?0.95:undefined);
      const slug=(fields.title||'track').replace(/\s+/g,'-').toLowerCase();
      const a=document.createElement('a');a.href=url;a.download=`label-${slug}.${ext}`;a.click();
      setExportMsg(`✓ ${canvas.width}×${canvas.height}px`);setTimeout(()=>setExportMsg(''),5000);
    }catch{setExportMsg('Export failed');}
    finally{ReactDOM.unmountComponentAtNode(el);document.body.removeChild(wrap);setExporting(false);}
  };

  // ── ARCHIVE EXPORTS
  const exportImportRef=useRef();
  const exportCSV=()=>{
    const pm=Object.fromEntries(profiles.map(p=>[p.id,p.name]));
    const cols=['ID','Profile','Title','Artist','Album','Year','Genre','BPM','Key','ISRC','UPC','Class Code','Status','Has Audio','Has Art','Credits','Created','Updated'];
    const rows=entries.map(e=>{
      const credStr=(e.credits||[]).map(c=>`${c.name||'—'} (${c.role}) ${parseFloat(c.split)||0}%`).join(' | ');
      return[e.id,pm[e.profileId]||'',e.title||'',e.artist||'',e.metadata?.album||'',e.metadata?.year||'',e.metadata?.genre||'',e.metadata?.bpm||'',e.metadata?.key||'',e.metadata?.isrc||'',e.metadata?.upc||'',e.classCode||'',e.status||'draft',e.hasAudio?'Yes':'No',e.hasArt?'Yes':'No',credStr,e.created||'',e.updated||''];
    });
    const csv=[cols,...rows].map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
    const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));a.download=`tracklab-${todayStr()}.csv`;a.click();
  };
  const exportJSON=()=>{
    const payload={app:'tracklab',version:VERSION,exportedAt:new Date().toISOString(),profiles,entries:entries.map(e=>({...e,albumArtThumb:undefined}))};
    const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([JSON.stringify(payload,null,2)],{type:'application/json'}));a.download=`tracklab-backup-${todayStr()}.json`;a.click();
  };
  const importJSON=async file=>{
    try{
      const d=JSON.parse(await file.text());
      if(d.profiles)setProfiles([...profiles,...d.profiles.filter(p=>!profiles.find(x=>x.id===p.id))]);
      if(d.entries)setEntries([...entries,...d.entries.filter(e=>!entries.find(x=>x.id===e.id))]);
      alert(`✓ Imported ${d.profiles?.length||0} profiles, ${d.entries?.length||0} entries`);
    }catch{alert('Invalid backup file. Expecting Track Lab JSON format.');}
  };
  const exportZIP=async()=>{
    if(typeof JSZip==='undefined'){alert('JSZip not loaded');return;}
    setZipping(true);
    try{
      const zip=new JSZip();const pm=Object.fromEntries(profiles.map(p=>[p.id,p.name]));
      zip.file('_manifest.json',JSON.stringify({app:'tracklab',version:VERSION,exportedAt:new Date().toISOString(),profiles,totalEntries:entries.length},null,2));
      for(const e of entries){
        const folderName=`${pm[e.profileId]||'unknown'}/${(e.artist||'artist').replace(/[^a-z0-9]/gi,'_')}__${(e.title||e.id).replace(/[^a-z0-9]/gi,'_')}`;
        const f=zip.folder(folderName);
        f.file('metadata.json',JSON.stringify({...e,albumArtThumb:undefined},null,2));
        // Use STORE (no compression) for audio/art — they're already compressed formats
        if(e.hasAudio){try{const buf=await IDB.get(`audio_${e.id}`);if(buf)f.file(e.audioFilename||'audio.mp3',buf,{compression:'STORE'});}catch{}}
        if(e.hasArt){try{const buf=await IDB.get(`art_${e.id}`);if(buf)f.file('artwork.jpg',buf,{compression:'STORE'});}catch{}}
      }
      const blob=await zip.generateAsync({type:'blob',compression:'DEFLATE',compressionOptions:{level:3}});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download=`tracklab-archive-${todayStr()}.zip`;a.click();
    }catch(err){console.error(err);alert('ZIP export failed: '+err.message);}
    finally{setZipping(false);}
  };

  // ── CSV IMPORT
  const csvImportRef=useRef();
  const importCSV=async file=>{
    if(!activePid){alert('Select a profile first before importing CSV entries.');return;}
    try{
      const text=await file.text();
      const lines=text.split(/\r?\n/).filter(Boolean);
      if(lines.length<2){alert('CSV must have a header row and at least one data row.');return;}
      // Simple CSV parser — handles quoted fields
      const parseRow=row=>{const out=[];let cur='',inQ=false;for(let i=0;i<row.length;i++){const ch=row[i];if(ch==='"'){if(inQ&&row[i+1]==='"'){cur+='"';i++;}else inQ=!inQ;}else if(ch===','&&!inQ){out.push(cur.trim());cur='';}else cur+=ch;}out.push(cur.trim());return out;};
      const headers=parseRow(lines[0]).map(h=>h.replace(/^"|"$/g,'').toLowerCase().replace(/\s+/g,''));
      const col=key=>headers.indexOf(key);
      const get=(row,key)=>{const i=col(key);return i>=0?(row[i]||'').replace(/^"|"$/g,''):'';};
      const newEntries=[];
      for(let i=1;i<lines.length;i++){
        const row=parseRow(lines[i]);
        if(!row.some(Boolean))continue;
        const title=get(row,'title')||`Imported ${i}`;
        const artist=get(row,'artist');
        const status=STATUS_OPT[get(row,'status')]?get(row,'status'):'draft';
        const classCode=get(row,'classcode')||get(row,'code')||'';
        const bpm=get(row,'bpm');const key=get(row,'key');const genre=get(row,'genre');
        const year=get(row,'year');const isrc=get(row,'isrc');const upc=get(row,'upc');
        const e={
          id:mkUid(),profileId:activePid,title,artist,created:todayStr(),updated:todayStr(),status,
          classCode,hasAudio:false,hasArt:false,audioFilename:'',audioType:'',albumArtThumb:null,
          metadata:{...DEFAULT_METADATA,title,artist,bpm,key,genre,year,isrc,upc},
          labelFields:{...DEFAULT_FIELDS,title,artist,classCode,isrc,upc},
          labelSettings:{...DEFAULT_SETTINGS},
        };
        newEntries.push(e);
      }
      if(!newEntries.length){alert('No valid rows found in CSV.');return;}
      setEntries([...entries,...newEntries]);
      alert(`✓ Imported ${newEntries.length} entr${newEntries.length===1?'y':'ies'} into "${profiles.find(p=>p.id===activePid)?.name||'selected profile'}"`);
    }catch(err){console.error(err);alert('CSV import failed: '+err.message);}
    finally{if(csvImportRef.current)csvImportRef.current.value='';}
  };

  // ── ARCHIVE LABEL EXPORT (renders off-screen)
  const [archiveLabelExport,setArchiveLabelExport]=useState(null); // {fields, settings, title}
  const archiveLabelRef=useRef();
  const [archiveLabelExporting,setArchiveLabelExporting]=useState(false);
  useEffect(()=>{
    if(!archiveLabelExport||!archiveLabelRef.current)return;
    const run=async()=>{
      setArchiveLabelExporting(true);
      await new Promise(r=>setTimeout(r,150));
      try{
        const el=archiveLabelRef.current.firstChild;
        if(!el)return;
        const sc=getColors(archiveLabelExport.settings);
        const canvas=await html2canvas(el,{scale:archiveLabelExport.settings.exportScale||2,width:archiveLabelExport.settings.labelW,height:archiveLabelExport.settings.labelH,useCORS:true,allowTaint:true,backgroundColor:sc.bg||'#fff',logging:false});
        const fmt=archiveLabelExport.settings.exportFormat||'png';
        const mime=fmt==='jpeg'?'image/jpeg':'image/png',ext=fmt==='jpeg'?'jpg':'png';
        const url=canvas.toDataURL(mime,fmt==='jpeg'?0.95:undefined);
        const slug=(archiveLabelExport.title||'track').replace(/\s+/g,'-').toLowerCase();
        const a=document.createElement('a');a.href=url;a.download=`label-${slug}.${ext}`;a.click();
      }catch(err){console.error('Archive label export:',err);alert('Label export failed.');}
      finally{setArchiveLabelExporting(false);setArchiveLabelExport(null);}
    };
    run();
  },[archiveLabelExport]);

  // ━━━━━━━━ BATCH LABEL EXPORT ━━━━━━━━
  const [batchIds,setBatchIds]=useState(new Set());
  const [batchScale,setBatchScale]=useState(2);
  const [batchRunning,setBatchRunning]=useState(false);
  // null while idle; {done,total,currentTitle} while running
  const [batchProgress,setBatchProgress]=useState(null);
  // [{id, title, ok, msg?}] — one row per processed entry
  const [batchLog,setBatchLog]=useState([]);
  const [batchPidFilter,setBatchPidFilter]=useState('all');

  // Entries visible in the batch checklist, filtered by profile
  const batchVisibleEntries=useMemo(()=>
    (batchPidFilter==='all'?entries:entries.filter(e=>e.profileId===batchPidFilter))
      .slice().sort((a,b)=>(b.updated||'').localeCompare(a.updated||''))
  ,[entries,batchPidFilter]);

  const toggleBatchId=id=>setBatchIds(prev=>{const n=new Set(prev);n.has(id)?n.delete(id):n.add(id);return n;});
  const batchSelectAll=()=>setBatchIds(new Set(batchVisibleEntries.map(e=>e.id)));
  const batchSelectNone=()=>setBatchIds(new Set());

  const batchExport=async()=>{
    if(!batchIds.size)return;
    if(typeof JSZip==='undefined'){alert('JSZip not loaded');return;}
    setBatchRunning(true);
    setBatchLog([]);
    const ids=[...batchIds];
    setBatchProgress({done:0,total:ids.length,currentTitle:'…'});
    const zip=new JSZip();
    const folder=zip.folder('labels');
    for(let i=0;i<ids.length;i++){
      const entry=entries.find(e=>e.id===ids[i]);
      if(!entry)continue;
      const title=entry.title||'untitled';
      setBatchProgress({done:i,total:ids.length,currentTitle:title});
      // Merge saved label data with defaults — ensures every field exists
      const ef={...DEFAULT_FIELDS,...(entry.labelFields||{}),
        title:entry.labelFields?.title||entry.title||'',
        artist:entry.labelFields?.artist||entry.artist||''};
      const es={...DEFAULT_SETTINGS,...(entry.labelSettings||{})};
      const idx=String(i+1).padStart(3,'0');
      const slug=`${idx}_${(entry.artist||'artist').replace(/[^a-z0-9]/gi,'_').slice(0,24)}_${title.replace(/[^a-z0-9]/gi,'_').slice(0,36)}`;
      try{
        const blob=await renderLabelToBlob(ef,es,batchScale);
        folder.file(`${slug}.png`,blob,{compression:'STORE'});
        setBatchLog(l=>[...l,{id:entry.id,title,ok:true}]);
      }catch(err){
        setBatchLog(l=>[...l,{id:entry.id,title,ok:false,msg:err.message||'Unknown error'}]);
      }
      await new Promise(r=>setTimeout(r,16)); // yield — keeps UI responsive between renders
    }
    setBatchProgress(p=>({...p,done:ids.length,currentTitle:''}));
    try{
      const zipBlob=await zip.generateAsync({type:'blob'});
      const a=document.createElement('a');a.href=URL.createObjectURL(zipBlob);
      a.download=`tracklab-labels-${todayStr()}.zip`;a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),8000);
    }catch(err){alert('ZIP generation failed: '+err.message);}
    setBatchRunning(false);
  };

  // ── SEND META TO LABEL
  const sendMetaToLabel=()=>{
    const nf={...fields,artist:meta.artist||fields.artist,title:meta.title||fields.title,catalog:meta.catalog||fields.catalog,isrc:meta.isrc||fields.isrc,upc:meta.upc||fields.upc};
    setFields(nf);
    setS(s=>{const mf=(s.metaFields||[]).map(m=>{const l=m.label.toUpperCase();if(l==='BPM'&&meta.bpm)return{...m,value:meta.bpm};if(l==='KEY'&&meta.key)return{...m,value:meta.key};if(l==='GENRE'&&meta.genre)return{...m,value:meta.genre};if((l==='YEAR'||l==='DATE')&&meta.year)return{...m,value:meta.year};return m;});return{...s,metaFields:mf};});
    setTab('studio');setStudioSubTab('label');saveLS('tl_studio_sub','label');
  };

  const mS={fontSize:9,color:T.muted,lineHeight:1.6};
  const h2S={fontSize:12,fontWeight:700,color:T.bright,marginBottom:14,letterSpacing:'0.06em',textTransform:'uppercase'};
  const prevScale=Math.min(1,420/settings.labelW);

  // ━━━━━━━━ IMAGE DRAG / RESIZE ━━━━━━━━
  // Local state only used during a resize drag — lets us move the overlay border
  // live without triggering an expensive Atkinson re-dither on every pixel.
  const [dragImgSize,setDragImgSize]=useState(null); // null | {w,h}

  // MOVE — drag the image overlay to reposition imageX / imageY.
  // Updates settings live; cheap because it doesn't affect dither output.
  const onImgDragStart=useCallback(e=>{
    if(e.button!==0)return;
    e.preventDefault();
    e.stopPropagation();
    const sx=e.clientX,sy=e.clientY;
    const ix=settings.imageX,iy=settings.imageY;
    const sc=prevScale;
    const onMove=ev=>{
      setS(s=>({...s,
        imageX:Math.round(ix+(ev.clientX-sx)/sc),
        imageY:Math.round(iy+(ev.clientY-sy)/sc),
      }));
    };
    const onUp=()=>{
      window.removeEventListener('mousemove',onMove);
      window.removeEventListener('mouseup',onUp);
    };
    window.addEventListener('mousemove',onMove);
    window.addEventListener('mouseup',onUp);
  },[settings.imageX,settings.imageY,prevScale,setS]);

  // RESIZE — drag the bottom-right handle to change imageW / imageH.
  // Uses local dragImgSize for a live border preview; commits to setS on mouseup
  // so the expensive re-dither only fires once at the end of the gesture.
  const onImgResizeStart=useCallback(e=>{
    if(e.button!==0)return;
    e.preventDefault();
    e.stopPropagation();
    const sx=e.clientX,sy=e.clientY;
    const sw=settings.imageW,sh=settings.imageH;
    const sc=prevScale;
    const onMove=ev=>{
      const nw=Math.max(40,Math.round(sw+(ev.clientX-sx)/sc));
      const nh=Math.max(40,Math.round(sh+(ev.clientY-sy)/sc));
      setDragImgSize({w:nw,h:nh});
    };
    const onUp=ev=>{
      const nw=Math.max(40,Math.round(sw+(ev.clientX-sx)/sc));
      const nh=Math.max(40,Math.round(sh+(ev.clientY-sy)/sc));
      setS(s=>({...s,imageW:nw,imageH:nh}));
      setDragImgSize(null);
      window.removeEventListener('mousemove',onMove);
      window.removeEventListener('mouseup',onUp);
    };
    window.addEventListener('mousemove',onMove);
    window.addEventListener('mouseup',onUp);
  },[settings.imageW,settings.imageH,prevScale,setS]);

  // ━━━━━━━━ TAB BAR ━━━━━━━━
  const tabBar=(
    <div style={{height:44,display:'flex',alignItems:'center',justifyContent:'space-between',background:T.panel,borderBottom:`1px solid ${T.border}`,padding:'0 14px',flexShrink:0,position:'relative',zIndex:100}}>
      <div style={{display:'flex',alignItems:'center',gap:8,minWidth:0}}>
        <div style={{display:'flex',alignItems:'baseline',gap:6,flexShrink:0}}>
          <div style={{fontSize:9,letterSpacing:'0.3em',textTransform:'uppercase',color:T.bright}}>Track Lab</div>
          <div style={{fontSize:7,letterSpacing:'0.15em',color:T.sub,fontFamily:'monospace'}}>{VERSION}</div>
        </div>
        {activeProfile&&<span style={{fontSize:8,color:T.accent,border:`1px solid ${T.accent}44`,padding:'2px 7px',borderRadius:T.r||0,flexShrink:0}}>{activeProfile.name}</span>}
        {activeEntry&&<span style={{fontSize:8,color:T.sub,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>· {activeEntry.title||'Untitled'}</span>}
      </div>
      <div style={{display:'flex',gap:1,flexShrink:0}}>
        {[['info','Info'],['archive','Archive'],['metadata','Data'],['classify','Classify'],['studio','Studio'],['catalog',`Codes (${savedCodes.length})`],['viz','Player']].map(([id,lbl])=>(
          <button key={id} onClick={()=>{setTab(id);if(id==='studio'){setStudioSubTab('art');saveLS('tl_studio_sub','art');}}} style={{padding:'6px 11px',background:tab===id?T.accent:'transparent',color:tab===id?T.bg:T.sub,border:'none',fontFamily:'inherit',fontSize:8,letterSpacing:'0.1em',textTransform:'uppercase',cursor:'pointer',fontWeight:tab===id?700:400,borderRadius:T.r||0}}>
            {lbl}
          </button>
        ))}
      </div>
      <div style={{display:'flex',alignItems:'center',gap:6,flexShrink:0}}>
        {/* ── Undo / Redo — context-aware: archive tab uses catalog history, others use meta history */}
        {(()=>{
          const isCatalog=tab==='archive';
          const canU=isCatalog?catalogHistory.canUndo:metaHistory.canUndo;
          const canR=isCatalog?catalogHistory.canRedo:metaHistory.canRedo;
          const steps=isCatalog?catalogHistory.steps:metaHistory.steps;
          const doU=isCatalog?doCatalogUndo:doMetaUndo;
          const doR=isCatalog?doCatalogRedo:doMetaRedo;
          const label=isCatalog?'catalog':'edits';
          return(
            <>
              <button
                onClick={doU} disabled={!canU}
                title={canU?`Undo ${steps} ${label} (Ctrl+Z)`:'Nothing to undo'}
                style={{background:'none',border:`1px solid ${canU?T.border:'transparent'}`,color:canU?T.text:T.muted,
                  fontFamily:'inherit',fontSize:11,padding:'2px 7px',cursor:canU?'pointer':'default',
                  borderRadius:T.r||0,lineHeight:1,opacity:canU?1:0.35,transition:'opacity 0.15s'}}>
                ↩
              </button>
              <button
                onClick={doR} disabled={!canR}
                title={canR?`Redo (Ctrl+Shift+Z)`:'Nothing to redo'}
                style={{background:'none',border:`1px solid ${canR?T.border:'transparent'}`,color:canR?T.text:T.muted,
                  fontFamily:'inherit',fontSize:11,padding:'2px 7px',cursor:canR?'pointer':'default',
                  borderRadius:T.r||0,lineHeight:1,opacity:canR?1:0.35,transition:'opacity 0.15s'}}>
                ↪
              </button>
            </>
          );
        })()}
        {autoSaving&&<span className="tl-spin" style={{fontSize:10,color:T.muted,lineHeight:1}}>↻</span>}
        {diskSaving&&<span className="tl-spin" style={{fontSize:10,color:T.accent,lineHeight:1}} title="Saving to disk…">↻</span>}
        {!diskSaving&&diskLastSaved&&folderName&&<span style={{fontSize:7,color:'#3fb950',lineHeight:1,cursor:'default'}} title={`Saved to disk at ${diskLastSaved.toLocaleTimeString()}`}>●</span>}
        {diskSaveError&&<span style={{fontSize:7,color:'#f87171',lineHeight:1,cursor:'pointer'}} title={diskSaveError} onClick={()=>setShowTheme(true)}>⚠</span>}
        {activeEid&&<button onClick={saveToEntry} style={{...mkBtn(T,true),padding:'4px 10px',fontSize:8,...(savedFlash?{background:'#3fb950'}:{}),transition:'background 0.2s'}}>{savedFlash?'✓ Saved':'⬆ Save'}</button>}
        <button onClick={()=>setShowTheme(!showTheme)} style={{background:showTheme?T.accent:T.bg,border:`1px solid ${T.border}`,color:showTheme?T.bg:T.muted,fontSize:13,padding:'3px 7px',cursor:'pointer',borderRadius:T.r||0}}>⚙</button>
      </div>
      {showTheme&&<>
        <div style={{position:'fixed',inset:0,zIndex:999}} onClick={()=>setShowTheme(false)}/>
        <ThemePopover appTheme={appTheme} setAppTheme={setAppTheme} T={T} onClose={()=>setShowTheme(false)} fsProps={{
          supported:permState!=='unsupported',
          folderName,diskSaving,diskLastSaved,diskSaveError,
          pickFolder:async()=>{const ok=await pickFolder();if(ok)setTimeout(()=>diskSaveAllRef.current?.(),300);},
          clearFolder,
          saveNow:()=>diskSaveAllRef.current?.(),
        }}/>
      </>}
    </div>
  );

  // ━━━━━━━━ INFO TAB ━━━━━━━━
  const infoTab=(
    <div style={{maxWidth:720,margin:'0 auto',padding:'32px 20px'}}>
      <div style={{...mkCard(T),padding:'32px 28px',marginBottom:20,textAlign:'center'}}>
        <div style={{fontSize:11,letterSpacing:'0.4em',textTransform:'uppercase',color:T.text,marginBottom:8}}>Welcome to</div>
        <div style={{fontSize:38,fontWeight:700,color:T.accent,letterSpacing:'0.08em',lineHeight:1,marginBottom:6}}>TRACK LAB</div>
        <div style={{fontSize:11,letterSpacing:'0.2em',textTransform:'uppercase',color:T.text,marginBottom:18}}>Music Archive & Label Design System</div>
        <div style={{fontSize:12,color:T.text,lineHeight:1.85,maxWidth:520,margin:'0 auto'}}>A personal archival system for your music. Catalog every track with industry-standard metadata, design physical and digital labels, generate classification codes, embed ID3 tags into your audio files, and maintain an organized archive across unlimited artist profiles.</div>
      </div>
      <div style={{...mkCard(T),marginBottom:16}}>
        <div style={{fontSize:10,fontWeight:700,color:T.accent,letterSpacing:'0.15em',textTransform:'uppercase',marginBottom:14}}>Workflow</div>
        {[
          ['1 — Create Profile','Go to Archive → New Profile. Create one profile per artist or project. Each profile holds unlimited track entries.'],
          ['2 — New Track Entry','Inside a profile, click "+ New Track Entry". This opens the Tags panel for that entry. Give it a title, artist, and any metadata.'],
          ['3 — Upload Audio','In Tags → Audio File, drop your audio file. Existing ID3 tags are read automatically. Export a properly-tagged MP3 with all your data embedded.'],
          ['4 — Album Art','In Tags → Album Art, upload your artwork. It is center-cropped and saved at your chosen output resolution (up to 3000×3000).'],
          ['5 — Classify','In the Classify tab, generate a 4-character classification code describing the track\'s genre, mood, tempo, and texture. Save it to the entry.'],
          ['6 — Design Label','In the Label tab, design a physical or digital label. Content flows from the Data tab. Export as PNG or JPG at any resolution.'],
          ['7 — Export & Backup','Use Archive → Export ZIP to create a portable archive of all audio, artwork, and metadata. Import JSON to restore on another device.'],
        ].map(([title,body])=>(
          <div key={title} style={{display:'flex',gap:14,padding:'10px 12px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0,marginBottom:6}}>
            <div style={{fontSize:9,fontWeight:700,color:T.accent,minWidth:110,paddingTop:2,flexShrink:0}}>{title}</div>
            <div style={{fontSize:11,color:T.text,lineHeight:1.75}}>{body}</div>
          </div>
        ))}
      </div>
      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12,marginBottom:16}}>
        <div style={mkCard(T)}>
          <div style={{fontSize:9,fontWeight:700,color:T.accent,letterSpacing:'0.12em',textTransform:'uppercase',marginBottom:8}}>Classification Format</div>
          <div style={{fontFamily:'monospace',fontSize:20,color:T.bright,letterSpacing:'0.2em',marginBottom:8,textAlign:'center'}}>XXX.X</div>
          {[['Pos 1','Genre / Style'],['Pos 2','Mood / Energy'],['Pos 3','Tempo / Feel'],['Pos 4','Texture']].map(([p,d])=>(
            <div key={p} style={{display:'flex',gap:8,marginBottom:4}}><span style={{fontSize:9,color:T.accent,minWidth:36,flexShrink:0}}>{p}</span><span style={{fontSize:9,color:T.muted}}>{d} · 0–9, A–Z</span></div>
          ))}
        </div>
        <div style={mkCard(T)}>
          <div style={{fontSize:9,fontWeight:700,color:T.accent,letterSpacing:'0.12em',textTransform:'uppercase',marginBottom:8}}>Cloud Backup</div>
          <div style={{fontSize:10,color:T.text,lineHeight:1.8}}>All data stored locally (IndexedDB + localStorage). To back up: <strong style={{color:T.bright}}>Archive → Export ZIP</strong> — creates a portable archive with audio, art, and metadata organized by profile and track. Upload to Google Drive, Dropbox, or iCloud. To restore: use <strong style={{color:T.bright}}>Import JSON</strong>.</div>
        </div>
      </div>
      <div style={{textAlign:'center',padding:'20px 0 0',color:T.sub,fontSize:8,letterSpacing:'0.2em',textTransform:'uppercase'}}>Track Lab {VERSION} · All data stored locally · No account required</div>
    </div>
  );

  // ━━━━━━━━ ARCHIVE TAB ━━━━━━━━
  const archiveTab=(
    <div style={{display:'flex',minHeight:'calc(100vh - 44px)',overflow:'visible',position:'relative'}}>
      {/* PROFILES SIDEBAR */}
      <div style={{width:archiveSidebar.width,flexShrink:0,background:T.panel,borderRight:archiveSidebar.collapsed?'none':`1px solid ${T.border}`,display:'flex',flexDirection:'column',overflow:'hidden',position:'relative',transition:'width 0.15s'}}>
        <div {...archiveSidebar.handle}/>
        {archiveSidebar.tab}
        <div style={{padding:'12px 12px 10px',borderBottom:`1px solid ${T.border}`,flexShrink:0}}>
          <div style={{fontSize:8,letterSpacing:'0.2em',textTransform:'uppercase',color:T.muted,marginBottom:8}}>Artist Profiles</div>
          {newProf.open?(
            <div>
              <input value={newProf.name} onChange={e=>setNewProf(p=>({...p,name:e.target.value}))} placeholder="Artist or project name" style={{...mkIS(T),marginBottom:5,fontSize:11}} onKeyDown={e=>e.key==='Enter'&&createProfile()}/>
              <input value={newProf.desc} onChange={e=>setNewProf(p=>({...p,desc:e.target.value}))} placeholder="Description (optional)" style={{...mkIS(T),marginBottom:6,fontSize:11}}/>
              <div style={{display:'flex',gap:5}}>
                <button onClick={createProfile} style={{...mkBtn(T,true),flex:1,padding:'5px 0',fontSize:9}}>Create</button>
                <button onClick={()=>setNewProf({open:false,name:'',desc:''})} style={{...mkBtn(T),padding:'5px 8px',fontSize:9}}>✕</button>
              </div>
            </div>
          ):(
            <button onClick={()=>setNewProf(p=>({...p,open:true}))} style={{...mkBtn(T,true),width:'100%',padding:'6px 0',fontSize:9}}>+ New Profile</button>
          )}
        </div>
        <div style={{flex:1,overflowY:'auto',padding:'6px'}}>
          {orderedProfiles.length===0&&<div style={{fontSize:9,color:T.muted,textAlign:'center',padding:'20px 10px',lineHeight:1.9,border:`1px dashed ${T.border}`,borderRadius:T.r||0,margin:'4px 0'}}>No projects yet.<br/>Create one below,<br/>or drop audio files<br/>into the track window.</div>}
          {orderedProfiles.map(p=>(
            <div key={p.id}
              draggable={!editProf}
              onDragStart={e=>{
                e.dataTransfer.effectAllowed='move';
                e.dataTransfer.setData('application/x-tl-profile-reorder',p.id);
                profileDragRef.current=p.id;
              }}
              onDragOver={e=>{
                e.preventDefault();
                e.dataTransfer.dropEffect='move';
                if(profileDragRef.current&&profileDragRef.current!==p.id)setProfileDragOverId(p.id);
              }}
              onDragLeave={e=>{if(!e.currentTarget.contains(e.relatedTarget))setProfileDragOverId(null);}}
              onDrop={e=>{
                e.preventDefault();
                if(!e.dataTransfer.types.includes('application/x-tl-profile-reorder'))return;
                if(profileDragRef.current&&profileDragRef.current!==p.id)reorderProfiles(profileDragRef.current,p.id);
                profileDragRef.current=null;
                setProfileDragOverId(null);
              }}
              onDragEnd={()=>{profileDragRef.current=null;setProfileDragOverId(null);}}
              style={{outline:profileDragOverId===p.id?`2px solid ${T.accent}`:'2px solid transparent',borderRadius:T.r||0,transition:'outline 0.1s'}}
            >
              {editProf?.id===p.id?(
                <div style={{padding:'8px',marginBottom:4,background:T.card,border:`1px solid ${T.accent}`,borderRadius:T.r||0}}>
                  <input value={editProf.name} onChange={e=>setEditProf(ep=>({...ep,name:e.target.value}))} style={{...mkIS(T),marginBottom:4,fontSize:11}} onKeyDown={e=>e.key==='Enter'&&saveEditProfile()}/>
                  <input value={editProf.desc} onChange={e=>setEditProf(ep=>({...ep,desc:e.target.value}))} placeholder="Description" style={{...mkIS(T),marginBottom:6,fontSize:11}}/>
                  <div style={{display:'flex',gap:4}}>
                    <button onClick={saveEditProfile} style={{...mkBtn(T,true),flex:1,padding:'4px 0',fontSize:9}}>Save</button>
                    <button onClick={()=>setEditProf(null)} style={{...mkBtn(T),padding:'4px 8px',fontSize:9}}>✕</button>
                  </div>
                </div>
              ):(
                <div onClick={()=>setActivePid(p.id)} style={{padding:'9px 10px',marginBottom:4,background:activePid===p.id?T.card:T.bg,border:`1px solid ${activePid===p.id?T.accent:T.border}`,borderRadius:T.r||0,cursor:'grab',position:'relative',userSelect:'none'}}>
                  <div style={{display:'flex',alignItems:'center',justifyContent:'space-between'}}>
                    <div style={{display:'flex',alignItems:'center',gap:5,minWidth:0,flex:1}}>
                      <span style={{fontSize:9,color:T.muted,flexShrink:0,lineHeight:1,cursor:'grab',opacity:0.5}}>⠿</span>
                      <div style={{fontSize:11,fontWeight:700,color:activePid===p.id?T.accent:T.bright,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',flex:1,minWidth:0}}>{p.name}</div>
                    </div>
                    <div style={{display:'flex',alignItems:'center',gap:4,flexShrink:0,marginLeft:4}}>
                      <span style={{fontSize:8,color:T.muted}}>{entries.filter(e=>e.profileId===p.id).length}</span>
                      <button onClick={ev=>{ev.stopPropagation();setEditProf({id:p.id,name:p.name,desc:p.description||''}); setActivePid(p.id);}} style={{background:'none',border:'none',color:T.muted,cursor:'pointer',fontSize:10,padding:'0 2px',lineHeight:1}}>✎</button>
                      <button onClick={ev=>{ev.stopPropagation();if(window.confirm(`Delete profile "${p.name}" and ALL its tracks?`)){deleteProfile(p.id);}}} style={{background:'none',border:'none',color:'#f87171',cursor:'pointer',fontSize:10,padding:'0 2px',lineHeight:1}} title="Delete profile">✕</button>
                    </div>
                  </div>
                  {p.description&&<div style={{fontSize:9,color:T.muted,marginTop:2,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{p.description}</div>}
                </div>
              )}
            </div>
          ))}
        </div>
        <div style={{padding:'8px',paddingBottom:8,borderTop:`1px solid ${T.border}`,flexShrink:0,display:'flex',flexDirection:'column',gap:4}}>
          <div style={{fontSize:7,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted,marginBottom:2}}>Export & Backup</div>
          <button onClick={exportCSV} style={{...mkBtn(T),width:'100%',padding:'5px 0',fontSize:8}}>📊 Export CSV</button>
          <button onClick={exportJSON} style={{...mkBtn(T),width:'100%',padding:'5px 0',fontSize:8}}>💾 Backup JSON</button>
          <button onClick={exportZIP} disabled={zipping} style={{...mkBtn(T),width:'100%',padding:'5px 0',fontSize:8,opacity:zipping?0.6:1}}>{zipping?'⏳ Building ZIP…':'📦 Export ZIP (audio+art)'}</button>
          <button onClick={()=>exportImportRef.current.click()} style={{...mkBtn(T),width:'100%',padding:'5px 0',fontSize:8}}>⬆ Import JSON</button>
          <button onClick={()=>csvImportRef.current.click()} style={{...mkBtn(T),width:'100%',padding:'5px 0',fontSize:8}}>📋 Import CSV</button>
          <input ref={exportImportRef} type="file" accept=".json" style={{display:'none'}} onChange={e=>e.target.files[0]&&importJSON(e.target.files[0])}/>
          <input ref={csvImportRef} type="file" accept=".csv,text/csv" style={{display:'none'}} onChange={e=>e.target.files[0]&&importCSV(e.target.files[0])}/>
        </div>
      </div>
      {archiveSidebar.expandStub}

      {/* ENTRY LIST */}
      <div style={{flex:1,display:'flex',flexDirection:'column',overflowY:'auto',minWidth:0}}>
        {activePid?(
          <>
            <div style={{padding:'12px 16px',borderBottom:`1px solid ${T.border}`,flexShrink:0,background:T.panel,gap:8,display:'flex',flexDirection:'column'}}>
              <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',gap:10}}>
              <div>
                <div style={{fontSize:13,fontWeight:700,color:T.bright}}>{activeProfile?.name}</div>
                <div style={{fontSize:9,color:T.muted}}>{profEntries.length} {profEntries.length===1?'track':'tracks'}{archiveSearch&&` · ${filteredEntries.length} shown`}</div>
              </div>
              <div style={{display:'flex',gap:6}}>
                <button onClick={createEntry} style={{...mkBtn(T,true),padding:'7px 14px',fontSize:9}}>+ New Track</button>
                <button onClick={toggleSelectMode} style={{...mkBtn(T,selectMode),padding:'7px 10px',fontSize:8}}>{selectMode?'✕ Cancel':'☑ Select'}</button>
                <button onClick={()=>{if(window.confirm(`Delete profile "${activeProfile?.name}" and ALL its entries?`)){deleteProfile(activePid);}}} style={{...mkBtn(T),padding:'7px 10px',fontSize:8,color:'#f87171'}}>Delete Profile</button>
              </div>
              </div>
              {/* Search bar */}
              <div style={{position:'relative'}}>
                <input value={archiveSearch} onChange={e=>setArchiveSearch(e.target.value)} placeholder="Search title, artist, code, status…" style={{...mkIS(T),paddingRight:28,fontSize:11}}/>
                {archiveSearch&&<button onClick={()=>setArchiveSearch('')} style={{position:'absolute',right:6,top:'50%',transform:'translateY(-50%)',background:'none',border:'none',color:T.muted,cursor:'pointer',fontSize:12,padding:0,lineHeight:1}}>✕</button>}
              </div>
              {/* Sort + Status filter row */}
              <div style={{display:'flex',gap:5,alignItems:'center',flexWrap:'wrap'}}>
                <span style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',flexShrink:0}}>Sort</span>
                {[['updated','Recent'],['created','Created'],['title','A–Z'],['status','Status'],['manual','Manual']].map(([v,lbl])=>(
                  <button key={v} onClick={()=>setArchiveSort(v)} style={{...mkBtn(T,archiveSort===v),padding:'2px 8px',fontSize:8}}>{lbl}</button>
                ))}
                <span style={{fontSize:7,color:T.border,marginLeft:4,flexShrink:0}}>|</span>
                <span style={{fontSize:7,color:T.muted,letterSpacing:'0.15em',textTransform:'uppercase',flexShrink:0}}>Filter</span>
                <button onClick={()=>setArchiveStatusFilter('all')} style={{...mkBtn(T,archiveStatusFilter==='all'),padding:'2px 8px',fontSize:8}}>All</button>
                {Object.entries(STATUS_OPT).map(([k,v])=>(
                  <button key={k} onClick={()=>setArchiveStatusFilter(archiveStatusFilter===k?'all':k)} style={{...mkBtn(T,archiveStatusFilter===k),padding:'2px 8px',fontSize:8,color:archiveStatusFilter===k?T.bg:v.color,borderColor:v.color+'66'}}>{v.label}</button>
                ))}
              </div>
              {/* Bulk select controls */}
              {selectMode&&(
                <div style={{display:'flex',alignItems:'center',gap:6,padding:'6px 0',borderTop:`1px solid ${T.border}`}}>
                  <button onClick={selectAll} style={{...mkBtn(T),padding:'4px 8px',fontSize:8}}>All</button>
                  <button onClick={()=>setSelectedEids(new Set())} style={{...mkBtn(T),padding:'4px 8px',fontSize:8}}>None</button>
                  <span style={{fontSize:9,color:T.muted,flex:1}}>{selectedEids.size} selected</span>
                  <select value={bulkStatus} onChange={e=>setBulkStatus(e.target.value)} style={{...mkIS(T),flex:'0 0 auto',width:'auto',fontSize:9,padding:'3px 6px'}}>
                    {Object.entries(STATUS_OPT).map(([k,v])=><option key={k} value={k}>{v.label}</option>)}
                  </select>
                  <button onClick={applyBulkStatus} disabled={!selectedEids.size} style={{...mkBtn(T,true),padding:'4px 10px',fontSize:9,opacity:selectedEids.size?1:0.4}}>Apply</button>
                  <button onClick={()=>{if(!selectedEids.size||!window.confirm(`Delete ${selectedEids.size} track${selectedEids.size>1?'s':''}? This cannot be undone.`))return;[...selectedEids].forEach(id=>deleteEntry(id));setSelectedEids(new Set());setSelectMode(false);}} disabled={!selectedEids.size} style={{...mkBtn(T),padding:'4px 10px',fontSize:9,color:'#f87171',borderColor:'#f87171',opacity:selectedEids.size?1:0.4}}>Delete</button>
                </div>
              )}
            </div>
            <div
              style={{flex:1,overflowY:'auto',padding:'14px 16px',position:'relative',
                transition:'background 0.15s',
                background:archiveDragOver?`${T.accent}18`:'transparent',
                outline:archiveDragOver?`2px dashed ${T.accent}`:'2px dashed transparent',
                outlineOffset:-2,
              }}
              onDragOver={e=>{e.preventDefault();if(!e.dataTransfer.types.includes('application/x-tl-reorder'))setArchiveDragOver(true);}}
              onDragLeave={e=>{if(!e.currentTarget.contains(e.relatedTarget))setArchiveDragOver(false);}}
              onDrop={async e=>{
              e.preventDefault();setArchiveDragOver(false);
              // Ignore internal card reorder drags — they have a custom type marker
              if(e.dataTransfer.types.includes('application/x-tl-reorder'))return;
              const {files,folderName}=await extractDropItems(e.dataTransfer);
              if(!files.length)return;
              if(activePid){
                importAudioFiles(files,activePid);
              }else{
                pendingDropFilesRef.current=files;
                setDropProfileName(folderName||'');
                setDropProfilePrompt(true);
              }
            }}
            >
              {profEntries.length===0?(
                <div style={{height:'100%',minHeight:260,display:'flex',flexDirection:'column',alignItems:'center',justifyContent:'center',gap:0,padding:32,textAlign:'center',position:'relative'}}>
                  {/* Big drop target visual */}
                  <div style={{position:'absolute',inset:16,border:`2px dashed ${archiveDragOver?T.accent:T.border}44`,borderRadius:(T.r||0)*2,pointerEvents:'none',transition:'border-color 0.15s'}}/>
                  <div style={{fontSize:48,opacity:archiveDragOver?0.6:0.12,marginBottom:16,transition:'opacity 0.15s'}}>🎵</div>
                  <div style={{fontSize:13,fontWeight:700,color:archiveDragOver?T.accent:T.bright,marginBottom:8,letterSpacing:'0.04em',transition:'color 0.15s'}}>{archiveDragOver?'Drop to import':'No tracks yet'}</div>
                  <div style={{fontSize:10,color:T.muted,lineHeight:1.7,marginBottom:24,maxWidth:260}}>Drag & drop audio files anywhere in this area to import them instantly, or start with a blank entry.</div>
                  <button onClick={createEntry} style={{...mkBtn(T,true),padding:'9px 20px',fontSize:10}}>+ New Blank Track</button>
                </div>
              ):filteredEntries.length===0?(
                <div style={{...mkCard(T),textAlign:'center',padding:32}}>
                  <div style={{fontSize:9,color:T.muted}}>No tracks match "{archiveSearch}"</div>
                </div>
              ):(
                filteredEntries.map(e=>(
                  <div key={e.id}
                    draggable={!selectMode}
                    onDragStart={ev=>{
                      ev.dataTransfer.effectAllowed='move';
                      ev.dataTransfer.setData('application/x-tl-reorder',e.id);
                      entryDragRef.current=e.id;
                    }}
                    onDragOver={ev=>{
                      ev.preventDefault();
                      ev.dataTransfer.dropEffect='move';
                      if(entryDragRef.current&&entryDragRef.current!==e.id)setEntryDragOverId(e.id);
                    }}
                    onDragLeave={ev=>{if(!ev.currentTarget.contains(ev.relatedTarget))setEntryDragOverId(null);}}
                    onDrop={ev=>{
                      ev.preventDefault();
                      // Only handle card reorder drops — ignore file drops
                      if(!ev.dataTransfer.types.includes('application/x-tl-reorder'))return;
                      if(entryDragRef.current&&entryDragRef.current!==e.id){
                        reorderEntries(entryDragRef.current,e.id,activePid);
                      }
                      entryDragRef.current=null;
                      setEntryDragOverId(null);
                    }}
                    onDragEnd={()=>{entryDragRef.current=null;setEntryDragOverId(null);}}
                    style={{outline:entryDragOverId===e.id?`2px solid ${T.accent}`:'2px solid transparent',borderRadius:(T.r||0)*1.5,transition:'outline 0.1s'}}
                  >
                  <EntryCard T={T} entry={e} isActive={e.id===activeEid&&!selectMode}
                    isPlaying={e.id===playingEid&&playing}
                    selectable={selectMode} selected={selectedEids.has(e.id)} onToggle={toggleEid}
                    onOpen={id=>{const ent=entries.find(x=>x.id===id);if(ent){const wasPlaying=playing&&playingEid!==null;loadEntry(ent).then(()=>{if(wasPlaying&&ent.hasAudio){setPlayingEid(ent.id);requestAnimationFrame(()=>requestAnimationFrame(()=>audioElRef.current?.play()));}});}}}
                    onDelete={deleteEntry}
                    onPlayPause={async ent=>{
                      const el=audioElRef.current;
                      if(ent.id===playingEid){
                        if(!el)return;
                        playing?el.pause():el.play();
                      }else if(ent.id===activeEid){
                        setPlayingEid(ent.id);
                        el?.play();
                      }else{
                        await loadEntry(ent);
                        setPlayingEid(ent.id);
                        requestAnimationFrame(()=>requestAnimationFrame(()=>{audioElRef.current?.play();}));
                      }
                    }}
                    onTabJump={async(ent,targetTab)=>{
                      if(ent.id!==activeEid)await loadEntry(ent);
                      setTab(targetTab);
                    }}
                  />
                  </div>
                ))
              )}
            </div>
          </>
        ):(
          <div
            style={{flex:1,display:'flex',alignItems:'center',justifyContent:'center',flexDirection:'column',gap:14,padding:40,
              background:archiveDragOver?`${T.accent}10`:'transparent',
              outline:archiveDragOver?`2px dashed ${T.accent}`:'2px dashed transparent',
              outlineOffset:-2,transition:'background 0.15s',position:'relative'}}
            onDragOver={e=>{e.preventDefault();if(!e.dataTransfer.types.includes('application/x-tl-reorder')&&!e.dataTransfer.types.includes('application/x-tl-profile-reorder'))setArchiveDragOver(true);}}
            onDragLeave={e=>{if(!e.currentTarget.contains(e.relatedTarget))setArchiveDragOver(false);}}
            onDrop={async e=>{
              e.preventDefault();setArchiveDragOver(false);
              if(e.dataTransfer.types.includes('application/x-tl-reorder')||e.dataTransfer.types.includes('application/x-tl-profile-reorder'))return;
              const {files,folderName}=await extractDropItems(e.dataTransfer);
              if(!files.length)return;
              pendingDropFilesRef.current=files;
              setDropProfileName(folderName||'');
              setDropProfilePrompt(true);
            }}
          >
            {archiveDragOver?(
              <>
                <div style={{fontSize:40,opacity:0.5}}>🎵</div>
                <div style={{fontSize:13,fontWeight:700,color:T.accent,letterSpacing:'0.04em'}}>Drop to create a new project</div>
                <div style={{fontSize:10,color:T.muted}}>You'll name it in one step.</div>
              </>
            ):(
              <>
                <div style={{fontSize:36,opacity:0.1}}>◈</div>
                <div style={{...mS,textAlign:'center'}}>Select a project<br/>to view its tracks.</div>
                <div style={{fontSize:9,color:T.muted,textAlign:'center',lineHeight:1.7,maxWidth:200}}>Or drop audio files here to create a new project automatically.</div>
              </>
            )}
          </div>
        )}
      </div>

      {/* ENTRY DETAIL */}
      {activeEntry&&(<>
        {archiveDetail.expandStub}
        <div style={{width:archiveDetail.width,flexShrink:0,background:T.panel,borderLeft:archiveDetail.collapsed?'none':`1px solid ${T.border}`,overflow:'hidden',padding:archiveDetail.collapsed?0:14,display:'flex',flexDirection:'column',gap:10,position:'relative',transition:'width 0.15s'}}>
          <div {...archiveDetail.handle}/>
          {archiveDetail.tab}
          <div style={{fontSize:8,letterSpacing:'0.2em',textTransform:'uppercase',color:T.muted}}>Entry Detail</div>
          {activeEntry.albumArtThumb&&<div style={{width:'100%',aspectRatio:'1',overflow:'hidden',borderRadius:T.r||0,border:`1px solid ${T.border}`}}><img src={activeEntry.albumArtThumb} style={{width:'100%',height:'100%',objectFit:'cover'}}/></div>}
          <div><div style={{fontSize:13,fontWeight:700,color:T.bright,marginBottom:2}}>{activeEntry.title||'Untitled'}</div><div style={{fontSize:10,color:T.muted}}>{activeEntry.artist}</div></div>
          {activeEntry.hasAudio&&(
            <div>
              <div style={{fontSize:8,color:T.muted,marginBottom:6,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{activeEntry.audioFilename}</div>
              <DetailMiniPlayer
                T={T}
                entry={activeEntry}
                audioElRef={audioElRef}
                audioObjectUrl={audioObjectUrl}
                isCurrentEntry={activeEntry.id===activeEid}
                onLoad={()=>loadEntry(activeEntry)}
              />
            </div>
          )}
          <div>
            <label style={mkLBL(T)}>Status</label>
            <select value={activeEntry.status||'draft'} onChange={e=>updateEntry(activeEntry.id,{status:e.target.value})} style={{...mkIS(T)}}>
              {Object.entries(STATUS_OPT).map(([k,v])=><option key={k} value={k}>{v.label}</option>)}
            </select>
          </div>
          {activeEntry.classCode&&<div><div style={{fontFamily:'monospace',fontSize:18,color:T.accent,marginBottom:3}}>{activeEntry.classCode}</div><div style={{fontSize:9,color:T.muted,lineHeight:1.5}}>{getCodeDesc(activeEntry.classCode)}</div></div>}
          <div style={{fontSize:7,color:T.muted}}>Created {fmtDate(activeEntry.created)} · Updated {fmtDate(activeEntry.updated)}</div>
          <div style={{display:'flex',flexDirection:'column',gap:5}}>
            <button onClick={()=>{loadEntry(activeEntry);setTab('metadata');}} style={{...mkBtn(T),width:'100%',padding:'7px 0',fontSize:9}}>✏ Edit Data</button>
            <button onClick={()=>{loadEntry(activeEntry);setTab('studio');setStudioSubTab('label');saveLS('tl_studio_sub','label');}} style={{...mkBtn(T),width:'100%',padding:'7px 0',fontSize:9}}>🏷 Edit Label</button>
            <button onClick={()=>{loadEntry(activeEntry);setTab('classify');}} style={{...mkBtn(T),width:'100%',padding:'7px 0',fontSize:9}}>◈ Classify</button>
            <button onClick={()=>duplicateEntry(activeEntry)} style={{...mkBtn(T),width:'100%',padding:'7px 0',fontSize:9}}>⧉ Duplicate</button>
            {activeEntry.labelSettings&&(
              <button onClick={()=>setArchiveLabelExport({fields:activeEntry.labelFields||DEFAULT_FIELDS,settings:activeEntry.labelSettings||DEFAULT_SETTINGS,title:activeEntry.title||'track'})} disabled={archiveLabelExporting} style={{...mkBtn(T,true),width:'100%',padding:'7px 0',fontSize:9,opacity:archiveLabelExporting?0.6:1}}>
                {archiveLabelExporting?'⏳ Exporting…':'⬇ Export Label'}
              </button>
            )}
          </div>
        </div>
      </>)}

      {/* ── CREATE PROJECT PROMPT — shown when files dropped with no profile ── */}
      {dropProfilePrompt&&(
        <div style={{position:'absolute',inset:0,zIndex:200,background:`${T.bg}ee`,display:'flex',alignItems:'center',justifyContent:'center'}}
          onClick={e=>{if(e.target===e.currentTarget){setDropProfilePrompt(false);pendingDropFilesRef.current=[];}}}>
          <div style={{background:T.panel,border:`1px solid ${T.accent}`,borderRadius:(T.r||0)*2,padding:32,width:320,display:'flex',flexDirection:'column',gap:14}}>
            <div style={{fontSize:14,fontWeight:700,color:T.bright,letterSpacing:'0.04em'}}>Name your project</div>
            <div style={{fontSize:10,color:T.muted,lineHeight:1.65}}>
              {pendingDropFilesRef.current.length} audio file{pendingDropFilesRef.current.length!==1?'s':''} ready to import. Give this project a name — you can change it any time.
            </div>
            <input
              autoFocus
              value={dropProfileName}
              onChange={e=>setDropProfileName(e.target.value)}
              onKeyDown={e=>{
                if(e.key==='Enter'&&dropProfileName.trim()){
                  const p={id:mkUid(),name:dropProfileName.trim(),description:'',created:todayStr()};
                  setProfiles(prev=>[...prev,p]);
                  setActivePid(p.id);
                  setDropProfilePrompt(false);
                  importAudioFiles(pendingDropFilesRef.current,p.id);
                  pendingDropFilesRef.current=[];
                }
                if(e.key==='Escape'){setDropProfilePrompt(false);pendingDropFilesRef.current=[];}
              }}
              placeholder="e.g. My First EP, Session Demos, Beat Tape Vol.1…"
              style={{...mkIS(T),fontSize:12,padding:'10px 12px'}}
            />
            <div style={{display:'flex',gap:8}}>
              <button
                onClick={()=>{
                  if(!dropProfileName.trim())return;
                  const p={id:mkUid(),name:dropProfileName.trim(),description:'',created:todayStr()};
                  setProfiles(prev=>[...prev,p]);
                  setActivePid(p.id);
                  setDropProfilePrompt(false);
                  importAudioFiles(pendingDropFilesRef.current,p.id);
                  pendingDropFilesRef.current=[];
                }}
                disabled={!dropProfileName.trim()}
                style={{...mkBtn(T,true),flex:1,padding:'9px 0',fontSize:10,opacity:dropProfileName.trim()?1:0.4}}
              >Create &amp; Import</button>
              <button onClick={()=>{setDropProfilePrompt(false);pendingDropFilesRef.current=[];}} style={{...mkBtn(T),padding:'9px 14px',fontSize:10}}>Cancel</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
  // ━━━━━━━━ METADATA / TAGS TAB ━━━━━━━━
  const metadataTab=(
    <div style={{display:'flex',minHeight:'calc(100vh - 44px)',overflow:'visible'}}>
      <div style={{width:metaSidebar.width,flexShrink:0,background:T.panel,borderRight:metaSidebar.collapsed?'none':`1px solid ${T.border}`,display:'flex',flexDirection:'column',overflow:'hidden',position:'relative',transition:'width 0.15s'}}>
        <div {...metaSidebar.handle}/>
        {metaSidebar.tab}
        <div style={{padding:'12px 12px 8px',borderBottom:`1px solid ${T.border}`}}>
          <div style={{fontSize:8,letterSpacing:'0.2em',textTransform:'uppercase',color:T.muted}}>Tag Sections</div>
        </div>
        <div style={{flex:1,padding:6,overflowY:'auto'}}>
          {[['core','Core Info'],['publish','Publishing'],['codes','ISRC / UPC'],['audio','Audio File'],['art','Album Art'],['extra','Extra Tags'],['analysis','Analysis'],['lyrics','Lyrics / Notes'],['splits','Split Sheet'],['summary','Summary']].map(([id,lbl])=>(
            <div key={id} onClick={()=>setMetaSection(id)} style={{padding:'8px 10px',marginBottom:3,background:metaSection===id?T.card:T.bg,border:`1px solid ${metaSection===id?T.accent:T.border}`,borderRadius:T.r||0,cursor:'pointer',fontSize:10,color:metaSection===id?T.accent:T.text,display:'flex',alignItems:'center',justifyContent:'space-between'}}>
              {lbl}
              {id==='splits'&&credits.length>0&&<span style={{fontSize:8,color:T.muted,background:T.card,padding:'1px 5px',borderRadius:8}}>{credits.length}</span>}
            </div>
          ))}
        </div>
        <div style={{padding:8,paddingBottom:8,borderTop:`1px solid ${T.border}`,display:'flex',flexDirection:'column',gap:4}}>
          <button onClick={sendMetaToLabel} style={{...mkBtn(T,true),width:'100%',padding:'7px 0',fontSize:8}}>→ Send to Label</button>
          <button onClick={exportTaggedAudio} style={{...mkBtn(T),width:'100%',padding:'7px 0',fontSize:8}}>⬇ Export Tagged MP3</button>
          {activeEid&&<button onClick={saveToEntry} style={{...mkBtn(T,true),width:'100%',padding:'7px 0',fontSize:8,...(savedFlash?{background:'#3fb950'}:{}),transition:'background 0.2s'}}>{savedFlash?'✓ Saved':'⬆ Save to Archive'}</button>}
          <button onClick={resetMeta} style={{...mkBtn(T),width:'100%',padding:'5px 0',fontSize:7,color:T.muted}}>↺ Reset Fields</button>
        </div>
      </div>
      {metaSidebar.expandStub}
      <div
        style={{flex:1,overflowY:'auto',overflowX:'auto',padding:'22px 28px',transition:'background 0.15s',
          background:metaPanelDragOver?`${T.accent}12`:'transparent',
          outline:metaPanelDragOver?`2px dashed ${T.accent}`:'2px dashed transparent',
          outlineOffset:-2}}
        onDragOver={e=>{e.preventDefault();setMetaPanelDragOver(true);}}
        onDragLeave={e=>{if(!e.currentTarget.contains(e.relatedTarget))setMetaPanelDragOver(false);}}
        onDrop={e=>{
          e.preventDefault();setMetaPanelDragOver(false);
          const f=e.dataTransfer.files[0];
          if(f)loadAudioFile(f);
        }}
      >
        {metaSection==='core'&&(
          <div style={{maxWidth:540}}>
            <div style={h2S}>Core Track Info</div>
            <MF T={T} label="Title"><TInp T={T} value={meta.title} onChange={e=>setMeta('title',e.target.value)} placeholder="Track title (as it will appear in stores)"/></MF>
            <MF T={T} label="Artist"><TInp T={T} value={meta.artist} onChange={e=>setMeta('artist',e.target.value)} placeholder="Primary artist / performer"/></MF>
            <MF T={T} label="Album Artist"><TInp T={T} value={meta.albumArtist} onChange={e=>setMeta('albumArtist',e.target.value)} placeholder="For VA compilations"/></MF>
            <MF T={T} label="Album / Release Title"><TInp T={T} value={meta.album} onChange={e=>setMeta('album',e.target.value)}/></MF>
            <Row2><MF T={T} label="Year"><TInp T={T} value={meta.year} onChange={e=>setMeta('year',e.target.value)} placeholder="YYYY"/></MF><MF T={T} label="Genre"><TInp T={T} value={meta.genre} onChange={e=>setMeta('genre',e.target.value)}/></MF></Row2>
            <Row2><MF T={T} label="Track #"><TInp T={T} value={meta.trackNum} onChange={e=>setMeta('trackNum',e.target.value)} placeholder="e.g. 3"/></MF><MF T={T} label="of Total"><TInp T={T} value={meta.trackTotal} onChange={e=>setMeta('trackTotal',e.target.value)} placeholder="e.g. 12"/></MF></Row2>
            <Row2><MF T={T} label="Disc #"><TInp T={T} value={meta.discNum} onChange={e=>setMeta('discNum',e.target.value)}/></MF><MF T={T} label="of Total"><TInp T={T} value={meta.discTotal} onChange={e=>setMeta('discTotal',e.target.value)}/></MF></Row2>
            <Row2><MF T={T} label="BPM"><TInp T={T} value={meta.bpm} onChange={e=>setMeta('bpm',e.target.value)}/></MF><MF T={T} label="Key"><TInp T={T} value={meta.key} onChange={e=>setMeta('key',e.target.value)} placeholder="e.g. F# minor"/></MF></Row2>
            <div style={{display:'flex',gap:24,marginTop:6}}><Tog T={T} label="Explicit" value={meta.explicit} onChange={v=>setMeta('explicit',v)}/><Tog T={T} label="Compilation" value={meta.compilation} onChange={v=>setMeta('compilation',v)}/></div>
          </div>
        )}
        {metaSection==='publish'&&(
          <div style={{maxWidth:540}}>
            <div style={h2S}>Publishing & Rights</div>
            <MF T={T} label="Composer"><TInp T={T} value={meta.composer} onChange={e=>setMeta('composer',e.target.value)} placeholder="Last, First format recommended"/></MF>
            <MF T={T} label="Lyricist"><TInp T={T} value={meta.lyricist} onChange={e=>setMeta('lyricist',e.target.value)}/></MF>
            <MF T={T} label="Producer"><TInp T={T} value={meta.producer} onChange={e=>setMeta('producer',e.target.value)}/></MF>
            <MF T={T} label="Publisher"><TInp T={T} value={meta.publisher} onChange={e=>setMeta('publisher',e.target.value)}/></MF>
            <MF T={T} label="Record Label"><TInp T={T} value={meta.label} onChange={e=>setMeta('label',e.target.value)}/></MF>
            <MF T={T} label="Catalog Number"><TInp T={T} value={meta.catalog} onChange={e=>setMeta('catalog',e.target.value)} placeholder="e.g. AVS-001"/></MF>
            <MF T={T} label="Copyright"><TInp T={T} value={meta.copyright} onChange={e=>setMeta('copyright',e.target.value)} placeholder="℗ 2025 Label Name"/></MF>
          </div>
        )}
        {metaSection==='codes'&&(
          <div style={{display:'flex',gap:20,alignItems:'flex-start',maxWidth:900}}>
            {/* Left — form fields */}
            <div style={{flex:'0 0 400px',minWidth:0}}>
            <div style={h2S}>Registration Codes</div>
            <div style={{fontSize:10,color:T.muted,marginBottom:18,padding:12,background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,lineHeight:1.7}}>
              These codes are embedded into exported MP3 files and can be sent to the label design. <strong style={{color:T.text}}>ISRC</strong> identifies a specific recording. <strong style={{color:T.text}}>UPC/EAN</strong> identifies the release as a product. <strong style={{color:T.text}}>ISWC</strong> identifies the composition.
            </div>
            <MF T={T} label="ISRC — International Standard Recording Code" hint="Format: CC-XXX-YY-NNNNN · e.g. GB-A3Z-23-00001 · Required for streaming, SoundExchange, PPL">
              <div style={{position:'relative'}}>
                <TInp T={T} value={meta.isrc} onChange={e=>setMeta('isrc',e.target.value.toUpperCase())} placeholder="GB-A3Z-23-00001" style={{borderColor:meta.isrc?(isrcValid(meta.isrc)?'#3fb950':'#f85149'):T.border,paddingRight:76}}/>
                <span style={{position:'absolute',right:8,top:'50%',transform:'translateY(-50%)',fontSize:8,color:meta.isrc?(isrcValid(meta.isrc)?'#3fb950':'#f85149'):T.muted}}>{meta.isrc?(isrcValid(meta.isrc)?'✓ VALID':'✗ FORMAT'):'XX-XXX-YY-NNNNN'}</span>
              </div>
            </MF>
            <MF T={T} label="UPC / EAN — Universal Product Code" hint="12-digit UPC-A or 13-digit EAN-13 · Obtain via GS1 or your distributor">
              <div style={{position:'relative'}}>
                <TInp T={T} value={meta.upc} onChange={e=>setMeta('upc',e.target.value)} placeholder="012345678905" style={{borderColor:meta.upc?(upcValid(meta.upc)?'#3fb950':'#f85149'):T.border,paddingRight:76}}/>
                <span style={{position:'absolute',right:8,top:'50%',transform:'translateY(-50%)',fontSize:8,color:meta.upc?(upcValid(meta.upc)?'#3fb950':'#f85149'):T.muted}}>{meta.upc?(upcValid(meta.upc)?'✓ VALID':'✗ 12–13 digits'):'12 or 13 digits'}</span>
              </div>
            </MF>
            <MF T={T} label="ISWC — Int'l Standard Musical Work Code" hint="Identifies the composition (not the recording) · Format: T-XXXXXXXXX-C · Assigned by your PRO (ASCAP, BMI, PRS, SOCAN)">
              <TInp T={T} value={meta.iswc} onChange={e=>setMeta('iswc',e.target.value.toUpperCase())} placeholder="T-345246800-1"/>
            </MF>
            <button onClick={()=>{setF('isrc',meta.isrc);setF('upc',meta.upc);setTab('studio');setStudioSubTab('label');saveLS('tl_studio_sub','label');}} style={{...mkBtn(T,true),width:'100%',padding:'10px 0',marginTop:8}}>→ Send ISRC + UPC to Label</button>
            </div>
            {/* Right — reference guide */}
            <div style={{flex:1,minWidth:0}}>
              <div style={{fontSize:8,letterSpacing:'0.2em',textTransform:'uppercase',color:T.muted,marginBottom:12}}>How to get your codes</div>

              {/* ISRC card */}
              <div style={{background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,padding:14,marginBottom:10}}>
                <div style={{fontSize:10,fontWeight:700,color:T.bright,marginBottom:8,letterSpacing:'0.06em'}}>ISRC — Two paths</div>
                <div style={{fontSize:9,color:T.accent,fontWeight:700,marginBottom:3,letterSpacing:'0.1em',textTransform:'uppercase'}}>Option 1 — Register yourself</div>
                <div style={{fontSize:9,color:T.text,lineHeight:1.7,marginBottom:6}}>
                  Apply through <a href="https://usisrc.org" target="_blank" rel="noopener" style={{color:T.accent}}>USISRC.org</a> (US) or your country's ISRC agency. You get your own registrant code and can issue unlimited ISRCs forever. One-time fee (~$95 in the US).
                </div>
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6,marginBottom:10}}>
                  <div style={{fontSize:8,color:'#3fb950',lineHeight:1.6}}><strong>✓ Pros</strong><br/>Full ownership of your codes<br/>Issue as many as you need<br/>No per-code cost after setup<br/>Professional credibility</div>
                  <div style={{fontSize:8,color:'#f85149',lineHeight:1.6}}><strong>✗ Cons</strong><br/>Upfront fee<br/>Application takes a few days<br/>You manage the registry</div>
                </div>
                <div style={{fontSize:9,color:T.accent,fontWeight:700,marginBottom:3,letterSpacing:'0.1em',textTransform:'uppercase'}}>Option 2 — Via distributor</div>
                <div style={{fontSize:9,color:T.text,lineHeight:1.7,marginBottom:4}}>
                  Most distributors (DistroKid, TuneCore, CD Baby, etc.) assign ISRCs automatically when you upload a release. Free, instant, no paperwork.
                </div>
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6}}>
                  <div style={{fontSize:8,color:'#3fb950',lineHeight:1.6}}><strong>✓ Pros</strong><br/>Free and automatic<br/>No setup required<br/>Handled for you</div>
                  <div style={{fontSize:8,color:'#f85149',lineHeight:1.6}}><strong>✗ Cons</strong><br/>Codes belong to distributor<br/>May be lost if you switch<br/>Less control overall</div>
                </div>
              </div>

              {/* UPC card */}
              <div style={{background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,padding:14}}>
                <div style={{fontSize:10,fontWeight:700,color:T.bright,marginBottom:8,letterSpacing:'0.06em'}}>UPC — Two paths</div>
                <div style={{fontSize:9,color:T.accent,fontWeight:700,marginBottom:3,letterSpacing:'0.1em',textTransform:'uppercase'}}>Option 1 — Register yourself</div>
                <div style={{fontSize:9,color:T.text,lineHeight:1.7,marginBottom:6}}>
                  Purchase a barcode prefix from <a href="https://www.gs1.org/services/get-barcodes" target="_blank" rel="noopener" style={{color:T.accent}}>GS1.org</a>. GS1 is the official authority; codes are globally unique and tied to your company. Annual fee based on how many products you need.
                </div>
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6,marginBottom:10}}>
                  <div style={{fontSize:8,color:'#3fb950',lineHeight:1.6}}><strong>✓ Pros</strong><br/>Officially recognized globally<br/>Your brand attached to codes<br/>Accepted everywhere</div>
                  <div style={{fontSize:8,color:'#f85149',lineHeight:1.6}}><strong>✗ Cons</strong><br/>Annual subscription fee<br/>Overkill for small releases</div>
                </div>
                <div style={{fontSize:9,color:T.accent,fontWeight:700,marginBottom:3,letterSpacing:'0.1em',textTransform:'uppercase'}}>Option 2 — Via distributor</div>
                <div style={{fontSize:9,color:T.text,lineHeight:1.7,marginBottom:4}}>
                  Distributors assign a UPC to each release automatically. Same trade-offs as ISRC — easy and free, but you don't own the code.
                </div>
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6}}>
                  <div style={{fontSize:8,color:'#3fb950',lineHeight:1.6}}><strong>✓ Pros</strong><br/>Free, instant, no effort<br/>Works for most use cases</div>
                  <div style={{fontSize:8,color:'#f85149',lineHeight:1.6}}><strong>✗ Cons</strong><br/>Tied to that distributor<br/>Not portable</div>
                </div>
              </div>
            </div>
          </div>
        )}
        {metaSection==='audio'&&(
          <div style={{maxWidth:540}}>
            <div style={h2S}>Audio File</div>
            <div style={{fontSize:10,color:T.muted,marginBottom:16,padding:12,background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,lineHeight:1.7}}>
              Upload your audio file. Existing ID3 tags will be read and will auto-fill fields above. The file is stored locally in IndexedDB. Use <strong style={{color:T.text}}>"Export Tagged MP3"</strong> to embed all your metadata — title, artist, BPM, ISRC, UPC, artwork, and more — into the file.
            </div>
            <input ref={audioRef} type="file" accept="audio/*,.mp3,.wav,.flac,.aiff,.aif,.m4a,.ogg" style={{display:'none'}} onChange={e=>e.target.files[0]&&loadAudioFile(e.target.files[0])}/>
            <div onClick={()=>audioRef.current.click()}
              style={{border:`2px dashed ${T.border}`,padding:32,textAlign:'center',cursor:'pointer',marginBottom:16,borderRadius:T.r||0,background:T.bg}}>
              <div style={{fontSize:32,opacity:0.15,marginBottom:8}}>🎵</div>
              <div style={{fontSize:12,color:T.text,marginBottom:4}}>{audioFile?audioFile.name:'Click or drag to upload audio'}</div>
              <div style={{fontSize:9,color:T.muted}}>{audioFile?`${audioFile.type} · ${fmtBytes(audioFile.size)}`:'MP3, WAV, FLAC, AIFF, M4A, OGG'}</div>
            </div>
            {audioFile&&(
              <div>
                {lufsAnalyzing&&(
                  <div style={{display:'flex',alignItems:'center',justifyContent:'center',gap:8,marginBottom:10,padding:'10px 12px',background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                    <span style={{display:'inline-block',animation:'tl-spin 0.7s linear infinite',fontSize:11}}>⟳</span>
                    <span style={{fontSize:9,color:T.muted,letterSpacing:'0.1em',textTransform:'uppercase'}}>Analyzing audio…</span>
                    <span style={{fontSize:8,color:T.muted,opacity:0.6}}>BS.1770-4 · EBU R128</span>
                  </div>
                )}
                {!lufsAnalyzing&&meta.lufs&&(
                  <div style={{marginBottom:10,padding:'10px 12px',background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                    <div style={{fontSize:8,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted,marginBottom:8,paddingBottom:6,borderBottom:`1px solid ${T.border}`}}>Audio Analysis</div>
                    <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'5px 12px'}}>
                      {[
                        ['LUFS',`${meta.lufs} LUFS`,parseFloat(meta.lufs)>=-14?'#3fb950':parseFloat(meta.lufs)>=-18?'#d29922':'#f85149'],
                        ['LRA',`${meta.lra} LU`,T.text],
                        ['PEAK',meta.samplePeak,parseFloat(meta.samplePeak)>=-1?'#f85149':parseFloat(meta.samplePeak)>=-6?'#d29922':'#3fb950'],
                        ['CREST',meta.crestFactor,T.text],
                        ['DC OFFSET',meta.dcOffset,parseFloat(meta.dcOffset)>0.5?'#d29922':T.text],
                      ].map(([label,val,col])=>(
                        <div key={label} style={{display:'flex',justifyContent:'space-between',alignItems:'baseline'}}>
                          <span style={{fontSize:8,color:T.muted,letterSpacing:'0.08em'}}>{label}</span>
                          <span style={{fontSize:10,fontWeight:700,color:col,fontFamily:'monospace'}}>{val}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                <div style={{display:'flex',alignItems:'center',gap:10,marginBottom:12,padding:'8px 12px',background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                  {/* Play/Pause — drives the shared audioElRef directly */}
                  <button
                    onClick={()=>{const el=audioElRef.current;if(!el||!audioObjectUrl)return;playing?el.pause():el.play();}}
                    disabled={!audioObjectUrl}
                    style={{width:34,height:34,borderRadius:'50%',border:`1px solid ${audioObjectUrl?T.accent:T.border}`,
                      background:audioObjectUrl?T.accent:'transparent',color:audioObjectUrl?T.bg:T.muted,
                      fontSize:12,cursor:audioObjectUrl?'pointer':'default',display:'flex',alignItems:'center',
                      justifyContent:'center',flexShrink:0,fontFamily:'inherit',lineHeight:1}}>
                    {playing?'⏸':'▶'}
                  </button>
                  <div style={{flex:1,minWidth:0}}>
                    <div style={{fontSize:10,color:T.text,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',fontWeight:600}}>
                      {meta.title||audioFile.name}
                    </div>
                    <div style={{fontSize:8,color:T.muted,marginTop:2}}>{audioFile.type} · {fmtBytes(audioFile.size)}</div>
                  </div>
                </div>
                <button onClick={exportTaggedAudio} style={{...mkBtn(T,true),width:'100%',padding:'10px 0',marginBottom:6}}>⬇ Export Tagged MP3</button>
                <div style={{fontSize:9,color:T.muted,textAlign:'center',lineHeight:1.6}}>Embeds: Title · Artist · Album · Year · Genre · BPM · ISRC · UPC · ISWC · Composer · Publisher · Copyright · Album Art · Comment · Mood · Producer</div>
              </div>
            )}
          </div>
        )}
        {metaSection==='art'&&(
          <div style={{maxWidth:460}}>
            <div style={h2S}>Album Art</div>
            <MF T={T} label="Output Size">
              <TSel T={T} value={meta.albumArtSize} onChange={e=>{setMeta('albumArtSize',e.target.value);}}>
                {ALBUM_ART_SIZES.map(s=><option key={s.val} value={s.val}>{s.label}</option>)}
              </TSel>
            </MF>
            <input ref={artRef} type="file" accept="image/*" style={{display:'none'}} onChange={e=>loadAlbumArt(e.target.files[0])}/>
            {meta.albumArt&&!meta.albumArt.startsWith('[stored]')?(
              <div>
                <div style={{width:'100%',aspectRatio:'1',marginBottom:10,position:'relative',overflow:'hidden',border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                  <img src={meta.albumArt} style={{width:'100%',height:'100%',objectFit:'cover',display:'block'}} alt="Album art"/>
                  <div style={{position:'absolute',top:8,right:8,background:'rgba(0,0,0,0.7)',color:'#fff',fontSize:9,padding:'3px 7px',borderRadius:T.r||0}}>{meta.albumArtSize}×{meta.albumArtSize}</div>
                </div>
                <div style={{display:'flex',gap:6,marginBottom:10}}>
                  <button onClick={()=>artRef.current.click()} style={{...mkBtn(T),flex:1,fontSize:9}}>↺ Replace</button>
                  <button onClick={()=>{const a=document.createElement('a');a.href=meta.albumArt;a.download=`${(meta.title||'artwork').replace(/\s+/g,'-')}-${meta.albumArtSize}px.jpg`;a.click();}} style={{...mkBtn(T,true),flex:1,fontSize:9}}>⬇ Export JPG</button>
                  <button onClick={()=>setMeta('albumArt',null)} style={{...mkBtn(T),fontSize:9,padding:'8px 10px',color:'#f87171'}}>✕</button>
                </div>
                <div style={{fontSize:9,color:T.muted,padding:10,background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,lineHeight:1.8}}>
                  <div><strong style={{color:T.text}}>Streaming (Apple, Spotify, Tidal)</strong> — 3000×3000 px minimum</div>
                  <div><strong style={{color:T.text}}>Bandcamp</strong> — 1400×1400 px minimum</div>
                  <div><strong style={{color:T.text}}>Physical CD</strong> — 300 DPI at print size (~1200×1200 for 4×4")</div>
                </div>
              </div>
            ):(
              <div onDragOver={e=>e.preventDefault()} onDrop={e=>{e.preventDefault();loadAlbumArt(e.dataTransfer.files[0]);}} onClick={()=>artRef.current.click()}
                style={{width:'100%',aspectRatio:'1',border:`2px dashed ${T.border}`,display:'flex',flexDirection:'column',alignItems:'center',justifyContent:'center',cursor:'pointer',gap:10,background:T.bg,borderRadius:T.r||0}}>
                <div style={{fontSize:40,opacity:0.15}}>🖼</div>
                <div style={{fontSize:11,color:T.muted,textAlign:'center',lineHeight:1.6}}>Click or drag to upload<br/>Auto-cropped to square at {meta.albumArtSize}×{meta.albumArtSize}px</div>
                <div style={{fontSize:8,color:T.muted}}>JPG · PNG · WEBP · TIFF</div>
              </div>
            )}
          </div>
        )}
        {metaSection==='analysis'&&(
          <div style={{width:'100%',minWidth:0}}>
            <AnalysisPanel T={T} meta={meta} audioFile={audioFile} lufsAnalyzing={lufsAnalyzing} recalculate={recalculateAnalysis}/>
          </div>
        )}
        {metaSection==='extra'&&(
          <div style={{maxWidth:540}}>
            <div style={h2S}>Extra Tags</div>
            {/* ── Audio Analysis block (read-only, auto-populated on file upload) ── */}
            <div style={{marginBottom:16,padding:'10px 12px',background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
              <div style={{fontSize:8,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted,marginBottom:10,display:'flex',justifyContent:'space-between',alignItems:'center'}}>
                <span>Audio Analysis — ITU-R BS.1770-4 / EBU R128</span>
                {lufsAnalyzing&&<span style={{display:'inline-block',animation:'tl-spin 0.7s linear infinite'}}>⟳</span>}
              </div>
              {[
                {key:'lufs',label:'Integrated Loudness',hint:'K-weighted integrated loudness (LUFS). Streaming targets: Spotify −14, Apple −16, YouTube −14.',
                  color:v=>parseFloat(v)>=-14?'#3fb950':parseFloat(v)>=-18?'#d29922':'#f85149',
                  badge:v=>parseFloat(v)>=-14?'▲ streaming-loud':parseFloat(v)>=-18?'◆ broadcast range':'▼ quiet master'},
                {key:'lra',label:'Loudness Range (LRA)',hint:'Difference between loud and quiet sections in Loudness Units. Higher = more dynamic. Typical music: 6–15 LU.',
                  color:()=>T.text,badge:()=>null},
                {key:'samplePeak',label:'Sample Peak',hint:'Highest absolute sample value in dBFS. Above −1 dBFS risks inter-sample clipping after encode.',
                  color:v=>parseFloat(v)>=-1?'#f85149':parseFloat(v)>=-6?'#d29922':'#3fb950',
                  badge:v=>parseFloat(v)>=-1?'▲ clipping risk':parseFloat(v)>=-6?'◆ hot':'▼ safe headroom'},
                {key:'crestFactor',label:'Crest Factor',hint:'Peak-to-RMS ratio in dB. Low values (< 8 dB) indicate heavy limiting/compression.',
                  color:()=>T.text,badge:()=>null},
                {key:'dcOffset',label:'DC Offset',hint:'Mean signal displacement as % of peak. Values above 0.5% may cause clicks at edit points and reduce headroom.',
                  color:v=>parseFloat(v)>0.5?'#d29922':T.text,
                  badge:v=>parseFloat(v)>0.5?'⚠ remove before mastering':null},
              ].map(({key,label,hint,color,badge})=>(
                <MF key={key} T={T} label={label} hint={hint}>
                  <div style={{position:'relative'}}>
                    <TInp T={T} value={lufsAnalyzing?'Analyzing…':(meta[key]||'')} readOnly
                      placeholder="Upload an audio file to analyze…"
                      style={{cursor:'default',
                        color:lufsAnalyzing?T.muted:(meta[key]?color(meta[key]):undefined),
                        fontWeight:(!lufsAnalyzing&&meta[key])?700:'normal',
                        fontStyle:lufsAnalyzing?'italic':undefined,
                        paddingRight:badge&&meta[key]&&!lufsAnalyzing?120:undefined}}/>
                    {!lufsAnalyzing&&meta[key]&&badge(meta[key])&&
                      <span style={{position:'absolute',right:8,top:'50%',transform:'translateY(-50%)',fontSize:7,color:T.muted,pointerEvents:'none',whiteSpace:'nowrap'}}>
                        {badge(meta[key])}
                      </span>}
                  </div>
                </MF>
              ))}
            </div>
            <MF T={T} label="Mood"><TInp T={T} value={meta.mood} onChange={e=>setMeta('mood',e.target.value)} placeholder="e.g. Dark, Hypnotic, Euphoric"/></MF>
            <MF T={T} label="Language"><TInp T={T} value={meta.language} onChange={e=>setMeta('language',e.target.value)} placeholder="e.g. English / eng"/></MF>
            <MF T={T} label="Grouping / Work"><TInp T={T} value={meta.grouping} onChange={e=>setMeta('grouping',e.target.value)} placeholder="Movement or work grouping"/></MF>
            <MF T={T} label="Encoder / Tool"><TInp T={T} value={meta.encoder} onChange={e=>setMeta('encoder',e.target.value)} placeholder="e.g. Ableton Live 12"/></MF>
            <MF T={T} label="Comment"><TTxt T={T} value={meta.comment} onChange={e=>setMeta('comment',e.target.value)} style={{minHeight:80}}/></MF>
          </div>
        )}
        {metaSection==='lyrics'&&(
          <div style={{maxWidth:600}}>
            <div style={h2S}>Lyrics / Notes</div>
            <MF T={T} label="Lyrics" hint="Full lyrics for this track. Not embedded in MP3 exports via the ID3 writer — use a dedicated tag editor (Mp3tag, Kid3) to embed USLT lyrics.">
              <div style={{position:'relative'}}>
                <TTxt T={T} value={meta.lyrics} onChange={e=>setMeta('lyrics',e.target.value)} style={{minHeight:260,fontFamily:'"Courier Prime",monospace',fontSize:12,lineHeight:1.8}}/>
                <div style={{position:'absolute',bottom:6,right:8,fontSize:7,color:T.muted,pointerEvents:'none'}}>
                  {meta.lyrics?(meta.lyrics.trim().split(/\n/).length)+' lines · '+(meta.lyrics.trim().split(/\s+/).filter(Boolean).length)+' words':'empty'}
                </div>
              </div>
            </MF>
            <MF T={T} label="Production Notes" hint="Private notes: session details, plugin chains, stem locations, mix references, etc. Never exported.">
              <TTxt T={T} value={meta.notes} onChange={e=>setMeta('notes',e.target.value)} style={{minHeight:120,fontSize:11,lineHeight:1.7}}/>
            </MF>
          </div>
        )}
        {metaSection==='splits'&&(
          <SplitSheet T={T} credits={credits} onChange={setCredits} trackTitle={meta.title||fields.title||''}/>
        )}
        {metaSection==='summary'&&(
          <div style={{maxWidth:560}}>
            <div style={h2S}>Tag Summary</div>
            <div style={{fontFamily:'monospace',fontSize:10,lineHeight:2.2,background:T.card,padding:16,border:`1px solid ${T.border}`,borderRadius:T.r||0,marginBottom:14}}>
              {[['TITLE',meta.title],['ARTIST',meta.artist],['ALBUM ARTIST',meta.albumArtist],['ALBUM',meta.album],['YEAR',meta.year],['TRACK',[meta.trackNum,meta.trackTotal].filter(Boolean).join('/')],['DISC',[meta.discNum,meta.discTotal].filter(Boolean).join('/')],['GENRE',meta.genre],['BPM',meta.bpm],['KEY',meta.key],['LUFS',meta.lufs||null],['LRA',meta.lra?`${meta.lra} LU`:null],['PEAK',meta.samplePeak||null],['CREST',meta.crestFactor||null],['DC OFFSET',meta.dcOffset||null],['ISRC',meta.isrc],['UPC',meta.upc],['ISWC',meta.iswc],['COMPOSER',meta.composer],['LYRICIST',meta.lyricist],['PRODUCER',meta.producer],['PUBLISHER',meta.publisher],['LABEL',meta.label],['CATALOG',meta.catalog],['COPYRIGHT',meta.copyright],['LANGUAGE',meta.language],['MOOD',meta.mood],['COMMENT',meta.comment]].filter(([,v])=>v).map(([k,v])=>{
                const analysisCols={
                  'LUFS':parseFloat(v)>=-14?'#3fb950':parseFloat(v)>=-18?'#d29922':'#f85149',
                  'PEAK':parseFloat(v)>=-1?'#f85149':parseFloat(v)>=-6?'#d29922':'#3fb950',
                  'DC OFFSET':parseFloat(v)>0.5?'#d29922':undefined,
                };
                const col=analysisCols[k]||T.bright;
                return(
                <div key={k} style={{display:'flex',gap:12,borderBottom:`1px solid ${T.border}44`,paddingBottom:1}}>
                  <span style={{color:T.muted,minWidth:120,flexShrink:0}}>{k}</span>
                  <span style={{color:col,flex:1,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',fontWeight:analysisCols[k]?700:'normal'}}>{v}</span>
                </div>
              );})}
              {meta.explicit&&<div style={{display:'flex',gap:12}}><span style={{color:T.muted,minWidth:120}}>EXPLICIT</span><span style={{color:T.bright}}>Yes</span></div>}
              {meta.albumArt&&<div style={{display:'flex',gap:12}}><span style={{color:T.muted,minWidth:120}}>ARTWORK</span><span style={{color:'#3fb950'}}>✓ {meta.albumArtSize}×{meta.albumArtSize}px embedded</span></div>}
              {audioFile&&<div style={{display:'flex',gap:12}}><span style={{color:T.muted,minWidth:120}}>AUDIO FILE</span><span style={{color:'#3fb950'}}>✓ {audioFile.name}</span></div>}
            </div>
            <div style={{display:'flex',gap:8}}>
              <button onClick={sendMetaToLabel} style={{...mkBtn(T,true),flex:1,padding:'9px 0',fontSize:9}}>→ Send All to Label</button>
              <button onClick={exportTaggedAudio} style={{...mkBtn(T),flex:1,padding:'9px 0',fontSize:9}}>⬇ Export Tagged MP3</button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
  // ━━━━━━━━ CLASSIFY TAB ━━━━━━━━
  const classifyTab=(
    <div style={{maxWidth:820,margin:'0 auto',padding:'24px 16px'}}>
      <div style={{padding:'14px 18px',marginBottom:16,background:T.card,border:`1px solid ${T.border}`,borderRadius:T.r||0,display:'flex',gap:14,alignItems:'flex-start'}}>
        <div style={{fontSize:22,flexShrink:0,opacity:0.5,lineHeight:1}}>◈</div>
        <div>
          <div style={{fontSize:10,fontWeight:700,color:T.bright,letterSpacing:'0.12em',textTransform:'uppercase',marginBottom:6}}>Personal Classification System</div>
          <div style={{fontSize:10,color:T.text,lineHeight:1.75,maxWidth:640}}>
            This is a <strong style={{color:T.bright}}>Track Lab–exclusive</strong> system for your own personal organization — it is not an industry standard, not recognized by streaming platforms, and carries no formal meaning outside of this app. Think of it as a private tagging shorthand: a four-character code that lets you quickly sort, search, and group your tracks by genre, mood, tempo, and texture in a way that makes sense to you.
          </div>
          <div style={{fontSize:9,color:T.muted,marginTop:8,lineHeight:1.65}}>
            Pick descriptors for each position, or hit <strong style={{color:T.muted}}>🎲 Random</strong> to generate one. Save codes to the Catalog to reuse them across tracks. Attach a code to the active archive entry with <strong style={{color:T.muted}}>⬆ Save to Entry</strong>. Use <strong style={{color:T.muted}}>📥 Export Guide</strong> to download the full reference sheet.
          </div>
        </div>
      </div>
      <div style={{...mkCard(T)}}>
        <div style={h2S}>Build Classification Code</div>
        <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12,marginBottom:14}}>
          {Object.entries(CLS).map(([key,data])=>(
            <div key={key}>
              <label style={mkLBL(T)}>{data.name}</label>
              <TSel T={T} value={sel[key]} onChange={e=>setSel({...sel,[key]:e.target.value})}>
                <option value="">— Random —</option>
                {Object.entries(data.options).map(([n,d])=><option key={n} value={n}>{n} — {d}</option>)}
              </TSel>
            </div>
          ))}
        </div>
        <div style={{display:'flex',gap:8}}>
          <button onClick={generateCode} style={{...mkBtn(T,true),flex:1,padding:'10px 0'}}>Generate Code</button>
          <button onClick={randomGenerate} style={{...mkBtn(T),padding:'10px 14px'}}>🎲 Random</button>
          <button onClick={exportGuide} style={{...mkBtn(T),padding:'10px 12px',fontSize:9}}>📥 Export Guide</button>
        </div>
      </div>
      {genCode&&(
        <div style={{...mkCard(T),textAlign:'center'}}>
          <div style={{fontSize:52,fontFamily:'monospace',fontWeight:700,color:T.accent,marginBottom:6,letterSpacing:'0.1em'}}>{genCode}</div>
          <div style={{fontSize:11,color:T.muted,marginBottom:16,lineHeight:1.5}}>{getCodeDesc(genCode)}</div>
          <div style={{display:'flex',gap:8,justifyContent:'center',flexWrap:'wrap'}}>
            <button onClick={()=>{navigator.clipboard.writeText(genCode);setCopied(true);setTimeout(()=>setCopied(false),2000);}} style={mkBtn(T)}>{copied?'✓ Copied':'📋 Copy'}</button>
            <button onClick={saveCode} style={mkBtn(T)}>💾 Save to Catalog</button>
            <button onClick={()=>sendToLabel(genCode)} style={mkBtn(T,true)}>🏷 Make Label →</button>
            {activeEid&&<button onClick={()=>{updateEntry(activeEid,{classCode:genCode});setF('classCode',genCode);setF('classDesc',getCodeDesc(genCode));}} style={mkBtn(T)}>⬆ Save to Entry</button>}
          </div>
        </div>
      )}
      <div style={{...mkCard(T)}}>
        <div style={h2S}>Decode a Code</div>
        <div style={{display:'flex',gap:8,marginBottom:12}}>
          <TInp T={T} value={decInput} onChange={e=>setDecInput(e.target.value)} onKeyDown={e=>e.key==='Enter'&&decodeCode()} placeholder="e.g. 142.7 or S3K.F" style={{flex:1,fontSize:16,fontFamily:'monospace',letterSpacing:'0.15em'}}/>
          <button onClick={decodeCode} style={{...mkBtn(T,true),padding:'8px 18px'}}>Decode</button>
        </div>
        {decResult&&(
          <div style={{padding:14,background:decResult.valid?rgba(T.accent,0.06):rgba('#f85149',0.08),border:`1px solid ${decResult.valid?rgba(T.accent,0.3):'#5a1e1e'}`,borderRadius:T.r||0}}>
            {decResult.valid?(
              <div>
                <div style={{fontSize:36,fontFamily:'monospace',fontWeight:700,color:T.accent,textAlign:'center',marginBottom:6,letterSpacing:'0.1em'}}>{decResult.code}</div>
                <div style={{fontSize:10,color:T.muted,textAlign:'center',marginBottom:14,paddingBottom:12,borderBottom:`1px solid ${T.border}`}}>{decResult.full}</div>
                <div style={{display:'flex',flexDirection:'column',gap:5,marginBottom:14}}>
                  {decResult.bd.map(item=>(
                    <div key={item.p} style={{display:'flex',alignItems:'flex-start',gap:10,padding:'8px 10px',background:T.bg,borderRadius:T.r||0,border:`1px solid ${T.border}`}}>
                      <div style={{width:28,height:28,borderRadius:'50%',background:T.accent,color:T.bg,display:'flex',alignItems:'center',justifyContent:'center',fontFamily:'monospace',fontWeight:700,flexShrink:0,fontSize:13}}>{item.v}</div>
                      <div><div style={{fontSize:8,color:T.muted,letterSpacing:'0.1em',marginBottom:2}}>{item.cat}</div><div style={{fontSize:12,color:T.bright}}>{item.m}</div></div>
                    </div>
                  ))}
                </div>
                <button onClick={()=>sendToLabel(decResult.code)} style={{...mkBtn(T,true),width:'100%',padding:'10px 0'}}>🏷 Send to Label →</button>
              </div>
            ):(
              <div style={{color:'#f85149',textAlign:'center',fontSize:12}}>{decResult.error}</div>
            )}
          </div>
        )}
      </div>
      <div style={mkCard(T)}>
        <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',cursor:'pointer'}} onClick={()=>setShowGuide(!showGuide)}>
          <span style={{fontSize:10,color:T.text}}>Classification Reference Guide</span>
          <span style={{color:T.accent,fontSize:10}}>{showGuide?'▴ Hide':'▾ Show'}</span>
        </div>
        {showGuide&&(
          <div style={{marginTop:14,display:'flex',flexDirection:'column',gap:10}}>
            {Object.entries(CLS).map(([k,d])=>(
              <div key={k} style={{background:T.bg,padding:12,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                <div style={{fontSize:10,fontWeight:700,color:T.accent,marginBottom:8}}>Position {k.replace('digit','')}: {d.name}</div>
                <div style={{display:'grid',gridTemplateColumns:'repeat(auto-fill,minmax(200px,1fr))',gap:3}}>
                  {Object.entries(d.options).map(([n,dd])=>(
                    <div key={n} style={{fontSize:9,color:T.text,display:'flex',gap:6}}>
                      <span style={{fontFamily:'monospace',fontWeight:700,color:T.accent,minWidth:14}}>{n}</span>
                      <span style={{color:T.muted}}>{dd}</span>
                    </div>
                  ))}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );

  // ━━━━━━━━ LABEL TAB ━━━━━━━━
  // Derived batch values — must precede labelTab JSX since they're referenced inline
  const batchDone=batchProgress?.done??0;
  const batchTotal=batchProgress?.total??0;
  const batchPct=batchTotal>0?Math.round(batchDone/batchTotal*100):0;
  const batchOk=batchLog.filter(r=>r.ok).length;
  const batchFail=batchLog.filter(r=>!r.ok).length;
  const labelTab=(
    <div style={{display:'flex',minHeight:'calc(100vh - 88px)'}}>
      {/* PANEL */}
      <div style={{width:labelPanel.width,flexShrink:0,background:T.panel,borderRight:labelPanel.collapsed?'none':`1px solid ${T.border}`,display:'flex',flexDirection:'column',overflow:'hidden',position:'relative',transition:'width 0.15s'}}>
        <div {...labelPanel.handle}/>
        {labelPanel.tab}
        <div style={{display:'flex',borderBottom:`1px solid ${T.border}`,flexShrink:0}}>
          {[['content','Content'],['style','Style'],['presets','Presets']].map(([id,lbl])=>(
            <button key={id} onClick={()=>setPanelTab(id)} style={{flex:1,padding:'9px 0',background:'transparent',color:panelTab===id?T.accent:T.muted,border:'none',borderBottom:panelTab===id?`2px solid ${T.accent}`:'2px solid transparent',fontFamily:'inherit',fontSize:8,letterSpacing:'0.12em',textTransform:'uppercase',cursor:'pointer'}}>
              {lbl}
            </button>
          ))}
        </div>
        <div style={{flex:1,overflowY:'auto',padding:'8px 12px'}}>
          {panelTab==='content'&&(
            <>
              {/* ── ID3 AUTO-FILL ─────────────────────────────────────── */}
              <div style={{marginBottom:8,padding:'8px 10px',background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0}}>
                <div style={{fontSize:7,letterSpacing:'0.18em',textTransform:'uppercase',color:T.muted,marginBottom:6}}>Auto-fill from Audio File</div>
                <input ref={labelTagFileRef} type="file" accept="audio/*,.mp3,.wav,.flac,.aiff,.aif,.m4a,.ogg" style={{display:'none'}}
                  onChange={e=>{const f=e.target.files[0];if(f)readLabelTags(f);e.target.value='';}}/>
                {/* Drop zone */}
                <div
                  onClick={()=>labelTagFileRef.current.click()}
                  onDragOver={e=>e.preventDefault()}
                  onDrop={e=>{e.preventDefault();const f=e.dataTransfer.files[0];if(f)readLabelTags(f);}}
                  style={{
                    border:`1px dashed ${labelTagStatus==='reading'?T.accent:T.border}`,
                    padding:'8px 10px',textAlign:'center',cursor:'pointer',
                    borderRadius:T.r||0,background:T.panel,transition:'border-color 0.15s',
                  }}
                >
                  {labelTagStatus==='reading'
                    ?<span style={{fontSize:9,color:T.accent,letterSpacing:'0.1em'}}><span className="tl-spin" style={{marginRight:5}}>↻</span>Reading tags…</span>
                    :<span style={{fontSize:9,color:T.muted}}>Drop audio · or click to pick file</span>
                  }
                </div>
                {/* Result strip */}
                {labelTagStatus&&labelTagStatus!=='reading'&&(
                  <div style={{marginTop:6,fontSize:8,lineHeight:1.7}}>
                    {labelTagStatus.err
                      ?<span style={{color:'#f87171'}}>✗ {labelTagStatus.err}</span>
                      :(()=>{
                          const {found,filled}=labelTagStatus;
                          const rows=[
                            ['Title',   found.title,  filled.title],
                            ['Artist',  found.artist, filled.artist],
                            ['BPM',     found.bpm,    filled.bpm],
                          ].filter(([,v])=>v);
                          if(!rows.length)return<span style={{color:T.muted}}>No title / artist / BPM tags found in this file.</span>;
                          return rows.map(([label,val,wasFilled])=>(
                            <div key={label} style={{display:'flex',gap:6,alignItems:'center'}}>
                              <span style={{color:T.muted,minWidth:36}}>{label}</span>
                              <span style={{color:wasFilled?T.accent:T.muted,flex:1,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{val||'—'}</span>
                              <span style={{fontSize:7,color:wasFilled?'#3fb950':T.muted,flexShrink:0,letterSpacing:'0.06em'}}>{wasFilled?'FILLED':'SKIPPED'}</span>
                            </div>
                          ));
                        })()
                    }
                  </div>
                )}
              </div>
              {/* ────────────────────────────────────────────────────────── */}
              <Accordion T={T} title="Identity" defaultOpen>
                <F T={T} label="Artist / Project"><TInp T={T} value={fields.artist} onChange={e=>setF('artist',e.target.value)}/></F>
                <Row2>
                  <F T={T} label="Catalog #"><TInp T={T} value={fields.catalog} onChange={e=>setF('catalog',e.target.value)}/></F>
                  <F T={T} label="Track #"><TInp T={T} value={fields.trackNum} onChange={e=>setF('trackNum',e.target.value)}/></F>
                </Row2>
              </Accordion>
              <Accordion T={T} title="Track Title" defaultOpen>
                <TInp T={T} value={fields.title} onChange={e=>setF('title',e.target.value)}/>
              </Accordion>
              <Accordion T={T} title="Meta Row Fields">
                <MetaFieldsPanel T={T} settings={settings} setS={setS}/>
              </Accordion>
              <Accordion T={T} title="Classification Code">
                <Row2>
                  <F T={T} label="Code (XXX.X)"><TInp T={T} value={fields.classCode} onChange={e=>{setF('classCode',e.target.value.toUpperCase());setF('classDesc',getCodeDesc(e.target.value.toUpperCase()));}}/></F>
                  <F T={T} label=" "><button onClick={()=>setTab('classify')} style={{...mkBtn(T),width:'100%',marginTop:11,fontSize:9}}>← Classify</button></F>
                </Row2>
                {fields.classCode&&<div style={{fontSize:9,color:T.muted,marginBottom:6,lineHeight:1.4}}>{getCodeDesc(fields.classCode)||'Enter a valid code'}</div>}
                <Tog T={T} label="Show code on label" value={settings.showClass} onChange={v=>setS({showClass:v})}/>
              </Accordion>
              <Accordion T={T} title="ISRC / UPC">
                <Row2>
                  <F T={T} label="ISRC"><TInp T={T} value={fields.isrc} onChange={e=>setF('isrc',e.target.value)}/></F>
                  <F T={T} label="UPC / EAN"><TInp T={T} value={fields.upc} onChange={e=>setF('upc',e.target.value)}/></F>
                </Row2>
                <Tog T={T} label="Show codes on label" value={settings.showCodes} onChange={v=>setS({showCodes:v})}/>
                <Tog T={T} label="Codes in footer strip" value={settings.codesInFooter} onChange={v=>setS({codesInFooter:v})}/>
              </Accordion>
              <Accordion T={T} title="Notes / Description">
                <TTxt T={T} value={fields.description} onChange={e=>setF('description',e.target.value)} style={{minHeight:72}}/>
                <Tog T={T} label="Show notes" value={settings.showDesc} onChange={v=>setS({showDesc:v})}/>
              </Accordion>
              <Accordion T={T} title="Tags">
                <div style={{fontSize:9,color:T.muted,marginBottom:4}}>Comma-separated</div>
                <TInp T={T} value={fields.tags} onChange={e=>setF('tags',e.target.value)} placeholder="dark, industrial, hypnotic"/>
                <Tog T={T} label="Show tags" value={settings.showTags} onChange={v=>setS({showTags:v})}/>
              </Accordion>
              <Accordion T={T} title="QR Code / URL">
                <F T={T} label="URL"><TInp T={T} value={fields.url} onChange={e=>setF('url',e.target.value)} placeholder="https://soundcloud.com/…"/></F>
                <F T={T} label="QR Caption"><TInp T={T} value={settings.qrCaption} onChange={e=>setS({qrCaption:e.target.value})}/></F>
                <Tog T={T} label="Show QR code" value={settings.showQR} onChange={v=>setS({showQR:v})}/>
                <Tog T={T} label="Float QR (free position)" value={settings.qrFloat} onChange={v=>setS({qrFloat:v})}/>
                {settings.qrFloat&&<Row2><F T={T} label="X px"><TInp T={T} type="number" value={settings.qrFloatX} onChange={e=>setS({qrFloatX:+e.target.value})}/></F><F T={T} label="Y px"><TInp T={T} type="number" value={settings.qrFloatY} onChange={e=>setS({qrFloatY:+e.target.value})}/></F></Row2>}
              </Accordion>
              <Accordion T={T} title="Dithered Image">
                <DitherPanel T={T} settings={settings} setS={setS}/>
              </Accordion>
              <Accordion T={T} title="Free Text Blocks">
                <TextBlocksPanel T={T} settings={settings} setS={setS}/>
              </Accordion>
              <div style={{marginTop:10}}>
                <button onClick={sendMetaToLabel} style={{...mkBtn(T,true),width:'100%',padding:'8px 0',fontSize:9}}>← Pull from Tags</button>
              </div>
            </>
          )}
          {panelTab==='style'&&(
            <>
              <Accordion T={T} title="Size & Dimensions" defaultOpen>
                <div style={{display:'flex',flexWrap:'wrap',gap:4,marginBottom:8}}>
                  {SIZE_PRESETS.map(p=><button key={p.name} onClick={()=>setS({labelW:p.w,labelH:p.h})} style={{...mkBtn(T,(settings.labelW===p.w&&settings.labelH===p.h)),padding:'4px 7px',fontSize:8}}>{p.name}</button>)}
                </div>
                <Row2>
                  <F T={T} label="W px"><TInp T={T} type="number" min={100} max={1200} value={settings.labelW} onChange={e=>setS({labelW:+e.target.value})}/></F>
                  <F T={T} label="H px"><TInp T={T} type="number" min={100} max={1200} value={settings.labelH} onChange={e=>setS({labelH:+e.target.value})}/></F>
                </Row2>
                <F T={T} label={`Outer border: ${settings.outerBorder}px`}><input type="range" min={0} max={10} value={settings.outerBorder} onChange={e=>setS({outerBorder:+e.target.value})} style={{width:'100%'}}/></F>
              </Accordion>
              <Accordion T={T} title="Color Scheme" defaultOpen>
                <div style={{display:'flex',flexWrap:'wrap',gap:4,marginBottom:8}}>
                  {Object.entries(BASE_SCHEMES).map(([key,sc])=>(
                    <button key={key} onClick={()=>setS({scheme:key})} style={{...mkBtn(T,settings.scheme===key),padding:'4px 8px',fontSize:8}}>{sc.n}</button>
                  ))}
                </div>
                <Tog T={T} label="Background gradient" value={settings.useGradient} onChange={v=>setS({useGradient:v})}/>
                {settings.scheme==='custom'&&(
                  <div style={{marginTop:8}}>
                    {[['bg','Background'],['fg','Foreground'],['bannerBg','Banner BG'],['bannerFg','Banner FG'],['metaBg','Meta Bar BG'],['metaFg','Meta Bar FG'],['accent','Accent'],['sub','Subtext'],['border','Borders'],['strip','Footer Strip'],['codeBg','Code BG'],['codeFg','Code Text']].map(([k,lbl])=>(
                      <ColorRow key={k} T={T} label={lbl} hex={settings.customColors[k]} onHex={hex=>setS(s=>({...s,scheme:'custom',customColors:{...s.customColors,[k]:hex}}))}/>
                    ))}
                    <ColorRow T={T} label="Gradient Color 2" hex={settings.gradColor2} onHex={hex=>setS({gradColor2:hex})}/>
                  </div>
                )}
              </Accordion>
              <Accordion T={T} title="Font">
                <F T={T} label="Font Family"><TSel T={T} value={settings.font} onChange={e=>setS({font:e.target.value})}>{Object.entries(FONTS).map(([k,f])=><option key={k} value={k}>{f.name}</option>)}</TSel></F>
              </Accordion>
              <Accordion T={T} title="Typography">
                <div style={{fontSize:9,color:T.accent,marginBottom:6,letterSpacing:'0.1em'}}>ARTIST</div>
                <Row2><F T={T} label="Size"><TInp T={T} type="number" min={8} max={40} value={settings.artistSize} onChange={e=>setS({artistSize:+e.target.value})}/></F><div style={{display:'flex',gap:6,alignItems:'flex-end',paddingBottom:7}}><Tog T={T} label="Bold" value={settings.artistBold} onChange={v=>setS({artistBold:v})}/><Tog T={T} label="Italic" value={settings.artistItalic} onChange={v=>setS({artistItalic:v})}/></div></Row2>
                <div style={{fontSize:9,color:T.accent,marginBottom:6,letterSpacing:'0.1em'}}>TITLE</div>
                <Row2><F T={T} label="Size"><TInp T={T} type="number" min={10} max={72} value={settings.titleSize} onChange={e=>setS({titleSize:+e.target.value})}/></F><div style={{display:'flex',gap:6,alignItems:'flex-end',paddingBottom:7}}><Tog T={T} label="Bold" value={settings.titleBold} onChange={v=>setS({titleBold:v})}/><Tog T={T} label="Italic" value={settings.titleItalic} onChange={v=>setS({titleItalic:v})}/></div></Row2>
                <F T={T} label="Title Align"><TSel T={T} value={settings.titleAlign} onChange={e=>setS({titleAlign:e.target.value})}><option value="left">Left</option><option value="center">Center</option><option value="right">Right</option></TSel></F>
                <div style={{fontSize:9,color:T.accent,marginBottom:6,letterSpacing:'0.1em'}}>BODY TEXT</div>
                <Row2><F T={T} label="Size"><TInp T={T} type="number" min={6} max={20} value={settings.bodySize} onChange={e=>setS({bodySize:+e.target.value})}/></F><F T={T} label="Meta Size"><TInp T={T} type="number" min={6} max={20} value={settings.metaSize} onChange={e=>setS({metaSize:+e.target.value})}/></F></Row2>
              </Accordion>
              <Accordion T={T} title="Sections & Borders">
                {[['showBanner','Artist Banner'],['showMeta','Meta Row'],['showClass','Classification'],['showDesc','Notes'],['showTags','Tags'],['showCodes','ISRC/UPC Bar'],['showQR','QR Code'],['showFooter','Footer Strip']].map(([k,lbl])=>(
                  <Tog key={k} T={T} label={lbl} value={settings[k]} onChange={v=>setS({[k]:v})}/>
                ))}
                <div style={{borderTop:`1px solid ${T.border}`,marginTop:8,paddingTop:8}}>
                  <div style={{fontSize:8,color:T.muted,marginBottom:6,letterSpacing:'0.12em',textTransform:'uppercase'}}>Section Dividers</div>
                  {Object.keys(settings.borders||{}).map(k=>(
                    <Tog key={k} T={T} label={k.replace(/([A-Z])/g,' $1').replace(/^./,s=>s.toUpperCase())} value={settings.borders[k]} onChange={v=>setS(s=>({...s,borders:{...s.borders,[k]:v}}))}/>
                  ))}
                </div>
              </Accordion>
            </>
          )}
          {panelTab==='presets'&&(
            <PresetPanel T={T} settings={settings} presets={presets} lastId={lastPid}
              onSave={name=>{const p={id:mkUid(),name,settings:{...settings}};setPresets([...presets,p]);}}
              onLoad={p=>{setS(()=>({...DEFAULT_SETTINGS,...p.settings}));setLastPid(p.id);saveLS('tl_last_preset',p.id);}}
              onDelete={id=>setPresets(presets.filter(p=>p.id!==id))}/>
          )}
        </div>
        <div style={{padding:'8px 12px',paddingBottom:12,borderTop:`1px solid ${T.border}`,flexShrink:0,display:'flex',flexDirection:'column',gap:5}}>
          <div style={{display:'flex',gap:6}}>
            <TSel T={T} value={settings.exportFormat} onChange={e=>setS({exportFormat:e.target.value})} style={{flex:1}}>
              <option value="png">PNG</option><option value="jpeg">JPG</option>
            </TSel>
            <TSel T={T} value={settings.exportScale} onChange={e=>setS({exportScale:+e.target.value})} style={{width:70}}>
              <option value={1}>1×</option><option value={2}>2×</option><option value={3}>3×</option><option value={4}>4×</option>
            </TSel>
          </div>
          <button onClick={exportLabel} disabled={exporting} style={{...mkBtn(T,true),width:'100%',padding:'10px 0'}}>
            {exporting?'Rendering…':'⬇ Export Label'}
          </button>
          {exportMsg&&<div style={{fontSize:9,color:T.muted,textAlign:'center'}}>{exportMsg}</div>}
          <button onClick={()=>setShowBatch(b=>!b)} style={{...mkBtn(T,true),width:'100%',padding:'10px 0'}}>
            {showBatch?'✕ Close Batch':'⊞ Batch Export…'}
          </button>
        </div>
      </div>
      {labelPanel.expandStub}
      {/* PREVIEW / BATCH PANEL */}
      {showBatch?(
        /* ── INLINE BATCH PANEL ── */
        <div style={{flex:1,display:'flex',overflowY:'auto'}}>
          {/* Controls column */}
          {batchPanel.expandStub}
          <div style={{width:batchPanel.width,flexShrink:0,borderLeft:batchPanel.collapsed?'none':`1px solid ${T.border}`,display:'flex',flexDirection:'column',overflow:'hidden',background:T.panel,position:'relative',transition:'width 0.15s'}}>
            <div {...batchPanel.handle}/>
            {batchPanel.tab}
            <div style={{padding:'10px 12px 8px',borderBottom:`1px solid ${T.border}`,flexShrink:0}}>
              <div style={{fontSize:10,fontWeight:700,color:T.bright,letterSpacing:'0.06em',marginBottom:1}}>Batch Label Export</div>
              <div style={{fontSize:7,color:T.muted,lineHeight:1.5}}>Select tracks · configure · export ZIP of PNG labels</div>
            </div>
            <div style={{flex:1,overflowY:'auto',padding:'10px 12px'}}>
              {/* Profile filter */}
              <div style={{marginBottom:9}}>
                <label style={mkLBL(T)}>Profile</label>
                <select value={batchPidFilter} onChange={e=>{setBatchPidFilter(e.target.value);batchSelectNone();}} style={{...mkIS(T),fontSize:10}}>
                  <option value="all">All Profiles ({entries.length})</option>
                  {profiles.map(p=>(
                    <option key={p.id} value={p.id}>{p.name} ({entries.filter(e=>e.profileId===p.id).length})</option>
                  ))}
                </select>
              </div>
              {/* Scale */}
              <div style={{marginBottom:9}}>
                <label style={mkLBL(T)}>Export Scale</label>
                <div style={{display:'flex',gap:3}}>
                  {[[1,'1×'],[2,'2×'],[3,'3×'],[4,'4×']].map(([v,lbl])=>(
                    <button key={v} onClick={()=>setBatchScale(v)} style={{...mkBtn(T,batchScale===v),flex:1,padding:'4px 0',fontSize:9}}>{lbl}</button>
                  ))}
                </div>
                <div style={{fontSize:7,color:T.muted,marginTop:3}}>384×576 → {384*batchScale}×{576*batchScale}px</div>
              </div>
              {/* Stats strip */}
              <div style={{display:'flex',gap:0,background:T.bg,border:`1px solid ${T.border}`,borderRadius:T.r||0,marginBottom:9,overflow:'hidden'}}>
                {[['Selected',batchIds.size,batchIds.size>0?T.accent:T.muted],['Visible',batchVisibleEntries.length,T.bright],['Total',entries.length,T.bright]].map(([lbl,val,col],i)=>(
                  <div key={lbl} style={{flex:1,padding:'6px 8px',borderLeft:i>0?`1px solid ${T.border}`:'none',textAlign:'center'}}>
                    <div style={{fontSize:12,fontWeight:700,color:col,lineHeight:1}}>{val}</div>
                    <div style={{fontSize:6,color:T.muted,letterSpacing:'0.1em',textTransform:'uppercase',marginTop:2}}>{lbl}</div>
                  </div>
                ))}
              </div>
              {/* Progress */}
              {batchProgress&&(
                <div style={{marginBottom:9}}>
                  <div style={{display:'flex',justifyContent:'space-between',marginBottom:3}}>
                    <span style={{fontSize:7,color:T.text}}>{batchRunning?'Rendering…':'Complete'}</span>
                    <span style={{fontSize:7,color:T.accent,fontVariantNumeric:'tabular-nums'}}>{batchDone}/{batchTotal} · {batchPct}%</span>
                  </div>
                  <div style={{height:3,background:T.muted,borderRadius:2,overflow:'hidden',marginBottom:5}}>
                    <div style={{height:'100%',width:`${batchPct}%`,background:T.accent,borderRadius:2,transition:'width 0.2s ease'}}/>
                  </div>
                  {batchRunning&&batchProgress.currentTitle&&(
                    <div style={{fontSize:7,color:T.muted,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>
                      <span className="tl-spin" style={{marginRight:3}}>↻</span>{batchProgress.currentTitle}
                    </div>
                  )}
                  {!batchRunning&&batchLog.length>0&&(
                    <div style={{fontSize:7,display:'flex',gap:10,marginTop:2}}>
                      <span style={{color:'#3fb950'}}>✓ {batchOk} ok</span>
                      {batchFail>0&&<span style={{color:'#f87171'}}>✗ {batchFail} failed</span>}
                    </div>
                  )}
                </div>
              )}
              {/* Log */}
              {batchLog.length>0&&(
                <div>
                  <div style={{fontSize:7,letterSpacing:'0.15em',textTransform:'uppercase',color:T.muted,marginBottom:4}}>Render Log</div>
                  <div style={{maxHeight:160,overflowY:'auto',display:'flex',flexDirection:'column',gap:2}}>
                    {batchLog.map((row,i)=>(
                      <div key={i} style={{display:'flex',alignItems:'center',gap:5,padding:'2px 5px',background:row.ok?T.bg:'#f871711a',border:`1px solid ${row.ok?T.border:'#f8717133'}`,borderRadius:T.r||0,fontSize:7}}>
                        <span style={{color:row.ok?'#3fb950':'#f87171',flexShrink:0}}>{row.ok?'✓':'✗'}</span>
                        <span style={{color:T.text,flex:1,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{row.title}</span>
                        {!row.ok&&row.msg&&<span style={{color:'#f87171',flexShrink:0,maxWidth:60,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}} title={row.msg}>{row.msg}</span>}
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
            {/* Export footer */}
            <div style={{padding:'8px 12px 10px',borderTop:`1px solid ${T.border}`,flexShrink:0,display:'flex',flexDirection:'column',gap:5}}>
              <button onClick={batchExport} disabled={batchRunning||batchIds.size===0}
                style={{...mkBtn(T,true),width:'100%',padding:'9px 0',fontSize:9,opacity:(batchRunning||batchIds.size===0)?0.45:1,transition:'opacity 0.15s'}}>
                {batchRunning
                  ?<><span className="tl-spin" style={{marginRight:5}}>↻</span>Rendering {batchDone}/{batchTotal}…</>
                  :`⬇ Export ${batchIds.size||'…'} Label${batchIds.size!==1?'s':''}`}
              </button>
              <div style={{fontSize:7,color:T.muted,textAlign:'center'}}>PNG · {batchScale}× · labels/ folder</div>
            </div>
          </div>
          {/* Checklist column */}
          <div style={{flex:1,display:'flex',flexDirection:'column',overflowY:'auto'}}>
            <div style={{padding:'8px 14px',borderBottom:`1px solid ${T.border}`,flexShrink:0,background:T.panel,display:'flex',alignItems:'center',gap:6}}>
              <button onClick={batchSelectAll} disabled={batchRunning} style={{...mkBtn(T),padding:'3px 9px',fontSize:8,opacity:batchRunning?0.4:1}}>All</button>
              <button onClick={batchSelectNone} disabled={batchRunning||batchIds.size===0} style={{...mkBtn(T),padding:'3px 9px',fontSize:8,opacity:(batchRunning||batchIds.size===0)?0.4:1}}>None</button>
              <div style={{flex:1}}/>
              <span style={{fontSize:7,color:T.muted}}>{batchVisibleEntries.length} tracks</span>
            </div>
            <div style={{flex:1,overflowY:'auto',padding:'8px 12px'}}>
              {entries.length===0?(
                <div style={{...mkCard(T),textAlign:'center',padding:40}}>
                  <div style={{fontSize:24,opacity:0.12,marginBottom:8}}>◈</div>
                  <div style={{fontSize:8,color:T.muted,lineHeight:1.8}}>No archive entries yet.</div>
                </div>
              ):batchVisibleEntries.map(e=>{
                const sel=batchIds.has(e.id);
                const st=STATUS_OPT[e.status||'draft'];
                const hasLabel=!!(e.labelFields||e.labelSettings);
                return(
                  <div key={e.id} onClick={()=>!batchRunning&&toggleBatchId(e.id)}
                    style={{display:'flex',alignItems:'center',gap:8,padding:'7px 9px',marginBottom:3,
                      background:sel?T.panel:T.card,border:`1px solid ${sel?T.accent:T.border}`,
                      borderRadius:(T.r||0)*1.5,cursor:batchRunning?'default':'pointer',
                      opacity:batchRunning?0.6:1,transition:'border-color 0.1s,background 0.1s'}}>
                    <div style={{flexShrink:0,width:14,height:14,border:`1px solid ${sel?T.accent:T.border}`,borderRadius:2,
                      background:sel?T.accent:'transparent',display:'flex',alignItems:'center',justifyContent:'center',
                      color:sel?T.bg:T.muted,fontSize:9,lineHeight:1}}>{sel?'✓':''}</div>
                    <div style={{flex:1,minWidth:0}}>
                      <div style={{display:'flex',alignItems:'baseline',gap:5,marginBottom:1}}>
                        <span style={{fontSize:10,fontWeight:700,color:T.bright,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{e.title||'Untitled'}</span>
                        {(e.created||e.updated)&&<span style={{fontSize:6,color:T.muted,flexShrink:0}}>{fmtDate(e.created||e.updated)}</span>}
                      </div>
                      <div style={{display:'flex',gap:5,alignItems:'center'}}>
                        <span style={{fontSize:8,color:T.muted,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',maxWidth:90}}>{e.artist||'—'}</span>
                        {e.classCode&&<span style={{fontFamily:'monospace',fontSize:7,color:T.accent}}>{e.classCode}</span>}
                        <span style={{fontSize:6,color:st.color,border:`1px solid ${st.color}44`,padding:'1px 3px',borderRadius:T.r||0,flexShrink:0}}>{st.label}</span>
                        <span style={{fontSize:6,color:hasLabel?'#3fb950':T.muted,flexShrink:0}}>{hasLabel?'🏷':'·'}</span>
                      </div>
                    </div>
                    {batchPidFilter==='all'&&(
                      <span style={{fontSize:6,color:T.muted,border:`1px solid ${T.border}`,padding:'1px 4px',borderRadius:T.r||0,flexShrink:0,maxWidth:60,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>
                        {profiles.find(p=>p.id===e.profileId)?.name||'?'}
                      </span>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      ):(
        /* ── LABEL PREVIEW ── */
        <div style={{flex:1,overflowY:'auto',display:'flex',alignItems:'flex-start',justifyContent:'center',padding:24,background:`${T.bg}cc`}}>
          {/* scale wrapper — position:relative so the interactive overlay can be absolutely placed */}
          <div style={{position:'relative',transform:`scale(${prevScale})`,transformOrigin:'top center',flexShrink:0}}>
            <TrackLabel fields={fields} settings={settings}/>
            {/* Interactive image overlay — only rendered when image is active */}
            {settings.showImage&&settings.imageData&&(
              <div
                onMouseDown={onImgDragStart}
                style={{
                  position:'absolute',
                  left:settings.imageX,
                  top:settings.imageY,
                  // During resize drag: show the live preview size, else the committed size
                  width:dragImgSize?dragImgSize.w:settings.imageW,
                  height:dragImgSize?dragImgSize.h:settings.imageH,
                  zIndex:30,
                  cursor:'move',
                  boxSizing:'border-box',
                  border:`1px dashed ${T.accent}99`,
                  outline:`1px dashed ${T.bg}55`,
                  userSelect:'none',
                }}>
                {/* Corner label showing live px values */}
                <div style={{
                  position:'absolute',top:2,left:3,
                  fontSize:7,lineHeight:1,color:T.accent,
                  fontFamily:'monospace',opacity:0.85,
                  pointerEvents:'none',letterSpacing:'0.04em',
                  textShadow:`0 0 4px ${T.bg}`,
                }}>
                  {dragImgSize
                    ?`${dragImgSize.w}×${dragImgSize.h}`
                    :`${settings.imageX},${settings.imageY}`
                  }
                </div>
                {/* Bottom-right resize handle */}
                <div
                  onMouseDown={onImgResizeStart}
                  style={{
                    position:'absolute',right:-5,bottom:-5,
                    width:11,height:11,
                    background:T.accent,
                    border:`1px solid ${T.bg}`,
                    cursor:'nwse-resize',
                    zIndex:31,
                  }}
                />
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );

  // ━━━━━━━━ STUDIO TAB ━━━━━━━━
  const STUDIO_SUBS=[['art','Album Art'],['label','Label Maker'],['flyer','Flyer Maker']];
  const studioTab=(
    <div style={{display:'flex',flexDirection:'column',minHeight:'calc(100vh - 44px)'}}>
      {/* Studio sub-nav */}
      <div style={{display:'flex',alignItems:'center',gap:0,background:T.panel,borderBottom:`1px solid ${T.border}`,flexShrink:0,paddingLeft:12}}>
        {STUDIO_SUBS.map(([id,lbl])=>(
          <button key={id} onClick={()=>{setStudioSubTab(id);saveLS('tl_studio_sub',id);}}
            style={{padding:'7px 16px',background:'transparent',color:studioSubTab===id?T.accent:T.muted,
              border:'none',borderBottom:studioSubTab===id?`2px solid ${T.accent}`:'2px solid transparent',
              fontFamily:'inherit',fontSize:9,letterSpacing:'0.12em',textTransform:'uppercase',cursor:'pointer',
              fontWeight:studioSubTab===id?700:400}}>
            {lbl}
          </button>
        ))}
        <div style={{flex:1}}/>
        {activeEntry&&<span style={{fontSize:7,color:T.muted,padding:'0 12px',letterSpacing:'0.08em'}}>
          {activeEntry.title||'Untitled'} · {activeEntry.artist||'—'}
        </span>}
      </div>
      {/* Sub-tab content */}
      <div style={{flex:1,display:'flex',flexDirection:'column'}}>
        {studioSubTab==='art'&&(
          <AlbumArtEditor T={T} artState={artState} setArtState={setArt} fields={fields} meta={meta}/>
        )}
        {studioSubTab==='label'&&labelTab}
        {studioSubTab==='flyer'&&(
          <div style={{flex:1,display:'flex',alignItems:'center',justifyContent:'center',flexDirection:'column',gap:12,opacity:0.4}}>
            <div style={{fontSize:40}}>✦</div>
            <div style={{fontSize:10,color:T.muted,letterSpacing:'0.2em',textTransform:'uppercase'}}>Flyer Maker</div>
            <div style={{fontSize:8,color:T.muted}}>Coming soon</div>
          </div>
        )}
      </div>
    </div>
  );

  // ━━━━━━━━ CODES CATALOG TAB ━━━━━━━━
  const catalogTab=(
    <div style={{maxWidth:680,margin:'0 auto',padding:'24px 16px'}}>
      <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:16}}>
        <div style={h2S}>Saved Codes</div>
        <div style={{display:'flex',gap:8}}>
          <button onClick={()=>{const txt=savedCodes.map(c=>`${c.code}  ${c.desc||getCodeDesc(c.code)}`).join('\n');const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([txt],{type:'text/plain'}));a.download='saved-codes.txt';a.click();}} style={{...mkBtn(T),padding:'6px 12px',fontSize:9}}>📥 Export TXT</button>
          {savedCodes.length>0&&<button onClick={()=>{if(window.confirm('Clear all saved codes?'))setSavedCodes([]);}} style={{...mkBtn(T),padding:'6px 12px',fontSize:9,color:'#f87171'}}>Clear All</button>}
        </div>
      </div>
      {savedCodes.length===0?(
        <div style={{...mkCard(T),textAlign:'center',padding:40}}>
          <div style={{fontSize:32,opacity:0.15,marginBottom:12}}>◈</div>
          <div style={{...mS}}>No codes saved yet. Generate codes in the Classify tab and save them here.</div>
        </div>
      ):(
        <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:8}}>
          {savedCodes.map((c,i)=>(
            <div key={i} style={{...mkCard(T),marginBottom:0,display:'flex',flexDirection:'column',gap:6}}>
              <div style={{display:'flex',alignItems:'flex-start',justifyContent:'space-between'}}>
                <div style={{fontFamily:'monospace',fontSize:22,fontWeight:700,color:T.accent,letterSpacing:'0.1em'}}>{c.code}</div>
                <button onClick={()=>setSavedCodes(savedCodes.filter((_,j)=>j!==i))} style={{...btnMini,color:'#f87171',fontSize:13}}>✕</button>
              </div>
              <div style={{fontSize:9,color:T.muted,lineHeight:1.5,flex:1}}>{c.desc||getCodeDesc(c.code)}</div>
              {c.saved&&<div style={{fontSize:7,color:T.muted,letterSpacing:'0.06em'}}>{c.saved}</div>}
              <div style={{display:'flex',gap:5}}>
                <button onClick={()=>{navigator.clipboard.writeText(c.code);}} style={{...mkBtn(T),flex:1,padding:'5px 0',fontSize:8}}>📋 Copy</button>
                <button onClick={()=>sendToLabel(c.code)} style={{...mkBtn(T,true),flex:1,padding:'5px 0',fontSize:8}}>🏷 Label</button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
  // ━━━━━━━━ RENDER ━━━━━━━━
  return(
    <LicenseGate T={T} bypass={true}>{/* ← set bypass=false to enforce in production */}
    <div style={{minHeight:'100vh',display:'flex',flexDirection:'column',background:T.bg,color:T.text}}>
      {/* ── LIBRARY RECONNECT BANNER — appears on reopen when permission needs one click ── */}
      {permState==='needs-prompt'&&(
        <div style={{background:T.accent,color:T.bg,display:'flex',alignItems:'center',justifyContent:'space-between',padding:'7px 16px',flexShrink:0,gap:12}}>
          <span style={{fontSize:9,letterSpacing:'0.08em'}}>📁 <strong>{folderName}</strong> — click to reconnect your library</span>
          <div style={{display:'flex',gap:6}}>
            <button onClick={reconnect} style={{background:T.bg,color:T.accent,border:'none',fontFamily:'inherit',fontSize:9,fontWeight:700,letterSpacing:'0.1em',padding:'4px 14px',cursor:'pointer',borderRadius:T.r||0}}>RECONNECT</button>
            <button onClick={clearFolder} style={{background:'transparent',color:T.bg,border:`1px solid ${T.bg}66`,fontFamily:'inherit',fontSize:9,padding:'4px 10px',cursor:'pointer',borderRadius:T.r||0,opacity:0.7}}>✕</button>
          </div>
        </div>
      )}
      {tabBar}
      <div style={{flex:1,minHeight:0,overflow:'auto',background:T.bg,paddingBottom:0}}>
        {tab==='info'&&infoTab}
        {tab==='archive'&&archiveTab}
        {tab==='metadata'&&metadataTab}
        {tab==='classify'&&classifyTab}
        {tab==='studio'&&studioTab}
        {tab==='catalog'&&catalogTab}
        <div style={{display:tab==='viz'?'flex':'none',minHeight:'calc(100vh - 44px)',flexDirection:'column'}}>
          <PlayerView T={T} audioElRef={audioElRef} audioObjectUrl={audioObjectUrl} activeEntry={activeEntry} activeEid={activeEid} meta={meta} audioFile={audioFile} entries={entries} profiles={profiles} activePid={activePid} setActivePid={setActivePid} loadEntry={loadEntry} setAudioObjectUrl={setAudioObjectUrl} setAudioFile={setAudioFile} playerVisible={!!audioObjectUrl&&!appTheme.playerAutoHide}/>
        </div>
      </div>
      {/* Hidden off-screen div for archive label export */}
      {archiveLabelExport&&(
        <div ref={archiveLabelRef} style={{position:'fixed',left:-9999,top:0,zIndex:-1,pointerEvents:'none',width:archiveLabelExport.settings.labelW}}>
          <TrackLabel fields={archiveLabelExport.fields} settings={archiveLabelExport.settings}/>
        </div>
      )}
      <FloatingPlayer T={T} audioObjectUrl={audioObjectUrl} audioFile={audioFile} activeEntry={activeEntry} meta={meta} autoHide={!!appTheme.playerAutoHide} audioElRef={audioElRef}/>
    </div>
    </LicenseGate>
  );
}

ReactDOM.render(<App/>,document.getElementById('root'));
</script>
</body>
</html>
